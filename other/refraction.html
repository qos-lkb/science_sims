<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Refraction Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            touch-action: none;
            /* Prevent pull-to-refresh on mobile */
        }

        canvas {
            touch-action: none;
        }

        .glass-panel {
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
    </style>
</head>

<body
    class="bg-gray-950 text-gray-100 min-h-screen flex flex-col items-center justify-center font-sans selection:bg-blue-500 selection:text-white">

    <div class="container mx-auto p-4 flex flex-col lg:flex-row gap-6 max-w-7xl h-screen max-h-[900px]">

        <!-- Canvas Area -->
        <div
            class="flex-1 glass-panel rounded-2xl shadow-2xl p-1 flex justify-center items-center relative overflow-hidden order-2 lg:order-1">
            <canvas id="myCanvas" width="700" height="600"
                class="w-full h-full object-contain cursor-crosshair"></canvas>

            <!-- Floating Info Overlay -->
            <div class="absolute top-4 left-4 pointer-events-none">
                <div class="bg-black/50 backdrop-blur-md rounded-lg p-3 text-sm border border-white/10 shadow-lg"
                    id="angle-display">
                    <!-- Content will be dynamically updated -->
                </div>
            </div>
        </div>

        <!-- Controls Area -->
        <div
            class="w-full lg:w-96 glass-panel rounded-2xl shadow-2xl p-6 flex flex-col gap-6 order-1 lg:order-2 overflow-y-auto">
            <div class="border-b border-gray-700 pb-4">
                <h1
                    class="text-3xl font-bold bg-gradient-to-r from-blue-400 to-purple-500 bg-clip-text text-transparent">
                    Refraction Lab</h1>
                <p class="text-gray-400 text-sm mt-1">Explore how light bends between media.</p>
            </div>

            <!-- Medium 1 Control -->
            <div class="space-y-3">
                <label class="flex items-center gap-2 text-sm font-semibold text-blue-300 uppercase tracking-wider">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7"></path>
                    </svg>
                    Medium 1 (Top)
                </label>
                <div class="grid grid-cols-2 gap-2" id="medium1-buttons">
                    <!-- Buttons injected by JS -->
                </div>
            </div>

            <!-- Medium 2 Control -->
            <div class="space-y-3">
                <label class="flex items-center gap-2 text-sm font-semibold text-purple-300 uppercase tracking-wider">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                    </svg>
                    Medium 2 (Bottom)
                </label>
                <div class="grid grid-cols-2 gap-2" id="medium2-buttons">
                    <!-- Buttons injected by JS -->
                </div>
            </div>

            <!-- Realistic vs Ideal -->
            <div class="mt-auto space-y-3">
                <div class="flex items-center justify-between bg-gray-800/60 border border-gray-700 rounded-xl px-4 py-3 shadow-inner">
                    <p class="text-sm font-semibold text-blue-200">Optics mode:</p>
                    <div class="flex bg-gray-900 rounded-full p-1 border border-gray-700" id="mode-toggle">
                        <button id="mode-realistic"
                            class="px-3 py-1 text-xs font-semibold rounded-full transition-all bg-blue-600 text-white shadow"
                            onclick="setMode(true)">Realistic</button>
                        <button id="mode-ideal"
                            class="px-3 py-1 text-xs font-semibold rounded-full transition-all text-gray-300 hover:text-white"
                            onclick="setMode(false)">Ideal</button>
                    </div>
                </div>

                <!-- Toggle Ray -->
                <div>
                    <button id="showhidebtn"
                        class="group w-full py-3 px-4 bg-gradient-to-r from-blue-600 to-blue-700 hover:from-blue-500 hover:to-blue-600 rounded-xl transition-all shadow-lg hover:shadow-blue-500/25 flex items-center justify-center gap-2 font-semibold"
                        onclick="toggleRay()">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z">
                            </path>
                        </svg>
                        <span>Hide Refracted Ray</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Hidden canvas for torch buffering -->
    <canvas id="torchCanvas" width="200" height="200" class="hidden"></canvas>

    <script>
        // --- Configuration & State ---
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');
        const torchCanvas = document.getElementById('torchCanvas');
        const torchCtx = torchCanvas.getContext('2d');

        let torchPosX = 250;
        let torchPosY = 50;
        let n1 = 1;
        let n2 = 1.33;
        let medium1Name = "Vacuum / Air";
        let medium2Name = "Water";
        let showRay = true;
        let useFresnel = true; // Realistic mode by default
        let isDragging = false;

        // --- Assets ---
        // Simple SVG Laser Pointer
        const laserSvg = `
        <svg xmlns="http://www.w3.org/2000/svg" width="100" height="40" viewBox="0 0 100 40">
            <defs>
                <linearGradient id="bodyGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                    <stop offset="0%" style="stop-color:#475569;stop-opacity:1" />
                    <stop offset="50%" style="stop-color:#94a3b8;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#475569;stop-opacity:1" />
                </linearGradient>
            </defs>
            <!-- Laser Body -->
            <rect x="0" y="10" width="80" height="20" rx="4" ry="4" fill="url(#bodyGrad)" stroke="#334155" stroke-width="1"/>
            <!-- Grip details -->
            <line x1="10" y1="10" x2="10" y2="30" stroke="#334155" stroke-width="1" opacity="0.5"/>
            <line x1="15" y1="10" x2="15" y2="30" stroke="#334155" stroke-width="1" opacity="0.5"/>
            <line x1="20" y1="10" x2="20" y2="30" stroke="#334155" stroke-width="1" opacity="0.5"/>
            <!-- Button -->
            <rect x="50" y="8" width="12" height="4" rx="1" fill="#ef4444" />
            <!-- Emitter Tip -->
            <path d="M 80 12 L 85 12 L 85 28 L 80 28 Z" fill="#1e293b" />
            <circle cx="85" cy="20" r="2" fill="#ef4444" />
        </svg>`.trim();

        const torchImg = new Image();
        torchImg.src = "data:image/svg+xml;base64," + btoa(laserSvg);
        torchImg.onload = () => drawScene();

        // --- Media Definitions ---
        const media = [
            { name: "Vacuum / Air", n: 1.0 },
            { name: "Water", n: 1.33 },
            { name: "Perspex", n: 1.5 },
            { name: "Glass", n: 1.5 }, // Keeping duplicate n as per original for variety
            { name: "Diamond", n: 2.42 },
            { name: "Mystery X", n: 1.2 },
            { name: "Mystery Y", n: 1.95 }
        ];

        // --- Initialization ---
        function initUI() {
            const createBtn = (m, type) => {
                const btn = document.createElement('button');
                const isSelected = (type === 1 && medium1Name === m.name) || (type === 2 && medium2Name === m.name);

                btn.className = `p-2 rounded-lg text-sm font-medium transition-all border border-transparent hover:scale-105 active:scale-95 ${isSelected
                    ? (type === 1 ? 'bg-blue-600 text-white border-blue-400 shadow-lg shadow-blue-900/50' : 'bg-purple-600 text-white border-purple-400 shadow-lg shadow-purple-900/50')
                    : 'bg-gray-700 text-gray-300 hover:bg-gray-600 hover:text-white'
                    }`;
                const displayN = (m.name.includes("Mystery X") || m.name.includes("Mystery Y")) ? "?" : m.n;
                btn.textContent = `${m.name} (n=${displayN})`;
                btn.onclick = () => {
                    if (type === 1) {
                        n1 = m.n;
                        medium1Name = m.name;
                    } else {
                        n2 = m.n;
                        medium2Name = m.name;
                    }
                    initUI(); // Re-render buttons to update active state
                    drawScene();
                };
                return btn;
            };

            const div1 = document.getElementById('medium1-buttons');
            const div2 = document.getElementById('medium2-buttons');
            div1.innerHTML = '';
            div2.innerHTML = '';

            media.forEach(m => {
                if (m.name === "Mystery Y") return; // Skip Y for top
                div1.appendChild(createBtn(m, 1));
            });
            media.forEach(m => {
                if (m.name === "Mystery X") return; // Skip X for bottom
                div2.appendChild(createBtn(m, 2));
            });
        }

        // --- Physics & Rendering ---
        function drawScene() {
            // 1. Clear Canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 2. Draw Media Backgrounds
            // Medium 1 (Top)
            const grad1 = ctx.createLinearGradient(0, 0, 0, 300);
            const opacity1 = Math.min(0.8, (n1 - 1) * 0.5);
            grad1.addColorStop(0, `rgba(200, 230, 255, ${opacity1 * 0.5})`);
            grad1.addColorStop(1, `rgba(100, 180, 255, ${opacity1})`);
            ctx.fillStyle = grad1;
            ctx.fillRect(0, 0, 700, 300);

            // Medium 2 (Bottom)
            const grad2 = ctx.createLinearGradient(0, 300, 0, 600);
            const opacity2 = Math.min(0.8, (n2 - 1) * 0.5);
            grad2.addColorStop(0, `rgba(100, 180, 255, ${opacity2})`);
            grad2.addColorStop(1, `rgba(50, 100, 200, ${opacity2 * 1.5})`);
            ctx.fillStyle = grad2;
            ctx.fillRect(0, 300, 700, 600);

            // 3. Draw Boundary & Normal
            ctx.beginPath();
            ctx.moveTo(0, 300);
            ctx.lineTo(700, 300);
            ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.beginPath();
            ctx.setLineDash([5, 5]);
            ctx.moveTo(350, 50);
            ctx.lineTo(350, 550);
            ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.setLineDash([]);

            // 4. Calculate Physics
            const boundaryY = 300;
            const boundaryX = 350;
            const dx = boundaryX - torchPosX;
            const dy = boundaryY - torchPosY;

            // Calculate angle with the vertical normal (0 to 90 degrees)
            // Math.abs(dx) and Math.abs(dy) ensures we get the acute angle with vertical
            const incidentAngleRad = Math.atan2(Math.abs(dx), Math.abs(dy));
            const incidentAngleDeg = incidentAngleRad * 180 / Math.PI;

            // Determine source medium
            const isTop = torchPosY < 300;
            const nSource = isTop ? n1 : n2;
            const nDest = isTop ? n2 : n1;

            // Snell's Law: n1 * sin(theta1) = n2 * sin(theta2)
            const sinTheta1 = Math.sin(incidentAngleRad);
            const sinTheta2 = (nSource / nDest) * sinTheta1;

            let refractedAngleRad = null;
            let isTIR = false;

            if (sinTheta2 <= 1.000001) { // Tolerance for float errors
                refractedAngleRad = Math.asin(Math.min(1, sinTheta2));
            } else {
                isTIR = true;
            }

            // Fresnel reflectance/transmittance to modulate brightness
            let reflectance = 0;
            let transmittance = 1;
            if (isTIR) {
                reflectance = 1;
                transmittance = 0;
            } else if (useFresnel) {
                const cosTheta1 = Math.cos(incidentAngleRad);
                const cosTheta2 = Math.cos(refractedAngleRad);
                const denomS = (nSource * cosTheta1 + nDest * cosTheta2) || 1e-6;
                const denomP = (nSource * cosTheta2 + nDest * cosTheta1) || 1e-6;
                const rs = Math.pow((nSource * cosTheta1 - nDest * cosTheta2) / denomS, 2);
                const rp = Math.pow((nSource * cosTheta2 - nDest * cosTheta1) / denomP, 2);
                reflectance = Math.min(1, Math.max(0, (rs + rp) / 2));
                transmittance = 1 - reflectance;
            }

            // 5. Draw Rays
            // Laser Style
            ctx.shadowBlur = 10;
            ctx.shadowColor = "red";
            ctx.lineCap = "round";

            // Incident Ray
            ctx.beginPath();
            ctx.moveTo(torchPosX, torchPosY);
            ctx.lineTo(boundaryX, boundaryY);
            ctx.strokeStyle = "#ff3333";
            ctx.lineWidth = 4;
            ctx.stroke();

            // Core
            ctx.shadowBlur = 0;
            ctx.beginPath();
            ctx.moveTo(torchPosX, torchPosY);
            ctx.lineTo(boundaryX, boundaryY);
            ctx.strokeStyle = "#ffcccc";
            ctx.lineWidth = 1;
            ctx.stroke();

            // Refracted / Reflected Ray
            if (showRay) {
                const rayLen = 600;
                // Direction multiplier for X: if dx > 0 (torch left), ray goes right (+1).
                // If dx < 0 (torch right), ray goes left (-1).
                const dirX = dx >= 0 ? 1 : -1;

                // Reflection back into source medium.
                const reflectDirY = isTop ? -1 : 1;
                const reflectEndX = boundaryX + Math.sin(incidentAngleRad) * rayLen * dirX;
                const reflectEndY = boundaryY + Math.cos(incidentAngleRad) * rayLen * reflectDirY;
                // Make reflection very faint at small angles (low reflectance)
                const reflectAlpha = reflectance;

                ctx.shadowBlur = 4 + reflectance * 8;
                ctx.shadowColor = `rgba(255, 80, 80, ${reflectAlpha})`;
                ctx.beginPath();
                ctx.moveTo(boundaryX, boundaryY);
                ctx.lineTo(reflectEndX, reflectEndY);
                ctx.strokeStyle = `rgba(255, 85, 85, ${reflectAlpha})`;
                ctx.lineWidth = 1 + reflectance * 3;
                ctx.stroke();

                // Core for reflected ray
                ctx.shadowBlur = 0;
                ctx.beginPath();
                ctx.moveTo(boundaryX, boundaryY);
                ctx.lineTo(reflectEndX, reflectEndY);
                ctx.strokeStyle = `rgba(255, 204, 204, ${reflectAlpha})`;
                ctx.lineWidth = 1.5;
                ctx.stroke();

                // Refracted ray into destination medium, dimmed near critical angle
                if (!isTIR && transmittance > 0.01) {
                    const refractDirY = isTop ? 1 : -1;
                    const refractEndX = boundaryX + Math.sin(refractedAngleRad) * rayLen * dirX;
                    const refractEndY = boundaryY + Math.cos(refractedAngleRad) * rayLen * refractDirY;
                    const refractAlpha = 0.15 + 0.85 * transmittance;

                    ctx.shadowBlur = 10 + transmittance * 8;
                    ctx.shadowColor = `rgba(255, 70, 70, ${refractAlpha})`;
                    ctx.beginPath();
                    ctx.moveTo(boundaryX, boundaryY);
                    ctx.lineTo(refractEndX, refractEndY);
                    ctx.strokeStyle = `rgba(255, 51, 51, ${refractAlpha})`;
                    ctx.lineWidth = 3 + transmittance * 2;
                    ctx.stroke();

                    // Core
                    ctx.shadowBlur = 0;
                    ctx.beginPath();
                    ctx.moveTo(boundaryX, boundaryY);
                    ctx.lineTo(refractEndX, refractEndY);
                    ctx.strokeStyle = `rgba(255, 204, 204, ${refractAlpha})`;
                    ctx.lineWidth = 1.2;
                    ctx.stroke();
                }
            }

            // 6. Draw Torch
            const angleToTarget = Math.atan2(300 - torchPosY, 350 - torchPosX);

            torchCtx.clearRect(0, 0, torchCanvas.width, torchCanvas.height);
            torchCtx.save();
            torchCtx.translate(torchCanvas.width / 2, torchCanvas.height / 2);
            torchCtx.rotate(angleToTarget);
            if (torchImg.complete) {
                torchCtx.drawImage(torchImg, -50, -20, 100, 40);
            }
            torchCtx.restore();

            ctx.drawImage(torchCanvas, torchPosX - torchCanvas.width / 2, torchPosY - torchCanvas.height / 2);

            // 7. Update Text Info
            const angleDisplay = document.getElementById('angle-display');
            const incidentHTML = `<div class="flex items-center gap-2 mb-1">
                <div class="w-3 h-3 rounded-full bg-red-500 shadow-[0_0_10px_rgba(239,68,68,0.8)]"></div>
                <span class="font-mono text-red-300">Angle of incidence: <span class="font-bold text-white">${Math.round(incidentAngleDeg)}°</span></span>
            </div>`;

            let refractionHTML = '';
            if (showRay) {
                if (isTIR) {
                    refractionHTML = `<div class="flex items-center gap-2">
                        <div class="w-3 h-3 rounded-full bg-yellow-500 shadow-[0_0_10px_rgba(234,179,8,0.8)]"></div>
                        <span class="font-mono text-yellow-300">Total Internal Reflection</span>
                    </div>`;
                } else {
                    const rDeg = Math.round(refractedAngleRad * 180 / Math.PI);
                    refractionHTML = `<div class="flex items-center gap-2">
                        <div class="w-3 h-3 rounded-full bg-blue-500 shadow-[0_0_10px_rgba(59,130,246,0.8)]"></div>
                        <span class="font-mono text-blue-300">Angle of refraction: <span class="font-bold text-white">${rDeg}°</span></span>
                    </div>`;
                }
            }

            // Order based on torch position: if at bottom, show refraction first
            if (isTop) {
                angleDisplay.innerHTML = incidentHTML + refractionHTML;
            } else {
                angleDisplay.innerHTML = refractionHTML + incidentHTML;
            }
        }

        function toggleRay() {
            showRay = !showRay;
            const btn = document.getElementById('showhidebtn');
            const span = btn.querySelector('span');
            if (showRay) {
                span.textContent = "Hide Refracted Ray";
                btn.classList.remove('opacity-50');
            } else {
                span.textContent = "Show Refracted Ray";
                btn.classList.add('opacity-50');
            }
            drawScene();
        }

        function setMode(fresnelEnabled) {
            useFresnel = fresnelEnabled;
            updateModeButtons();
            drawScene();
        }

        function updateModeButtons() {
            const realBtn = document.getElementById('mode-realistic');
            const idealBtn = document.getElementById('mode-ideal');
            if (!realBtn || !idealBtn) return;

            if (useFresnel) {
                realBtn.className = "px-3 py-1 text-xs font-semibold rounded-full transition-all bg-blue-600 text-white shadow";
                idealBtn.className = "px-3 py-1 text-xs font-semibold rounded-full transition-all text-gray-300 hover:text-white";
            } else {
                realBtn.className = "px-3 py-1 text-xs font-semibold rounded-full transition-all text-gray-300 hover:text-white";
                idealBtn.className = "px-3 py-1 text-xs font-semibold rounded-full transition-all bg-purple-600 text-white shadow";
            }
        }

        // --- Event Listeners ---
        function getMousePos(evt) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (evt.clientX - rect.left) * scaleX,
                y: (evt.clientY - rect.top) * scaleY
            };
        }

        function handleMove(e) {
            if (!isDragging) return;
            e.preventDefault(); // Prevent scrolling on touch
            const pos = getMousePos(e.touches ? e.touches[0] : e);

            // Constrain to canvas
            torchPosX = Math.max(20, Math.min(680, pos.x));
            torchPosY = Math.max(20, Math.min(580, pos.y));

            drawScene();
        }

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            handleMove(e);
        });

        canvas.addEventListener('touchstart', (e) => {
            isDragging = true;
            handleMove(e);
        }, { passive: false });

        window.addEventListener('mousemove', handleMove);
        window.addEventListener('touchmove', handleMove, { passive: false });

        window.addEventListener('mouseup', () => isDragging = false);
        window.addEventListener('touchend', () => isDragging = false);

        // Resize observer to handle responsive canvas scaling if needed (CSS handles most)

        // Start
        initUI();
        updateModeButtons();
        // Initial draw will happen when image loads
        setTimeout(drawScene, 100); // Fallback
    </script>
</body>

</html>
