<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HKDSE Projectile Motion</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
    
    <style>
        body { font-family: 'Segoe UI', 'Microsoft JhengHei', sans-serif; background-color: #f3f4f6; }
        canvas { border-radius: 8px; touch-action: none; }
        
        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { opacity: 1; }
        
        .stat-box { @apply bg-white p-2 rounded shadow text-xs font-mono border border-gray-100; }
        .stat-label { @apply text-gray-500 block text-[10px] uppercase tracking-wider mb-0.5; }
        .stat-value { @apply block font-bold text-gray-800 text-sm; }

        .lang-btn.active { @apply bg-blue-600 text-white border-blue-600; }
        .lang-btn.inactive { @apply bg-white text-gray-500 border-gray-300 hover:bg-gray-50; }
    </style>
</head>
<body class="h-screen flex flex-col lg:flex-row overflow-hidden">

    <div class="w-full lg:w-80 bg-white p-4 border-r border-gray-200 z-10 flex flex-col gap-3 overflow-y-auto shrink-0 shadow-lg">
        
        <div class="flex justify-between items-start">
            <div>
                <h1 id="lbl-title" class="text-xl font-bold text-blue-700 tracking-tight">Projectile Motion</h1>
                <p id="lbl-subtitle" class="text-xs text-gray-400 font-medium">HKDSE Physics (Force & Motion)</p>
            </div>
            <div class="flex gap-1">
                <button onclick="setLang('en')" id="btn-lang-en" class="lang-btn active text-[10px] font-bold px-2 py-1 rounded border transition">EN</button>
                <button onclick="setLang('zh')" id="btn-lang-zh" class="lang-btn inactive text-[10px] font-bold px-2 py-1 rounded border transition">‰∏≠</button>
            </div>
        </div>

        <div class="space-y-4 border-b border-gray-100 pb-4 bg-gray-50 p-3 rounded-lg">
            
            <div>
                <label id="lbl-u" class="block text-xs font-bold text-gray-700 mb-1">Initial Velocity (u)</label>
                <div class="flex items-center gap-2">
                    <input type="range" id="u-slider" min="1" max="100" value="25" step="0.1" class="flex-1 accent-blue-600 h-1.5 bg-gray-300 rounded-lg appearance-none cursor-pointer">
                    <input type="number" id="u-input" min="1" max="100" step="0.1" value="25" class="w-16 text-right text-sm border border-gray-300 rounded px-1 py-0.5 focus:border-blue-500 font-mono">
                    <span class="text-xs font-bold text-gray-500 w-6">m/s</span>
                </div>
            </div>

            <div>
                <label id="lbl-theta" class="block text-xs font-bold text-gray-700 mb-1">Launch Angle (Œ∏)</label>
                <div class="flex items-center gap-2">
                    <input type="range" id="theta-slider" min="-90" max="90" value="45" step="0.1" class="flex-1 accent-blue-600 h-1.5 bg-gray-300 rounded-lg appearance-none cursor-pointer">
                    <input type="number" id="theta-input" min="-90" max="90" step="0.1" value="45" class="w-16 text-right text-sm border border-gray-300 rounded px-1 py-0.5 focus:border-blue-500 font-mono">
                    <span class="text-xs font-bold text-gray-500 w-6">deg</span>
                </div>
            </div>

            <div>
                <label id="lbl-h" class="block text-xs font-bold text-gray-700 mb-1">Initial Height (h)</label>
                <div class="flex items-center gap-2">
                    <input type="range" id="h-slider" min="0" max="100" value="0" step="0.1" class="flex-1 accent-blue-600 h-1.5 bg-gray-300 rounded-lg appearance-none cursor-pointer">
                    <input type="number" id="h-input" min="0" max="100" step="0.1" value="0" class="w-16 text-right text-sm border border-gray-300 rounded px-1 py-0.5 focus:border-blue-500 font-mono">
                    <span class="text-xs font-bold text-gray-500 w-6">m</span>
                </div>
            </div>

            <div class="flex gap-2 pt-1">
                <button id="air-toggle" class="flex-1 bg-white border border-gray-300 text-gray-600 px-2 py-1.5 rounded text-xs font-bold hover:bg-gray-50 transition shadow-sm">Air Resistance: OFF</button>
                <select id="time-scale" class="bg-white border border-gray-300 text-gray-700 text-xs rounded px-2 font-bold shadow-sm focus:outline-none">
                    <option value="1">1.0x Speed</option>
                    <option value="0.5">0.5x Slow</option>
                    <option value="0.1">0.1x Analysis</option>
                </select>
            </div>
        </div>

        <div class="grid grid-cols-3 gap-2">
            <button id="btn-fire" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 rounded shadow transition text-sm flex items-center justify-center gap-1">üöÄ <span id="txt-fire">FIRE</span></button>
            <button id="btn-pause" class="bg-amber-500 hover:bg-amber-600 text-white font-bold py-2 rounded shadow transition text-sm">PAUSE</button>
            <button id="btn-clear" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 rounded shadow transition text-sm">CLEAR</button>
        </div>

        <div class="flex-1 min-h-0 flex flex-col">
            <h3 class="font-bold text-gray-700 text-xs mb-2 flex items-center gap-2 mt-2">
                <span class="w-2 h-2 rounded-full bg-gray-400" id="status-dot"></span>
                <span id="lbl-realtime">Real-time Data</span>
            </h3>
            <div class="grid grid-cols-2 gap-2 mb-2">
                <div class="stat-box border-l-2 border-l-blue-500"><span id="lbl-t" class="stat-label">Time (t)</span><br><span id="data-t" class="stat-value">0.00 s</span></div>
                <div class="stat-box border-l-2 border-l-green-500"><span id="lbl-v" class="stat-label">Speed (v)</span><br><span id="data-v" class="stat-value">0.00 m/s</span></div>
                <div class="stat-box"><span id="lbl-x" class="stat-label">Pos X (x)</span><br><span id="data-x" class="stat-value">0.00 m</span></div>
                <div class="stat-box"><span id="lbl-y" class="stat-label">Pos Y (y)</span><br><span id="data-y" class="stat-value">0.00 m</span></div>
                <div class="stat-box"><span id="lbl-vx" class="stat-label">Vel X (v<sub>x</sub>)</span><br><span id="data-vx" class="stat-value text-red-600">0.00 m/s</span></div>
                <div class="stat-box"><span id="lbl-vy" class="stat-label">Vel Y (v<sub>y</sub>)</span><br><span id="data-vy" class="stat-value text-purple-600">0.00 m/s</span></div>
            </div>

            <div id="results-panel" class="hidden bg-emerald-50 border border-emerald-200 p-3 rounded-lg mt-auto">
                <h3 class="font-bold text-emerald-800 text-xs mb-2 uppercase tracking-wide border-b border-emerald-200 pb-1">
                    <span id="lbl-results">Experiment Results</span> <span id="res-type" class="normal-case font-normal opacity-70"></span>
                </h3>
                <div class="space-y-1.5 text-xs text-emerald-900 font-mono">
                    <div class="flex justify-between"><span id="lbl-res-time">Total Time:</span><span id="res-time" class="font-bold">--</span></div>
                    <div class="flex justify-between"><span id="lbl-res-height">Max Height:</span><span id="res-height" class="font-bold">--</span></div>
                    <div class="flex justify-between"><span id="lbl-res-range">Max Range:</span><span id="res-range" class="font-bold">--</span></div>
                </div>
            </div>
        </div>
    </div>

    <div class="flex-1 bg-gray-100 flex flex-col p-3 gap-3 w-full overflow-hidden relative">
        
        <div id="canvas-container" class="flex-1 bg-white rounded-lg shadow-sm border border-gray-200 relative w-full overflow-hidden min-h-[300px]">
            <div id="pause-overlay" class="hidden absolute top-4 right-4 bg-yellow-100 text-yellow-800 px-3 py-1 rounded font-bold text-xs shadow border border-yellow-300 z-10 pointer-events-none">PAUSED</div>
        </div>

        <div class="h-40 flex gap-3 w-full shrink-0">
            <div class="flex-1 bg-white rounded-lg shadow-sm border border-gray-200 p-2 relative flex flex-col">
                <div class="flex justify-between items-center mb-1">
                    <select id="graph1-select" class="text-[10px] font-bold text-gray-700 border border-gray-300 rounded bg-gray-50 px-1 py-0.5 focus:outline-none uppercase">
                    </select>
                </div>
                <canvas id="graph1" class="flex-1 w-full h-full"></canvas>
            </div>
            
            <div class="flex-1 bg-white rounded-lg shadow-sm border border-gray-200 p-2 relative flex flex-col">
                <div class="flex justify-between items-center mb-1">
                    <select id="graph2-select" class="text-[10px] font-bold text-gray-700 border border-gray-300 rounded bg-gray-50 px-1 py-0.5 focus:outline-none uppercase">
                    </select>
                </div>
                <canvas id="graph2" class="flex-1 w-full h-full"></canvas>
            </div>
        </div>
    </div>

    <script>
        // --- TRANSLATION DATA ---
        const LANG = {
            en: {
                title: "Projectile Motion", subtitle: "HKDSE Physics (Force & Motion)", u: "Initial Velocity (u)", theta: "Launch Angle (Œ∏)", h: "Initial Height (h)",
                air: "Air Resistance", on: "ON", off: "OFF", speed1: "1.0x Speed", speed05: "0.5x Slow", speed01: "0.1x Analysis",
                fire: "FIRE", pause: "PAUSE", resume: "RESUME", clear: "CLEAR", realtime: "Real-time Data",
                t: "Time (t)", v: "Speed (v)", x: "Displacement X (x)", y: "Displacement Y (y)", vx: "Velocity X (vx)", vy: "Velocity Y (vy)",
                results: "Experiment Results", resTime: "Total Time:", resHeight: "Max Height:", resRange: "Max Range:",
                theo: "(Theoretical)", sim: "(Simulated)",
                graphs: { vy: "Velocity Y (vy)", vx: "Velocity X (vx)", v: "Speed (v)", y: "Displacement Y (y)", x: "Displacement X (x)", ke: "Kinetic Energy (KE)", pe: "Potential Energy (PE)", ay: "Acceleration (ay)" }
            },
            zh: {
                title: "ÊããÈ´îÈÅãÂãï", subtitle: "HKDSE Áâ©ÁêÜ (ÂäõÂíåÈÅãÂãï)", u: "ÂàùÈÄüÂ∫¶ (u)", theta: "ÁôºÂ∞ÑËßíÂ∫¶ (Œ∏)", h: "ÂàùÂßãÈ´òÂ∫¶ (h)",
                air: "Á©∫Ê∞£ÈòªÂäõ", on: "Èñã", off: "Èóú", speed1: "1.0x ÈÄüÂ∫¶", speed05: "0.5x ÊÖ¢Âãï‰Ωú", speed01: "0.1x ÂàÜÊûêÊ®°Âºè",
                fire: "ÁôºÂ∞Ñ", pause: "Êö´ÂÅú", resume: "ÁπºÁ∫å", clear: "Ê∏ÖÈô§", realtime: "ÂØ¶ÊôÇÊï∏Êìö",
                t: "ÊôÇÈñì (t)", v: "ÈÄüÁéá (v)", x: "‰ΩçÁßª X (x)", y: "‰ΩçÁßª Y (y)", vx: "ÈÄüÂ∫¶ X (vx)", vy: "ÈÄüÂ∫¶ Y (vy)",
                results: "ÂØ¶È©óÁµêÊûú", resTime: "Á∏ΩÊôÇÈñì:", resHeight: "ÊúÄÈ´òÈªû:", resRange: "ÊúÄÈÅ†Â∞ÑÁ®ã:",
                theo: "(ÁêÜË´ñÂÄº)", sim: "(Ê®°Êì¨ÂÄº)",
                graphs: { vy: "ÈÄüÂ∫¶ Y (vy)", vx: "ÈÄüÂ∫¶ X (vx)", v: "ÈÄüÁéá (v)", y: "‰ΩçÁßª Y (y)", x: "‰ΩçÁßª X (x)", ke: "ÂãïËÉΩ (KE)", pe: "Âã¢ËÉΩ (PE)", ay: "Âä†ÈÄüÂ∫¶ (ay)" }
            }
        };

        // --- CONSTANTS ---
        const g = 9.81; 
        let PIXELS_PER_METER = 8; // Will be updated dynamically
        const GROUND_OFFSET = 50;
        
        // --- APP STATE ---
        let currentLang = 'en';
        let lastResultTypeKey = null;

        let state = {
            t: 0, pos: null, vel: null, acc: null, maxHeightSim: 0,
            running: false, paused: false, finished: false,
            history: [], previousRunPath: null, savedPaths: [] 
        };

        let params = { u: 25, theta: 45, h: 0, airResistance: false, timeScale: 1.0 };

        // --- DOM ELEMENTS ---
        const ui = {
            sliders: { u: document.getElementById('u-slider'), theta: document.getElementById('theta-slider'), h: document.getElementById('h-slider') },
            inputs: { u: document.getElementById('u-input'), theta: document.getElementById('theta-input'), h: document.getElementById('h-input') },
            btns: { fire: document.getElementById('btn-fire'), pause: document.getElementById('btn-pause'), clear: document.getElementById('btn-clear'), air: document.getElementById('air-toggle') },
            data: { t: document.getElementById('data-t'), v: document.getElementById('data-v'), x: document.getElementById('data-x'), y: document.getElementById('data-y'), vx: document.getElementById('data-vx'), vy: document.getElementById('data-vy') },
            statusDot: document.getElementById('status-dot'),
            graphs: { sel1: document.getElementById('graph1-select'), sel2: document.getElementById('graph2-select') },
            txtFire: document.getElementById('txt-fire'),
            timeScale: document.getElementById('time-scale')
        };

        // --- LOCALIZATION ---
        function setLang(lang) {
            currentLang = lang;
            const t = LANG[lang];
            document.getElementById('btn-lang-en').className = `lang-btn ${lang==='en'?'active':'inactive'} text-[10px] font-bold px-2 py-1 rounded border transition`;
            document.getElementById('btn-lang-zh').className = `lang-btn ${lang==='zh'?'active':'inactive'} text-[10px] font-bold px-2 py-1 rounded border transition`;
            document.getElementById('lbl-title').innerText = t.title;
            document.getElementById('lbl-subtitle').innerText = t.subtitle;
            document.getElementById('lbl-u').innerText = t.u;
            document.getElementById('lbl-theta').innerText = t.theta;
            document.getElementById('lbl-h').innerText = t.h;
            document.getElementById('lbl-realtime').innerText = t.realtime;
            document.getElementById('lbl-results').innerText = t.results;
            
            document.getElementById('lbl-t').innerText = t.t;
            document.getElementById('lbl-v').innerText = t.v;
            document.getElementById('lbl-x').innerText = t.x;
            document.getElementById('lbl-y').innerText = t.y;
            document.getElementById('lbl-vx').innerHTML = t.vx.replace('vx', 'v<sub>x</sub>');
            document.getElementById('lbl-vy').innerHTML = t.vy.replace('vy', 'v<sub>y</sub>');

            document.getElementById('lbl-res-time').innerText = t.resTime;
            document.getElementById('lbl-res-height').innerText = t.resHeight;
            document.getElementById('lbl-res-range').innerText = t.resRange;

            ui.btns.clear.innerText = t.clear;
            ui.txtFire.innerText = t.fire;
            updateAirBtnText();
            updatePauseBtnText();
            updateTimeScaleOptions();
            updateGraphDropdowns(ui.graphs.sel1);
            updateGraphDropdowns(ui.graphs.sel2);

            if (lastResultTypeKey) document.getElementById('res-type').innerText = t[lastResultTypeKey];
            if(state.history.length > 0) updateGraphs();
        }

        function updateAirBtnText() {
            const t = LANG[currentLang];
            ui.btns.air.innerText = `${t.air}: ${params.airResistance ? t.on : t.off}`;
        }

        function updatePauseBtnText() {
            const t = LANG[currentLang];
            const overlay = document.getElementById('pause-overlay');
            if (state.paused) {
                ui.btns.pause.innerText = t.resume;
                overlay.innerText = t.pause; 
                overlay.classList.remove('hidden');
            } else {
                ui.btns.pause.innerText = t.pause;
                overlay.classList.add('hidden');
            }
        }

        function updateTimeScaleOptions() {
            const t = LANG[currentLang];
            const sel = ui.timeScale;
            sel.options[0].text = t.speed1;
            sel.options[1].text = t.speed05;
            sel.options[2].text = t.speed01;
        }

        function updateGraphDropdowns(selectEl) {
            const t = LANG[currentLang].graphs;
            const currentVal = selectEl.value;
            selectEl.innerHTML = "";
            const keys = ['vy', 'vx', 'v', 'y', 'x', 'ke', 'pe', 'ay'];
            keys.forEach(key => {
                let opt = document.createElement('option');
                opt.value = key;
                opt.text = t[key];
                selectEl.appendChild(opt);
            });
            selectEl.value = currentVal;
        }

        function toSigFig(num, n = 3) {
            if (Math.abs(num) < 1e-9) return "0.00";
            let val = Number(num);
            if (Math.abs(val) >= 1000) return val.toFixed(0);
            if (Math.abs(val) >= 100) return val.toFixed(1);
            if (Math.abs(val) >= 1) return val.toFixed(2);
            return val.toPrecision(n);
        }

        // --- P5.JS ---
        function setup() {
            let container = document.getElementById('canvas-container');
            let c = createCanvas(container.clientWidth, container.clientHeight);
            c.parent('canvas-container');
            state.pos = createVector(0,0);
            state.vel = createVector(0,0);
            state.acc = createVector(0,0);
            setLang('en');
            resetSimulation(true);
            window.addEventListener('resize', () => {
                resizeCanvas(container.clientWidth, container.clientHeight);
            });
        }

        function draw() {
            background(255);
            
            // --- SMART AUTO-ZOOM LOGIC ---
            // 1. Calculate Theoretical Bounds based on current Inputs
            let rad = radians(params.theta);
            let ux = params.u * Math.cos(rad);
            let uy = params.u * Math.sin(rad);
            
            // Calculate Max Height (Theoretical)
            let peakY = params.h;
            if (uy > 0) peakY += (uy * uy) / (2 * g); // Only add if launching up
            
            // Calculate Max Range (Theoretical) roughly
            let t_flight = 0;
            if (uy < 0 && params.h <= 0) t_flight = 0; // Invalid
            else {
                let delta = Math.sqrt(uy * uy + 2 * g * params.h);
                t_flight = (uy + delta) / g;
            }
            let maxDistX = Math.abs(ux * t_flight);
            
            // Fallback for vertical shots or zero velocity
            if (maxDistX < 1) maxDistX = 10; 
            if (peakY < 1) peakY = 10;
            
            // 2. Determine Scale factors to fit in canvas
            // Padding: Left=60, Right=60, Top=50, Bottom=50 (Ground)
            let marginX = 120; 
            let marginY = 120;
            
            let scaleX = (width - marginX) / maxDistX;
            let scaleY = (height - marginY) / peakY;
            
            // Choose smaller scale to fit both dimensions
            let targetScale = Math.min(scaleX, scaleY);
            
            // Clamp scale to prevent extreme zoom
            targetScale = constrain(targetScale, 0.5, 30);
            
            // 3. Smooth Transition
            PIXELS_PER_METER = lerp(PIXELS_PER_METER, targetScale, 0.1);

            // -----------------------------

            drawGrid();

            if (state.running && !state.paused && !state.finished) {
                let dt = (deltaTime / 1000) * params.timeScale;
                if (dt > 0.05) dt = 0.05; 
                updatePhysics(dt);
            }

            drawPaths();
            drawCannon();
            drawBall();
            
            if (state.running || state.paused) drawVectors();
            if (state.running && !state.paused) updateGraphs();

            updateStatusDot();
        }

        // --- PHYSICS ---
        function updatePhysics(dt) {
            let prevPos = state.pos.copy();
            let prevT = state.t;
            state.t += dt;

            let gravity = createVector(0, -g);
            let drag = createVector(0, 0);
            let currentAccY = -g;

            if (params.airResistance) {
                let k = 0.1;
                drag = state.vel.copy().mult(-1).mult(k);
                state.acc = p5.Vector.add(gravity, drag);
                currentAccY = state.acc.y;
            } else {
                state.acc = gravity;
            }

            state.vel.add(p5.Vector.mult(state.acc, dt));
            state.pos.add(p5.Vector.mult(state.vel, dt));

            if (state.pos.y > state.maxHeightSim) state.maxHeightSim = state.pos.y;
            recordHistory(currentAccY);

            if (state.pos.y <= 0) {
                finishRun(prevPos, prevT, dt);
            } else {
                updateRealtimeData();
            }
        }

        function recordHistory(ay) {
            state.history.push({
                t: state.t, x: state.pos.x, y: state.pos.y,
                vx: state.vel.x, vy: state.vel.y, v: state.vel.mag(),
                ay: ay, ke: 0.5 * Math.pow(state.vel.mag(), 2), pe: 9.81 * state.pos.y
            });
        }

        function finishRun(prevPos, prevT, dt) {
            state.running = false;
            state.finished = true;
            let dy = prevPos.y - state.pos.y;
            let frac = (dy > 1e-9) ? prevPos.y / dy : 0;
            let impactT = prevT + (dt * frac);
            let impactX = prevPos.x + ((state.pos.x - prevPos.x) * frac);
            
            if (!params.airResistance) {
                let theo = calculateTheoretical();
                state.t = theo.time;
                state.pos.x = theo.range;
                state.pos.y = 0;
                let finalV = Math.sqrt(Math.pow(params.u, 2) + 2*g*params.h);
                let finalVx = params.u * Math.cos(radians(params.theta));
                let finalVy = Math.sqrt(Math.pow(finalV, 2) - Math.pow(finalVx, 2));
                if(params.theta >= 0) finalVy = -finalVy; 
                state.history.push({
                    t: state.t, x: state.pos.x, y: 0,
                    vx: finalVx, vy: finalVy, v: finalV, ay: -g, ke: 0.5 * Math.pow(finalV, 2), pe: 0
                });
                showResults(theo.time, theo.height, theo.range, "theo");
            } else {
                state.t = impactT; state.pos.x = impactX; state.pos.y = 0;
                state.history.push({
                    t: impactT, x: impactX, y: 0,
                    vx: state.vel.x, vy: state.vel.y, v: state.vel.mag(),
                    ay: state.acc.y, ke: 0.5*Math.pow(state.vel.mag(), 2), pe: 0
                });
                showResults(impactT, state.maxHeightSim, impactX, "sim");
            }
            state.vel.set(0,0); 
            state.previousRunPath = state.history.map(h => createVector(h.x, h.y));
            updateRealtimeData();
            updateGraphs();
        }

        // --- DRAWING ---
        function toScreen(v) {
            return createVector(60 + v.x * PIXELS_PER_METER, height - GROUND_OFFSET - v.y * PIXELS_PER_METER);
        }

        function drawGrid() {
            noStroke(); fill(245); rect(0, height - GROUND_OFFSET, width, GROUND_OFFSET);
            stroke(200); strokeWeight(1); line(0, height - GROUND_OFFSET, width, height - GROUND_OFFSET);
            fill(150); noStroke(); textSize(10); textAlign(CENTER);
            
            // Dynamic Grid Step
            let step = 10;
            if (PIXELS_PER_METER < 2) step = 50;
            else if (PIXELS_PER_METER < 5) step = 20;
            else if (PIXELS_PER_METER > 15) step = 5;

            for (let x = 0; x < width/PIXELS_PER_METER; x += step) {
                let sx = 60 + x * PIXELS_PER_METER;
                text(x, sx, height - GROUND_OFFSET + 15);
                stroke(240); line(sx, 0, sx, height - GROUND_OFFSET);
            }
        }

        function drawPaths() {
            noFill(); strokeWeight(2); stroke(220); 
            for (let path of state.savedPaths) {
                beginShape();
                path.forEach(p => { let s = toScreen(p); vertex(s.x, s.y); });
                endShape();
            }
            if (state.history.length > 0) {
                stroke(100);
                beginShape();
                state.history.forEach(h => { let s = toScreen(createVector(h.x, h.y)); vertex(s.x, s.y); });
                endShape();
            }
        }

        function drawCannon() {
            let start = toScreen(createVector(0, params.h));
            push(); translate(start.x, start.y);
            stroke(100); strokeWeight(3); line(0, 0, 0, (height - GROUND_OFFSET) - start.y);
            rotate(radians(-params.theta)); noStroke(); fill(80); rect(0, -5, 30, 10);
            pop();
        }

        function drawBall() {
            let s = toScreen(state.pos);
            fill(50); noStroke(); circle(s.x, s.y, 14);
        }

        function drawVectors() {
            let s = toScreen(state.pos);
            if (state.vel.mag() < 0.1) return;
            let scale = 3.0;
            if (Math.abs(state.vel.x) > 0.1) drawArrow(s, createVector(state.vel.x, 0), '#ef4444', scale);
            if (Math.abs(state.vel.y) > 0.1) drawArrow(s, createVector(0, state.vel.y), '#9333ea', scale);
            drawArrow(s, state.vel, '#22c55e', scale);
        }

        function drawArrow(base, vec, colorHex, scale) {
            push(); stroke(colorHex); fill(colorHex); strokeWeight(2);
            translate(base.x, base.y);
            let vDraw = createVector(vec.x, -vec.y).mult(scale);
            line(0, 0, vDraw.x, vDraw.y);
            rotate(vDraw.heading());
            translate(vDraw.mag() - 5, 0);
            triangle(0, 3, 0, -3, 6, 0);
            pop();
        }

        function updateGraphs() {
            if (frameCount % 3 !== 0 && !state.finished) return; 
            let tArr = state.history.map(h => h.t);
            renderGraph('graph1', tArr, state.history, ui.graphs.sel1.value);
            renderGraph('graph2', tArr, state.history, ui.graphs.sel2.value);
        }

        function renderGraph(canvasId, tArr, history, key) {
            let cvs = document.getElementById(canvasId);
            let ctx = cvs.getContext('2d');
            if (cvs.width !== cvs.clientWidth) { cvs.width = cvs.clientWidth; cvs.height = cvs.clientHeight; }
            ctx.clearRect(0,0,cvs.width, cvs.height);
            if (history.length < 2) return;

            let yArr = history.map(h => h[key]);
            let color = "#666";
            if (key.includes('v')) color = (key === 'vx') ? '#ef4444' : (key === 'vy' ? '#9333ea' : '#22c55e');
            else if (key.includes('x')) color = '#ef4444';
            else if (key.includes('y') && key !== 'ay') color = '#9333ea';
            else if (key === 'ke') color = '#f59e0b'; else if (key === 'pe') color = '#3b82f6'; else if (key === 'ay') color = '#000000'; 

            let maxT = Math.max(...tArr) || 1;
            let maxY = Math.max(...yArr);
            let minY = Math.min(...yArr);
            
            if (Math.abs(maxY - minY) < 1e-5) {
                let center = maxY; maxY = center + 10; minY = center - 10;
            } else {
                let span = maxY - minY; maxY += span * 0.065; minY -= span * 0.065;
            }
            if (['v', 'vx', 'vy', 'ke', 'pe'].includes(key)) {
                 if(minY > 0) minY = 0; if(maxY < 0) maxY = 0;
            }
            
            let rangeY = maxY - minY;
            let padL = 15, padB = 15, padT = 10, padR = 15;
            let w = cvs.width - padL - padR;
            let h = cvs.height - padT - padB;

            ctx.beginPath(); ctx.strokeStyle = "#eee"; ctx.lineWidth = 1; ctx.rect(padL, padT, w, h); ctx.stroke();

            let xAxisY = (cvs.height - padB);
            if (minY <= 0 && maxY >= 0) xAxisY = (cvs.height - padB) - ((0 - minY)/rangeY) * h;
            ctx.beginPath(); ctx.strokeStyle = "#000"; ctx.lineWidth = 1.5;
            ctx.moveTo(padL, xAxisY); ctx.lineTo(cvs.width - 5, xAxisY);
            ctx.moveTo(padL, cvs.height - padB); ctx.lineTo(padL, 5);
            ctx.stroke();

            drawArrowHead(ctx, cvs.width - 5, xAxisY, 'right');
            drawArrowHead(ctx, padL, 5, 'up');

            ctx.beginPath(); ctx.strokeStyle = color; ctx.lineWidth = 2;
            let minPX = padL; let maxPX = cvs.width - padR; let minPY = padT; let maxPY = cvs.height - padB;

            for(let i=0; i<tArr.length; i++) {
                let px = padL + (tArr[i]/maxT) * w;
                let py = (cvs.height - padB) - ((yArr[i] - minY)/rangeY) * h;
                px = Math.max(minPX, Math.min(maxPX, px)); py = Math.max(minPY, Math.min(maxPY, py));
                if(i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
            }
            ctx.stroke();
        }

        function drawArrowHead(ctx, x, y, dir) {
            ctx.beginPath(); ctx.fillStyle = "#000";
            if (dir === 'right') { ctx.moveTo(x, y); ctx.lineTo(x - 6, y - 3); ctx.lineTo(x - 6, y + 3); } 
            else if (dir === 'up') { ctx.moveTo(x, y); ctx.lineTo(x - 3, y + 6); ctx.lineTo(x + 3, y + 6); }
            ctx.fill();
        }

        function calculateTheoretical() {
            let rad = radians(params.theta);
            let ux = params.u * Math.cos(rad);
            let uy = params.u * Math.sin(rad);
            let delta = Math.sqrt(uy*uy + 2*g*params.h);
            let t = (uy + delta) / g;
            let range = ux * t;
            let maxHeight = (params.theta < 0) ? params.h : params.h + (uy * uy) / (2 * g);
            return { time: t, range: range, height: maxHeight };
        }

        function updateRealtimeData() {
            ui.data.t.innerText = toSigFig(state.t) + " s";
            ui.data.v.innerText = toSigFig(state.vel.mag()) + " m/s";
            ui.data.x.innerText = toSigFig(state.pos.x) + " m";
            ui.data.y.innerText = toSigFig(state.pos.y) + " m";
            ui.data.vx.innerText = toSigFig(state.vel.x) + " m/s";
            ui.data.vy.innerText = toSigFig(state.vel.y) + " m/s";
        }

        function showResults(t, h, r, typeKey) {
            lastResultTypeKey = typeKey;
            document.getElementById('results-panel').classList.remove('hidden');
            document.getElementById('res-type').innerText = LANG[currentLang][typeKey];
            document.getElementById('res-time').innerText = toSigFig(t, 4) + " s";
            document.getElementById('res-height').innerText = toSigFig(h, 4) + " m";
            document.getElementById('res-range').innerText = toSigFig(r, 4) + " m";
        }
        
        function updateStatusDot() {
            if(state.paused) ui.statusDot.className = "w-2 h-2 rounded-full bg-yellow-500";
            else if(state.running) ui.statusDot.className = "w-2 h-2 rounded-full bg-green-500 animate-pulse";
            else ui.statusDot.className = "w-2 h-2 rounded-full bg-gray-400";
        }

        function resetSimulation(fullClear = false) {
            state.running = false; state.paused = false; state.finished = false;
            state.maxHeightSim = params.h; state.t = 0; state.history = []; 
            if (fullClear) {
                state.savedPaths = []; state.previousRunPath = null;
                document.getElementById('results-panel').classList.add('hidden');
                lastResultTypeKey = null;
            }
            let rad = radians(params.theta);
            state.pos.set(0, params.h);
            state.vel.set(params.u * Math.cos(rad), params.u * Math.sin(rad));
            state.acc.set(0, -g);
            updateRealtimeData();
            updatePauseBtnText();
            ['graph1', 'graph2'].forEach(id => {
                let c = document.getElementById(id); c.getContext('2d').clearRect(0,0,c.width, c.height);
            });
            document.getElementById('pause-overlay').classList.add('hidden');
        }

        function handleFire() {
            if (state.previousRunPath) {
                state.savedPaths.push(state.previousRunPath);
                state.previousRunPath = null;
            }
            resetSimulation(false);
            state.running = true;
        }

        function handlePause() {
            if (!state.running && !state.finished) return;
            state.paused = !state.paused;
            updatePauseBtnText();
        }

        function syncInput(p, isSlider) {
            let val = parseFloat(isSlider ? ui.sliders[p].value : ui.inputs[p].value);
            if (!isSlider) { 
                let min = parseFloat(ui.inputs[p].min); let max = parseFloat(ui.inputs[p].max);
                if(val < min) val = min; if(val > max) val = max; 
            }
            params[p] = val; ui.sliders[p].value = val; ui.inputs[p].value = val;
            resetSimulation(false);
        }
        ['u', 'theta', 'h'].forEach(k => {
            ui.sliders[k].addEventListener('input', () => syncInput(k, true));
            ui.inputs[k].addEventListener('change', () => syncInput(k, false));
        });

        ui.btns.fire.onclick = handleFire;
        ui.btns.pause.onclick = handlePause;
        ui.btns.clear.onclick = () => resetSimulation(true);
        ui.btns.air.onclick = () => {
            params.airResistance = !params.airResistance;
            updateAirBtnText();
            resetSimulation(false);
        };
        ui.timeScale.onchange = (e) => params.timeScale = parseFloat(e.target.value);
        ui.graphs.sel1.addEventListener('change', () => { if(state.finished || state.paused) updateGraphs(); });
        ui.graphs.sel2.addEventListener('change', () => { if(state.finished || state.paused) updateGraphs(); });

    </script>
</body>
</html>