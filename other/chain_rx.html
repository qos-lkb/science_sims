<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>核子連鎖反應模擬器 (邊界逃逸版)</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1a1a1a;
            color: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
        }
        h1 { margin-bottom: 5px; color: #4facfe; }
        p { margin-bottom: 15px; color: #aaa; font-size: 0.9em; }
        
        .container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        /* 畫布樣式：加上虛線邊框代表開放邊界 */
        canvas {
            background-color: #000;
            border: 2px dashed #666; 
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            cursor: crosshair;
            transition: background-color 0.5s ease;
        }

        .controls {
            background-color: #2d2d2d;
            padding: 20px;
            border-radius: 10px;
            width: 320px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        .control-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-weight: bold; }
        input[type="range"], select { width: 100%; padding: 5px; border-radius: 4px; border: none; }
        
        button {
            width: 100%;
            padding: 10px;
            background-image: linear-gradient(to right, #43e97b 0%, #38f9d7 100%);
            border: none;
            border-radius: 5px;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            font-size: 16px;
            margin-bottom: 10px;
        }
        button:hover { opacity: 0.9; }
        button.reset {
            background-image: linear-gradient(to right, #ff8177 0%, #ff867a 0%, #ff8c7f 21%, #f99185 52%, #cf556c 78%, #b12a5b 100%);
            color: white;
        }
        
        .legend { margin-top: 20px; font-size: 0.9em; background: #333; padding: 10px; border-radius: 5px; }
        .legend-item { display: flex; align-items: center; margin-bottom: 5px; }
        .dot { width: 12px; height: 12px; border-radius: 50%; margin-right: 10px; display: inline-block; border: 1px solid #fff; }
        
        #stats { font-family: monospace; color: #4facfe; margin-bottom: 10px; min-height: 45px; line-height: 1.4; }
    </style>
</head>
<body>

    <h1>核子連鎖反應模擬器 (教學版)</h1>
    <p>注意：中子若移動到邊界外將會逃逸消失 (模擬中子洩漏)</p>

    <div class="container">
        <canvas id="simCanvas" width="600" height="500"></canvas>

        <div class="controls">
            <div class="control-group">
                <label for="fuelDensity">燃料密度 (U-235 數量)</label>
                <input type="range" id="fuelDensity" min="20" max="250" value="80">
                <small>數量: <span id="fuelVal">80</span></small>
            </div>

            <div class="control-group">
                <label style="background: #444; padding: 10px; border-radius: 5px; cursor: pointer;">
                    <input type="checkbox" id="moderatorToggle"> 
                    啟用減速劑 (水)
                    <br><small style="font-weight:normal; color:#ddd;">(背景變藍，中子減速)</small>
                </label>
            </div>
            
            <div class="control-group">
                <label for="neutronOutput">每次裂變釋放中子數</label>
                <select id="neutronOutput">
                    <option value="1">1 粒 (不易維持)</option>
                    <option value="2" selected>2 粒 (標準)</option>
                    <option value="3">3 粒 (劇烈)</option>
                </select>
            </div>

            <div class="control-group">
                <label for="controlRods">控制棒插入深度</label>
                <input type="range" id="controlRods" min="0" max="100" value="0">
            </div>

            <div id="stats">
                狀態: 準備就緒<br>
                活性中子: 0
            </div>

            <button onclick="fireNeutron()">發射中子</button>
            <button class="reset" onclick="init()">重置 / 重新生成燃料</button>

            <div class="legend">
                <div class="legend-item"><span class="dot" style="background:lime;"></span> 鈾-235 原子核</div>
                <div class="legend-item"><span class="dot" style="background:red;"></span> 熱中子 (慢/有效)</div>
                <div class="legend-item"><span class="dot" style="background:white;"></span> 快中子 (快/穿透)</div>
                <div class="legend-item"><span class="dot" style="background:grey;"></span> 控制棒 (吸收)</div>
            </div>
        </div>
    </div>

<script>
    const canvas = document.getElementById('simCanvas');
    const ctx = canvas.getContext('2d');
    
    // 變數
    let atoms = [];
    let neutrons = [];
    let particles = [];
    let fissionCount = 0;
    
    // 參數設定
    const ATOM_RADIUS = 9;
    const NEUTRON_RADIUS = 4;
    const FAST_SPEED = 7;     // 快中子速度
    const THERMAL_SPEED = 2;  // 熱中子速度

    // UI 綁定
    const fuelSlider = document.getElementById('fuelDensity');
    const fuelValDisplay = document.getElementById('fuelVal');
    const modCheckbox = document.getElementById('moderatorToggle');
    const neutronSelect = document.getElementById('neutronOutput');
    const rodSlider = document.getElementById('controlRods');
    const statsDiv = document.getElementById('stats');

    class Atom {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.active = true;
        }
        draw() {
            if (!this.active) return;
            ctx.beginPath();
            ctx.arc(this.x, this.y, ATOM_RADIUS, 0, Math.PI * 2);
            ctx.fillStyle = '#32CD32'; // 鮮豔綠色
            ctx.fill();
            ctx.strokeStyle = '#006400';
            ctx.stroke();
            
            ctx.fillStyle = 'black';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('U', this.x, this.y);
        }
    }

    class Neutron {
        constructor(x, y, vx, vy, isThermal = false) {
            this.x = x;
            this.y = y;
            this.vx = vx;
            this.vy = vy;
            this.isThermal = isThermal;
            // 移除了壽命限制，現在靠飛出邊界來結束
        }

        update() {
            // --- 速度與減速機制 ---
            if (modCheckbox.checked) {
                // 有減速劑：中子會受到阻力減速
                if (!this.isThermal) {
                    this.vx *= 0.96; 
                    this.vy *= 0.96;
                    
                    const speed = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
                    if (speed <= THERMAL_SPEED) {
                        this.isThermal = true; // 變成熱中子
                    }
                } else {
                    // 已經是熱中子，維持恆定慢速
                    const speed = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
                    if (speed < THERMAL_SPEED - 0.5) {
                        this.vx *= 1.05; this.vy *= 1.05;
                    }
                }
            } else {
                // 無減速劑：中子保持高速，且永遠是快中子
                this.isThermal = false;
                const speed = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
                if (speed < FAST_SPEED) {
                    this.vx *= 1.1; this.vy *= 1.1; 
                }
            }

            this.x += this.vx;
            this.y += this.vy;

            // --- 邊界逃逸機制 (修正重點) ---
            // 如果中子超出畫布範圍，直接返回 false (代表需要被移除)
            if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
                return false; 
            }

            // --- 控制棒碰撞 (吸收) ---
            const rodHeight = (rodSlider.value / 100) * canvas.height;
            const rodsX = [canvas.width * 0.25, canvas.width * 0.5, canvas.width * 0.75];
            for (let rx of rodsX) {
                // 控制棒寬度 20px
                if (this.x > rx - 10 && this.x < rx + 10 && this.y < rodHeight) {
                    return false; // 被控制棒吸收，消失
                }
            }
            
            return true; // 還活著
        }

        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, NEUTRON_RADIUS, 0, Math.PI * 2);
            
            if (this.isThermal) {
                ctx.fillStyle = '#FF0000'; // 熱中子：紅色
            } else {
                // 快中子：根據背景調整顏色
                ctx.fillStyle = modCheckbox.checked ? '#444' : '#FFF';
            }
            ctx.fill();
            ctx.strokeStyle = this.isThermal ? '#FFF' : '#000'; 
            ctx.lineWidth = 1;
            ctx.stroke();
        }
    }

    class Particle {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 4 + 1;
            this.vx = Math.cos(angle) * speed;
            this.vy = Math.sin(angle) * speed;
            this.life = 30;
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.life--;
            return this.life > 0;
        }
        draw() {
            ctx.globalAlpha = this.life / 30;
            ctx.fillStyle = 'orange';
            ctx.beginPath();
            ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1.0;
        }
    }

    function init() {
        atoms = [];
        neutrons = [];
        particles = [];
        fissionCount = 0;
        
        const count = parseInt(fuelSlider.value);
        fuelValDisplay.innerText = count;

        // 隨機放置原子核
        for (let i = 0; i < count; i++) {
            const x = Math.random() * (canvas.width - 40) + 20;
            const y = Math.random() * (canvas.height - 40) + 20;
            atoms.push(new Atom(x, y));
        }
        
        drawFrame();
        statsDiv.innerHTML = "狀態: 等待中子觸發";
    }

    function fireNeutron() {
        // 從左側隨機高度發射
        const y = Math.random() * (canvas.height - 100) + 50;
        // 初始射入一定是快中子
        neutrons.push(new Neutron(0, y, FAST_SPEED, (Math.random() - 0.5) * 2));
    }

    function checkCollisions() {
        for (let n = neutrons.length - 1; n >= 0; n--) {
            let neutron = neutrons[n];
            let hit = false;

            // 物理規則：快中子直接穿透 (模擬截面過小)
            if (!neutron.isThermal) {
                continue; 
            }

            for (let i = atoms.length - 1; i >= 0; i--) {
                let atom = atoms[i];
                if (!atom.active) continue;

                const dx = atom.x - neutron.x;
                const dy = atom.y - neutron.y;
                const distSq = dx*dx + dy*dy;

                // 只有熱中子(紅) 撞擊 原子(綠) 才有效
                if (distSq < (ATOM_RADIUS + NEUTRON_RADIUS) ** 2) {
                    
                    atom.active = false; // 原子裂變消失
                    hit = true;
                    fissionCount++;

                    // 爆炸特效
                    for(let p=0; p<6; p++) particles.push(new Particle(atom.x, atom.y));

                    // 根據使用者選擇釋放新中子 (1, 2, or 3)
                    const releaseCount = parseInt(neutronSelect.value);

                    for (let k = 0; k < releaseCount; k++) {
                        const angle = Math.random() * Math.PI * 2;
                        // 新生的中子一定是 "快中子"
                        neutrons.push(new Neutron(
                            atom.x, 
                            atom.y, 
                            Math.cos(angle) * FAST_SPEED, 
                            Math.sin(angle) * FAST_SPEED, 
                            false 
                        ));
                    }
                    break; // 一個中子只能撞一個原子
                }
            }
            if (hit) {
                neutrons.splice(n, 1); // 撞擊後舊中子消失
            }
        }
    }

    function drawFrame() {
        // 背景色切換
        if (modCheckbox.checked) {
            ctx.fillStyle = '#b3e5fc'; // 淺藍 (有水/減速劑)
        } else {
            ctx.fillStyle = '#000000'; // 黑 (無減速劑)
        }
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // 畫控制棒 (灰色長條)
        const rodH = (rodSlider.value / 100) * canvas.height;
        ctx.fillStyle = '#666'; 
        const rodsX = [canvas.width * 0.25, canvas.width * 0.5, canvas.width * 0.75];
        for(let rx of rodsX) {
            ctx.fillRect(rx - 10, 0, 20, rodH);
            ctx.strokeStyle = '#333';
            ctx.strokeRect(rx - 10, 0, 20, rodH);
        }

        atoms.forEach(a => a.draw());
        neutrons.forEach(n => n.draw());
        particles.forEach(p => p.draw());

        // 更新數據
        if (neutrons.length > 0) {
            statsDiv.innerHTML = `狀態: 反應中<br>活性中子: ${neutrons.length} | 累積裂變: ${fissionCount}`;
        } else if (fissionCount > 0 && neutrons.length === 0) {
            statsDiv.innerHTML = `狀態: 反應結束 (中子耗盡或逃逸)<br>總裂變次數: ${fissionCount}`;
        }
    }

    function animate() {
        // 更新位置 / 移除逃逸中子
        for (let i = neutrons.length - 1; i >= 0; i--) {
            if (!neutrons[i].update()) {
                neutrons.splice(i, 1);
            }
        }
        for (let i = particles.length - 1; i >= 0; i--) {
            if (!particles[i].update()) {
                particles.splice(i, 1);
            }
        }
        
        checkCollisions();
        drawFrame();
        requestAnimationFrame(animate);
    }

    // 事件
    fuelSlider.addEventListener('input', init);
    window.onload = function() {
        init();
        animate();
    };

</script>
</body>
</html>