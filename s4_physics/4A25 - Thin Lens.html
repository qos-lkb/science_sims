<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lens Imaging Simulation Lab</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: #f0f4f8;
        }
        canvas {
            background-color: #ffffff;
            background-image: 
                linear-gradient(#e5e7eb 1px, transparent 1px),
                linear-gradient(90deg, #e5e7eb 1px, transparent 1px);
            background-size: 20px 20px;
            border: 1px solid #cbd5e1;
            cursor: crosshair;
        }
        .slider-thumb::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
        }
        .panel {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
    </style>
</head>
<body class="h-screen flex flex-col text-slate-800">

    <!-- Header -->
    <header class="bg-slate-800 text-white p-4 shadow-md flex justify-between items-center shrink-0">
        <div class="flex items-center gap-3">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 text-blue-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
            </svg>
            <h1 class="text-xl font-bold tracking-wide">Physics Lab: Lens Optics</h1>
        </div>
        <div class="text-sm text-slate-300 hidden md:block">
            Interactive Ray Optics Simulation
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-1 flex flex-col md:flex-row overflow-hidden">
        
        <!-- Sidebar Controls -->
        <aside class="w-full md:w-80 bg-white border-r border-slate-200 p-6 flex flex-col gap-6 overflow-y-auto shrink-0 z-10">
            
            <!-- Lens Type Selector -->
            <div class="bg-slate-50 p-4 rounded-lg border border-slate-200">
                <label class="block text-sm font-semibold text-slate-600 mb-3">Select Lens Type</label>
                <div class="flex gap-2">
                    <button id="btnConvex" class="flex-1 py-2 px-3 rounded transition-colors bg-blue-600 text-white shadow-sm font-medium text-sm">
                        Convex
                    </button>
                    <button id="btnConcave" class="flex-1 py-2 px-3 rounded transition-colors bg-white text-slate-600 border border-slate-300 hover:bg-slate-50 font-medium text-sm">
                        Concave
                    </button>
                </div>
            </div>

            <!-- Parameters -->
            <div class="space-y-6">
                <div>
                    <div class="flex justify-between mb-1">
                        <label class="text-sm font-medium text-slate-700">Focal Length (f)</label>
                        <span id="valF" class="text-sm font-bold text-blue-600">100 mm</span>
                    </div>
                    <input type="range" id="rangeF" min="50" max="200" value="100" class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer slider-thumb">
                </div>

                <div>
                    <div class="flex justify-between mb-1">
                        <label class="text-sm font-medium text-slate-700">Object Distance (u)</label>
                        <span id="valU" class="text-sm font-bold text-blue-600">250 mm</span>
                    </div>
                    <input type="range" id="rangeU" min="0" max="500" value="250" class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer slider-thumb">
                </div>

                <div>
                    <div class="flex justify-between mb-1">
                        <label class="text-sm font-medium text-slate-700">Object Height (h)</label>
                        <span id="valH" class="text-sm font-bold text-blue-600">80 mm</span>
                    </div>
                    <input type="range" id="rangeH" min="10" max="150" value="80" class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer slider-thumb">
                </div>
            </div>

            <!-- Results Panel -->
            <div class="mt-auto pt-4 border-t border-slate-200">
                <h3 class="text-sm font-semibold text-slate-800 mb-3">Analysis</h3>
                
                <!-- Position Descriptions -->
                <div class="mb-4 p-3 bg-slate-50 rounded border border-slate-100 text-xs space-y-2">
                    <div>
                        <span class="font-semibold text-slate-600 block">Object Position:</span>
                        <span id="posObj" class="text-blue-700 font-medium">--</span>
                    </div>
                    <div>
                        <span class="font-semibold text-slate-600 block">Image Position:</span>
                        <span id="posImg" class="text-red-700 font-medium">--</span>
                    </div>
                </div>

                <div class="space-y-2 text-sm">
                    <div class="flex justify-between">
                        <span class="text-slate-500">Image Dist. (v):</span>
                        <span id="resV" class="font-mono font-bold text-slate-800">--</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-slate-500">Magnification (m):</span>
                        <span id="resM" class="font-mono font-bold text-slate-800">--</span>
                    </div>
                    <div class="flex justify-between items-center">
                        <span class="text-slate-500">Nature:</span>
                        <span id="resType" class="font-bold px-2 py-0.5 rounded bg-slate-100 text-slate-800 text-xs">--</span>
                    </div>
                </div>
            </div>
        </aside>

        <!-- Canvas Area -->
        <div class="flex-1 relative bg-slate-50 p-2 md:p-4 flex flex-col min-h-[400px]">
            <canvas id="opticsCanvas" class="w-full h-full rounded shadow-inner bg-white block"></canvas>
            
            <!-- Legend -->
            <div class="absolute bottom-6 right-6 bg-white/90 backdrop-blur p-3 rounded border border-slate-200 text-xs shadow-sm hidden md:block pointer-events-none">
                <div class="flex items-center gap-2 mb-1"><div class="w-3 h-3 bg-blue-500 rounded-sm"></div> Object</div>
                <div class="flex items-center gap-2 mb-1"><div class="w-3 h-3 bg-red-500 rounded-sm"></div> Image</div>
                <div class="flex items-center gap-2 mb-1"><div class="w-8 h-0.5 bg-orange-400"></div> Real Ray</div>
                <div class="flex items-center gap-2"><div class="w-8 h-0.5 border-t-2 border-dashed border-orange-400"></div> Virtual Ext.</div>
            </div>
        </div>

    </main>

    <script>
        // State
        const state = {
            lensType: 'convex', // 'convex' or 'concave'
            f: 100,  // focal length (magnitude)
            u: 200,  // object distance (always positive in UI logic)
            h: 80    // object height
        };

        // DOM Elements
        const canvas = document.getElementById('opticsCanvas');
        const ctx = canvas.getContext('2d');
        
        // Inputs
        const btnConvex = document.getElementById('btnConvex');
        const btnConcave = document.getElementById('btnConcave');
        const rangeF = document.getElementById('rangeF');
        const rangeU = document.getElementById('rangeU');
        const rangeH = document.getElementById('rangeH');
        
        // Displays
        const valF = document.getElementById('valF');
        const valU = document.getElementById('valU');
        const valH = document.getElementById('valH');
        const resV = document.getElementById('resV');
        const resM = document.getElementById('resM');
        const resType = document.getElementById('resType');
        const posObj = document.getElementById('posObj');
        const posImg = document.getElementById('posImg');

        // Initialize
        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Event Listeners
            btnConvex.addEventListener('click', () => setLensType('convex'));
            btnConcave.addEventListener('click', () => setLensType('concave'));
            
            rangeF.addEventListener('input', (e) => {
                state.f = parseInt(e.target.value);
                valF.innerText = state.f + ' mm';
                update();
            });
            
            rangeU.addEventListener('input', (e) => {
                state.u = parseInt(e.target.value);
                valU.innerText = state.u + ' mm';
                update();
            });

            rangeH.addEventListener('input', (e) => {
                state.h = parseInt(e.target.value);
                valH.innerText = state.h + ' mm';
                update();
            });

            // Initial render
            update();
        }

        function resizeCanvas() {
            const parent = canvas.parentElement;
            canvas.width = parent.clientWidth;
            canvas.height = parent.clientHeight;
            update();
        }

        function setLensType(type) {
            state.lensType = type;
            if (type === 'convex') {
                btnConvex.classList.add('bg-blue-600', 'text-white', 'shadow-sm');
                btnConvex.classList.remove('bg-white', 'text-slate-600', 'border', 'border-slate-300');
                
                btnConcave.classList.remove('bg-blue-600', 'text-white', 'shadow-sm');
                btnConcave.classList.add('bg-white', 'text-slate-600', 'border', 'border-slate-300');
            } else {
                btnConcave.classList.add('bg-blue-600', 'text-white', 'shadow-sm');
                btnConcave.classList.remove('bg-white', 'text-slate-600', 'border', 'border-slate-300');
                
                btnConvex.classList.remove('bg-blue-600', 'text-white', 'shadow-sm');
                btnConvex.classList.add('bg-white', 'text-slate-600', 'border', 'border-slate-300');
            }
            update();
        }

        // Main Update Loop
        function update() {
            let f_calc = state.lensType === 'convex' ? state.f : -state.f;
            let u_coord = -state.u; 
            
            let v_coord;
            if (Math.abs(u_coord + f_calc) < 0.1) {
                v_coord = Infinity; 
            } else {
                v_coord = 1 / ((1/f_calc) + (1/u_coord));
            }

            let magnification = v_coord / u_coord;
            let h_image = state.h * magnification;

            updateResultsPanel(v_coord, magnification, h_image);
            drawScene(f_calc, u_coord, v_coord, state.h, h_image);
        }

        function getPositionDescription(dist, f) {
            // dist is absolute distance
            // f is absolute focal length
            if (Math.abs(dist - f) < 1) return "At F'"; // Object side
            if (Math.abs(dist - 2*f) < 1) return "At 2F'"; // Object side
            if (dist === Infinity) return "At Infinity";
            
            if (dist < f) return "Between Lens and F'";
            if (dist > f && dist < 2*f) return "Between F' and 2F'";
            if (dist > 2*f) return "Beyond 2F'";
            return "";
        }

        function updateResultsPanel(v, m, h_img) {
            const absF = state.f;
            const absU = state.u;
            const absV = Math.abs(v);

            // 1. Object Position Description
            posObj.innerText = getPositionDescription(absU, absF);

            // 2. Image Position Description
            if (v === Infinity || absV > 10000) {
                posImg.innerText = "At Infinity";
                resV.innerText = "∞";
                resM.innerText = "∞";
                resType.innerText = "No Image";
                resType.className = "font-bold px-2 py-0.5 rounded bg-gray-200 text-gray-600 text-xs";
                return;
            } else {
                // For image, we should also clarify side
                // V > 0 means right side (Real image usually), V < 0 means left side (Virtual)
                let side = v > 0 ? " (Opposite Side)" : " (Same Side)";
                
                // Describe location relative to F/2F
                let loc = "";
                if (Math.abs(absV - absF) < 1) loc = "At F";
                else if (Math.abs(absV - 2*absF) < 1) loc = "At 2F";
                else if (absV < absF) loc = "Between Lens and F";
                else if (absV > absF && absV < 2*absF) loc = "Between F and 2F";
                else if (absV > 2*absF) loc = "Beyond 2F";
                
                posImg.innerText = loc + side;
            }

            resV.innerText = Math.abs(v).toFixed(1) + " mm";
            resM.innerText = Math.abs(m).toFixed(2) + "x";

            let typeText = "";
            let typeClass = "";

            if (v > 0) {
                typeText += "Real";
                typeClass = "bg-green-100 text-green-700";
            } else {
                typeText += "Virtual";
                typeClass = "bg-purple-100 text-purple-700";
            }

            typeText += " · ";

            // Change "Upright" to "Erect"
            if (m > 0) typeText += "Erect";
            else typeText += "Inverted";
            
            typeText += " · ";

            if (Math.abs(m) > 1.01) typeText += "Magnified";
            else if (Math.abs(m) < 0.99) typeText += "Diminished";
            else typeText += "Same Size";

            resType.innerText = typeText;
            resType.className = "font-bold px-2 py-0.5 rounded text-xs " + typeClass;
        }

        function drawScene(f, u, v, ho, hi) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            
            let maxDist = Math.max(state.u * 1.2, Math.abs(f) * 2.2);
            if (Math.abs(v) !== Infinity && Math.abs(v) < 5000) {
                maxDist = Math.max(maxDist, Math.abs(v) * 1.2);
            }
            
            // Clamping zoom
            if (maxDist < 300) maxDist = 300;
            if (maxDist > 2000) maxDist = 2000; 

            const scale = (canvas.width / 2 - 40) / maxDist; 

            const toCanvasX = (x) => cx + x * scale;
            const toCanvasY = (y) => cy - y * scale; 

            // 1. Draw Optical Axis
            ctx.beginPath();
            ctx.moveTo(0, cy);
            ctx.lineTo(canvas.width, cy);
            ctx.strokeStyle = "#94a3b8";
            ctx.lineWidth = 1;
            ctx.stroke();

            // 2. Draw Focal Points (SWAPPED LABELS)
            // Right Side (+f) -> F, 2F
            drawPoint(toCanvasX(f), cy, "F", "#ef4444");
            drawPoint(toCanvasX(2*f), cy, "2F", "#94a3b8");
            
            // Left Side (-f) -> F', 2F'
            drawPoint(toCanvasX(-f), cy, "F'", "#ef4444");
            drawPoint(toCanvasX(-2*f), cy, "2F'", "#94a3b8");

            // 3. Draw Lens
            drawLens(cx, cy, state.lensType);

            // 4. Draw Object
            const objX = toCanvasX(u);
            const objYHead = toCanvasY(ho);
            drawArrow(objX, cy, objX, objYHead, "#3b82f6", "Object");

            // 5. Draw Image
            let imgX, imgYHead;
            if (v !== Infinity) {
                imgX = toCanvasX(v);
                imgYHead = toCanvasY(hi);
                const isVirtual = v < 0; 
                drawArrow(imgX, cy, imgX, imgYHead, "#ef4444", "Image", isVirtual);
            }

            // 6. Draw Rays
            if (Math.abs(state.u) > 1) { 
                drawRayTracingInfinite(u, ho, v, hi, f, toCanvasX, toCanvasY, cx, cy);
            }
        }

        // New helper for infinite lines
        // Draws a line through (x1,y1) and (x2,y2).
        // 'forward' = true: draws in direction x1 -> x2 to edge
        // 'forward' = false: draws in direction x2 -> x1 to edge (backward)
        // 'style': dashed or solid
        function drawLineExtended(x1, y1, x2, y2, style, direction = 'both') {
            ctx.beginPath();
            if (style === 'dashed') ctx.setLineDash([5, 5]);
            else ctx.setLineDash([]);

            // Handle vertical lines if ever needed, though not in paraxial optics
            if (x2 === x1) return;

            const slope = (y2 - y1) / (x2 - x1);
            
            let startX, startY, endX, endY;

            // Calculate Y at canvas boundaries
            const yAt0 = y1 + slope * (0 - x1);
            const yAtW = y1 + slope * (canvas.width - x1);

            if (direction === 'right') {
                // From x1 to Right Edge
                ctx.moveTo(x1, y1);
                ctx.lineTo(canvas.width, yAtW);
            } else if (direction === 'left') {
                // From x1 to Left Edge
                ctx.moveTo(x1, y1);
                ctx.lineTo(0, yAt0);
            } else if (direction === 'both') {
                ctx.moveTo(0, yAt0);
                ctx.lineTo(canvas.width, yAtW);
            }
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function drawRayTracingInfinite(u, ho, v, hi, f, toX, toY, cx, cy) {
            ctx.lineWidth = 2;
            const objTopX = toX(u);
            const objTopY = toY(ho);
            const fx_right = toX(f);  // F (Right)
            const fx_left = toX(-f);   // F' (Left) (Careful: toX(-f) where f is positive mag)

            // Note: In our state, f is magnitude. 
            // If Convex: f_calc is +f.
            // If Concave: f_calc is -f.
            // But visually F is Right, F' is Left.
            
            // --- RAY 1: Parallel -> Focus ---
            
            // 1.1 Incident (Object to Lens)
            ctx.strokeStyle = "#f59e0b"; // Orange
            ctx.beginPath();
            ctx.moveTo(objTopX, objTopY);
            ctx.lineTo(cx, objTopY);
            ctx.stroke();
            drawArrowHead(objTopX, objTopY, cx, objTopY, "#f59e0b");

            // 1.2 Refracted (Lens outward)
            if (state.lensType === 'convex') {
                // Passes through F (Right side)
                // Solid line to the right
                drawLineExtended(cx, objTopY, fx_right, cy, 'solid', 'right');
                
                // Virtual extension (backwards) to the left
                ctx.strokeStyle = "#fcd34d"; // Light Orange
                drawLineExtended(cx, objTopY, fx_right, cy, 'dashed', 'left');
            } else {
                // Concave: Diverges as if from F' (Left side)
                // Solid line to right, aligned with F' (Left)
                
                // Solid part: From Lens to Right
                ctx.strokeStyle = "#f59e0b";
                ctx.beginPath();
                ctx.setLineDash([]);
                
                const slope = (objTopY - cy) / (cx - fx_left); 
                const yAtW = objTopY + slope * (canvas.width - cx);
                
                ctx.moveTo(cx, objTopY); 
                ctx.lineTo(canvas.width, yAtW);
                ctx.stroke();

                // Virtual part: From Lens to Left (infinite)
                ctx.strokeStyle = "#fcd34d";
                drawLineExtended(cx, objTopY, fx_left, cy, 'dashed', 'left');
            }

            // --- RAY 2: Through Optical Center ---
            
            ctx.strokeStyle = "#10b981"; // Green
            
            // Solid from object to right infinity
            ctx.beginPath();
            ctx.setLineDash([]);
            const slope2 = (cy - objTopY) / (cx - objTopX);
            const yAtW2 = cy + slope2 * (canvas.width - cx);
            ctx.moveTo(objTopX, objTopY);
            ctx.lineTo(canvas.width, yAtW2);
            ctx.stroke();
            drawArrowHead(objTopX, objTopY, cx, cy, "#10b981");

            // Virtual Extension to the Left (Infinity)
            ctx.strokeStyle = "#6ee7b7";
            drawLineExtended(objTopX, objTopY, cx, cy, 'dashed', 'left');


            // --- RAY 3: Through Focus -> Parallel ---
            
            ctx.strokeStyle = "#8b5cf6"; // Purple
            
            if (state.lensType === 'convex') {
                // Incident: Passes through F' (Left) to hit lens
                // We draw from Object to Lens.
                
                // Calculate where it hits the lens plane
                const slope3 = (cy - objTopY) / (fx_left - objTopX);
                const lensHitY = cy + slope3 * (cx - fx_left);

                if (Math.abs(lensHitY - cy) < canvas.height * 2) {
                    // Draw Incident
                    ctx.beginPath();
                    ctx.setLineDash([]);
                    ctx.moveTo(objTopX, objTopY);
                    ctx.lineTo(cx, lensHitY);
                    ctx.stroke();
                    drawArrowHead(objTopX, objTopY, fx_left, cy, "#8b5cf6");

                    // Refracted: Parallel to axis (Horizontal)
                    // Solid to right
                    ctx.beginPath();
                    ctx.moveTo(cx, lensHitY);
                    ctx.lineTo(canvas.width, lensHitY);
                    ctx.stroke();

                    // Virtual Extension: Parallel to axis (Horizontal) to left
                    ctx.strokeStyle = "#ddd6fe";
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(cx, lensHitY);
                    ctx.lineTo(0, lensHitY);
                    ctx.stroke();
                }
            } else {
                // Concave: Aimed at F (Right) -> Parallel
                
                const slope3 = (cy - objTopY) / (fx_right - objTopX);
                const lensHitY = cy + slope3 * (cx - fx_right);

                // Incident: Object to Lens (aiming at F right)
                ctx.beginPath();
                ctx.setLineDash([]);
                ctx.moveTo(objTopX, objTopY);
                ctx.lineTo(cx, lensHitY);
                ctx.stroke();
                drawArrowHead(objTopX, objTopY, cx, lensHitY, "#8b5cf6");
                
                // Virtual Extension of Incident Ray (aiming at F right)
                // User wants infinite virtual lines?
                // The virtual line shows where the ray WAS heading.
                // So dashed line from lens to F (right)
                ctx.strokeStyle = "#ddd6fe";
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(cx, lensHitY);
                ctx.lineTo(fx_right, cy);
                ctx.stroke();


                // Refracted: Parallel to axis
                ctx.strokeStyle = "#8b5cf6";
                ctx.setLineDash([]);
                ctx.beginPath();
                ctx.moveTo(cx, lensHitY);
                ctx.lineTo(canvas.width, lensHitY);
                ctx.stroke();

                // Virtual Extension of Refracted Ray (Parallel back to left)
                ctx.strokeStyle = "#ddd6fe";
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(cx, lensHitY);
                ctx.lineTo(0, lensHitY);
                ctx.stroke();
            }
            ctx.setLineDash([]);
        }

        function drawPoint(x, y, label, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "#475569";
            ctx.font = "12px sans-serif";
            ctx.fillText(label, x - 5, y + 15);
        }

        function drawLens(cx, cy, type) {
            ctx.strokeStyle = "#1e293b";
            ctx.lineWidth = 2;
            ctx.fillStyle = "rgba(219, 234, 254, 0.3)";
            
            const h = 150; 
            const w = 20;  

            ctx.beginPath();
            if (type === 'convex') {
                ctx.moveTo(cx, cy - h);
                ctx.quadraticCurveTo(cx + w, cy, cx, cy + h);
                ctx.quadraticCurveTo(cx - w, cy, cx, cy - h);
            } else {
                ctx.moveTo(cx - w, cy - h);
                ctx.quadraticCurveTo(cx, cy, cx - w, cy + h);
                ctx.lineTo(cx + w, cy + h);
                ctx.quadraticCurveTo(cx, cy, cx + w, cy - h);
                ctx.lineTo(cx - w, cy - h);
            }
            ctx.fill();
            ctx.stroke();
            
            ctx.beginPath();
            ctx.strokeStyle = "#cbd5e1";
            ctx.setLineDash([4, 4]);
            ctx.moveTo(cx, cy - h - 20);
            ctx.lineTo(cx, cy + h + 20);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function drawArrow(fromX, fromY, toX, toY, color, label, isDashed = false) {
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = 3;
            
            if (isDashed) ctx.setLineDash([6, 4]);
            
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.stroke();
            ctx.setLineDash([]);

            const headLen = 10;
            const angle = Math.atan2(toY - fromY, toX - fromX);
            ctx.beginPath();
            ctx.moveTo(toX, toY);
            ctx.lineTo(toX - headLen * Math.cos(angle - Math.PI / 6), toY - headLen * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(toX - headLen * Math.cos(angle + Math.PI / 6), toY - headLen * Math.sin(angle + Math.PI / 6));
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = color;
            ctx.font = "bold 14px sans-serif";
            ctx.fillText(label, toX - 10, toY - 15);
        }

        function drawArrowHead(x1, y1, x2, y2, color) {
            const midX = (x1 + x2) / 2;
            const midY = (y1 + y2) / 2;
            const angle = Math.atan2(y2 - y1, x2 - x1);
            const headLen = 8;
            
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(midX, midY);
            ctx.lineTo(midX - headLen * Math.cos(angle - Math.PI / 6), midY - headLen * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(midX - headLen * Math.cos(angle + Math.PI / 6), midY - headLen * Math.sin(angle + Math.PI / 6));
            ctx.fill();
        }

        init();

    </script>
</body>
</html>
