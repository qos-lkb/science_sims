<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>楊氏雙縫實驗虛擬模型</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 自定義滑桿樣式 */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            margin-top: -8px;
            box-shadow: 0 0 5px rgba(255,255,255,0.5);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #4B5563;
            border-radius: 2px;
        }
        .canvas-container {
            position: relative;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5), 0 2px 4px -1px rgba(0, 0, 0, 0.3);
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 font-sans min-h-screen flex flex-col">

    <!-- 標題區 -->
    <header class="p-6 border-b border-gray-700 bg-gray-800 shadow-lg">
        <div class="max-w-7xl mx-auto flex flex-col md:flex-row justify-between items-center">
            <div>
                <h1 class="text-3xl font-bold tracking-wider text-blue-400">楊氏雙縫實驗 <span class="text-sm text-gray-400 font-normal">Young's Double Slit Experiment</span></h1>
                <p class="text-gray-400 text-sm mt-1">虛擬物理實驗室</p>
            </div>
            <div class="mt-4 md:mt-0 bg-gray-900 p-3 rounded border border-gray-700">
                <span class="text-gray-400 text-sm">公式: </span>
                <span class="font-mono text-yellow-400 text-lg ml-2">Δy = λD / a</span>
            </div>
        </div>
    </header>

    <!-- 主要內容區 -->
    <main class="flex-grow p-4 md:p-8 max-w-7xl mx-auto w-full grid grid-cols-1 lg:grid-cols-3 gap-8">

        <!-- 左側：控制面板 (修改：h-fit -> h-full 以確保高度對齊) -->
        <section class="bg-gray-800 rounded-xl p-6 shadow-xl border border-gray-700 h-full flex flex-col">
            <h2 class="text-xl font-semibold mb-6 border-b border-gray-600 pb-2 flex items-center">
                <svg class="w-6 h-6 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4"></path></svg>
                參數設定
            </h2>

            <!-- 波長控制 -->
            <div class="mb-8 group">
                <label class="block text-sm font-medium mb-2 text-gray-300">光波波長 (λ)</label>
                <div class="flex justify-between items-center mb-1">
                    <span class="text-xs text-gray-500">400 nm</span>
                    <span id="val-lambda" class="font-mono text-xl font-bold" style="color: #fff;">532 nm</span>
                    <span class="text-xs text-gray-500">700 nm</span>
                </div>
                <input type="range" id="input-lambda" min="400" max="700" step="1" value="532" class="w-full">
                <div class="h-2 w-full mt-2 rounded-full" style="background: linear-gradient(to right, #5900ff, #0000ff, #00ffff, #00ff00, #ffff00, #ff7f00, #ff0000);"></div>
            </div>

            <!-- 雙縫間距控制 -->
            <div class="mb-8">
                <label class="block text-sm font-medium mb-2 text-gray-300">雙縫間距 (a)</label>
                <div class="flex justify-between items-center mb-1">
                    <span class="text-xs text-gray-500">0.1 mm</span>
                    <span id="val-a" class="font-mono text-xl text-blue-300 font-bold">0.20 mm</span>
                    <span class="text-xs text-gray-500">2.0 mm</span>
                </div>
                <input type="range" id="input-a" min="0.1" max="2.0" step="0.05" value="0.2">
            </div>

            <!-- 屏幕距離控制 -->
            <div class="mb-8">
                <label class="block text-sm font-medium mb-2 text-gray-300">屏幕距離 (D)</label>
                <div class="flex justify-between items-center mb-1">
                    <span class="text-xs text-gray-500">1.0 m</span>
                    <span id="val-D" class="font-mono text-xl text-blue-300 font-bold">2.0 m</span>
                    <span class="text-xs text-gray-500">5.0 m</span>
                </div>
                <input type="range" id="input-D" min="1.0" max="5.0" step="0.1" value="2.0">
            </div>

            <!-- 屏幕視野寬度控制 -->
            <div class="mb-8">
                <label class="block text-sm font-medium mb-2 text-gray-300">屏幕視野寬度 (Zoom)</label>
                <div class="flex justify-between items-center mb-1">
                    <span class="text-xs text-gray-500">10 mm</span>
                    <span id="val-width" class="font-mono text-xl text-purple-300 font-bold">30 mm</span>
                    <span class="text-xs text-gray-500">50 mm</span>
                </div>
                <input type="range" id="input-width" min="10" max="50" step="1" value="30">
            </div>

            <!-- 結果顯示面板 -->
            <div class="bg-gray-900 rounded-lg p-4 border border-gray-600 mt-8">
                <h3 class="text-gray-400 text-sm uppercase tracking-wider mb-2">實驗測量結果</h3>
                <div class="flex justify-between items-end">
                    <span class="text-gray-300">亮紋間距 (Δy):</span>
                    <span id="result-dy" class="text-3xl font-bold text-green-400 font-mono">-- mm</span>
                </div>
            </div>
        </section>

        <!-- 右側：視覺化區域 -->
        <section class="lg:col-span-2 flex flex-col gap-6 h-full">
            
            <!-- 實驗配置 Top View -->
            <div class="bg-gray-800 rounded-xl p-4 shadow-xl border border-gray-700 flex flex-col flex-shrink-0">
                <div class="flex justify-between items-center mb-2">
                    <h3 class="text-lg font-semibold text-gray-200">實驗配置俯視圖 (Top View)</h3>
                    <span class="text-xs text-gray-500 bg-gray-900 px-2 py-1 rounded">*示意圖，非真實比例</span>
                </div>
                <div class="canvas-container bg-black rounded-lg overflow-hidden w-full h-48 flex items-center justify-center">
                    <canvas id="setupCanvas" class="w-full h-full"></canvas>
                </div>
            </div>

            <!-- 干涉條紋 Screen View (整合刻度尺) -->
            <div class="bg-gray-800 rounded-xl p-4 shadow-xl border border-gray-700 flex-grow flex flex-col">
                <h3 class="text-lg font-semibold text-gray-200 mb-4">屏幕干涉條紋 (Fringe Pattern)</h3>
                
                <!-- 修改：固定高度 h-[240px]，移除 min-h-[350px] 以縮窄高度 -->
                <div class="relative bg-black rounded-lg border-2 border-gray-600 overflow-hidden h-[240px]">
                    <!-- 干涉畫布 (包含刻度尺) -->
                    <canvas id="fringeCanvas" class="w-full h-full absolute top-0 left-0"></canvas>
                    
                    <!-- 中心虛線標記 -->
                    <div class="absolute top-1/4 bottom-1/4 left-1/2 border-l border-dashed border-gray-500 opacity-30 pointer-events-none"></div>
                </div>

                <div class="mt-2 text-center text-sm text-gray-400">
                    <p>屏幕寬度模擬範圍: <span id="screen-width-label">30</span> mm</p>
                </div>
            </div>

        </section>
    </main>

    <script>
        // --- 1. 初始化變數 ---
        const elements = {
            inputLambda: document.getElementById('input-lambda'),
            inputA: document.getElementById('input-a'),
            inputBigD: document.getElementById('input-D'),
            inputWidth: document.getElementById('input-width'),
            valLambda: document.getElementById('val-lambda'),
            valA: document.getElementById('val-a'),
            valBigD: document.getElementById('val-D'),
            valWidth: document.getElementById('val-width'),
            resultDy: document.getElementById('result-dy'),
            setupCanvas: document.getElementById('setupCanvas'),
            fringeCanvas: document.getElementById('fringeCanvas'),
            screenWidthLabel: document.getElementById('screen-width-label')
        };

        // 模擬參數 (初始值)
        let params = {
            lambda: 532, // nm
            a: 0.2,      // mm
            D: 2.0,      // m
            screenWidth: 30 // mm
        };

        // --- 2. 物理計算與顏色轉換 ---

        function wavelengthToColor(wavelength) {
            let R, G, B, alpha;
            if (wavelength >= 380 && wavelength < 440) {
                R = -(wavelength - 440) / (440 - 380); G = 0.0; B = 1.0;
            } else if (wavelength >= 440 && wavelength < 490) {
                R = 0.0; G = (wavelength - 440) / (490 - 440); B = 1.0;
            } else if (wavelength >= 490 && wavelength < 510) {
                R = 0.0; G = 1.0; B = -(wavelength - 510) / (510 - 490);
            } else if (wavelength >= 510 && wavelength < 580) {
                R = (wavelength - 510) / (580 - 510); G = 1.0; B = 0.0;
            } else if (wavelength >= 580 && wavelength < 645) {
                R = 1.0; G = -(wavelength - 645) / (645 - 580); B = 0.0;
            } else if (wavelength >= 645 && wavelength <= 750) {
                R = 1.0; G = 0.0; B = 0.0;
            } else {
                R = 0.0; G = 0.0; B = 0.0;
            }

            if (wavelength > 700) alpha = 0.3 + 0.7 * (750 - wavelength) / (750 - 700);
            else if (wavelength < 420) alpha = 0.3 + 0.7 * (wavelength - 380) / (420 - 380);
            else alpha = 1.0;

            const intensity = 255;
            return `rgba(${Math.round(R * intensity)}, ${Math.round(G * intensity)}, ${Math.round(B * intensity)}, ${alpha})`;
        }

        function calculateDeltaY() {
            const lambda_mm = params.lambda * 1e-6;
            const D_mm = params.D * 1e3;
            const a_mm = params.a; 
            return (lambda_mm * D_mm) / a_mm;
        }

        // --- 3. 繪圖函數 ---

        function resizeCanvas(canvas) {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            
            const ctx = canvas.getContext('2d');
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            
            return { width: rect.width, height: rect.height, ctx: ctx, physicalWidth: canvas.width, physicalHeight: canvas.height };
        }

        // 繪製俯視圖 (Top View)
        function drawSetup() {
            const { width, height, ctx } = resizeCanvas(elements.setupCanvas);
            
            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);

            const lightColor = wavelengthToColor(params.lambda);
            const startX = 40;
            const endX = width - 40;
            const centerY = height / 2;
            
            // 光源
            ctx.beginPath();
            ctx.arc(startX - 20, centerY, 5, 0, Math.PI * 2);
            ctx.fillStyle = lightColor;
            ctx.fill();

            // 雙縫板位置
            const dRatio = (params.D - 1.0) / (4.0); 
            const slitX = startX + 30 + (1 - dRatio) * (width * 0.4);

            // 繪製雙縫板
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 4;
            ctx.lineCap = 'square';
            
            const visualGap = 15 + (params.a - 0.1) * 20;
            const slitOpenSize = 6;

            // 1. 上方擋板
            ctx.beginPath();
            ctx.moveTo(slitX, 0);
            ctx.lineTo(slitX, centerY - visualGap/2 - slitOpenSize/2);
            ctx.stroke();

            // 2. 下方擋板
            ctx.beginPath();
            ctx.moveTo(slitX, height);
            ctx.lineTo(slitX, centerY + visualGap/2 + slitOpenSize/2);
            ctx.stroke();

            // 3. 中間阻隔擋板
            ctx.beginPath();
            ctx.moveTo(slitX, centerY - visualGap/2 + slitOpenSize/2);
            ctx.lineTo(slitX, centerY + visualGap/2 - slitOpenSize/2);
            ctx.stroke();

            // 屏幕
            ctx.fillStyle = '#DDD';
            ctx.fillRect(endX, 10, 6, height - 20);

            // 光線 (示意)
            ctx.lineWidth = 1;
            ctx.strokeStyle = lightColor;
            ctx.globalAlpha = 0.5;

            // 光源到縫 (兩束)
            ctx.beginPath();
            ctx.moveTo(startX - 20, centerY);
            ctx.lineTo(slitX, centerY - visualGap/2); // 上縫中心
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(startX - 20, centerY);
            ctx.lineTo(slitX, centerY + visualGap/2); // 下縫中心
            ctx.stroke();

            // 縫到屏幕
            ctx.beginPath();
            ctx.moveTo(slitX, centerY - visualGap/2);
            ctx.lineTo(endX, centerY);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(slitX, centerY + visualGap/2);
            ctx.lineTo(endX, centerY);
            ctx.stroke();
            
            ctx.globalAlpha = 1.0;
            
            // 標註
            ctx.fillStyle = '#FFF';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`a`, slitX + 10, centerY + visualGap/2 + 25);
            ctx.fillText(`D`, (slitX + endX)/2, centerY - 10);
        }

        // 繪製干涉條紋 + 刻度尺 (整合)
        function drawFringesAndRuler() {
            const { width, height, ctx, physicalWidth, physicalHeight } = resizeCanvas(elements.fringeCanvas);
            const color = wavelengthToColor(params.lambda);
            
            // 物理參數
            const lambda = params.lambda * 1e-9; 
            const D = params.D; 
            const a = params.a * 1e-3; 
            
            const pixelsPerMeter = physicalWidth / (params.screenWidth * 1e-3);
            
            // --- 1. 繪製干涉條紋 ---
            const imgData = ctx.createImageData(physicalWidth, physicalHeight);
            const data = imgData.data;
            
            // 解析 RGB
            const tempDiv = document.createElement('div');
            tempDiv.style.color = color;
            document.body.appendChild(tempDiv);
            const rgbStyle = window.getComputedStyle(tempDiv).color; 
            document.body.removeChild(tempDiv);
            const rgbMatch = rgbStyle.match(/\d+/g);
            
            let r = 0, g = 255, b = 0;
            if (rgbMatch && rgbMatch.length >= 3) {
                r = parseInt(rgbMatch[0]);
                g = parseInt(rgbMatch[1]);
                b = parseInt(rgbMatch[2]);
            }

            const centerX = physicalWidth / 2;
            const centerY = physicalHeight / 2;
            const patternHeightSigma = physicalHeight / 50; 

            for (let x = 0; x < physicalWidth; x++) {
                // 物理位置 (相對於中心)
                const posMeters = (x - centerX) / pixelsPerMeter;

                // 干涉公式
                const phase = (Math.PI * a * posMeters) / (lambda * D);
                const intensityX = Math.cos(phase) * Math.cos(phase);

                // 水平方向的高斯衰減
                const envelopeX = Math.exp( - (posMeters * posMeters) / (2 * Math.pow(0.012, 2)) ); 

                for (let y = 0; y < physicalHeight; y++) {
                    // 垂直方向的高斯衰減
                    const distY = y - centerY;
                    const intensityY = Math.exp( - (distY * distY) / (2 * (patternHeightSigma * patternHeightSigma)));

                    const finalAlpha = intensityX * envelopeX * intensityY * 255;

                    const index = (y * physicalWidth + x) * 4;
                    data[index] = r;
                    data[index + 1] = g;
                    data[index + 2] = b;
                    data[index + 3] = finalAlpha;
                }
            }
            
            ctx.putImageData(imgData, 0, 0);

            // --- 2. 繪製刻度尺 ---
            // 修改：因為高度變小，刻度尺的位置需要上移
            // 之前是 (height/2) + 80，現在高度 240px，中心是 120，所以大概在 180px 比較合適
            const rulerY = (height / 2) + 60; 

            ctx.fillStyle = '#9CA3AF'; 
            ctx.strokeStyle = '#9CA3AF';
            ctx.lineWidth = 1.5;
            ctx.font = '11px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';

            // 畫主軸線
            ctx.beginPath();
            ctx.moveTo(0, rulerY);
            ctx.lineTo(width, rulerY);
            ctx.stroke();

            const pixelsPerMm = width / params.screenWidth;
            const cssCenterX = width / 2;

            // 從中心向左右畫刻度
            for (let i = 0; i <= params.screenWidth / 2; i++) {
                // 向右
                let xRight = cssCenterX + i * pixelsPerMm;
                // 向左
                let xLeft = cssCenterX - i * pixelsPerMm;

                let tickH = (i % 5 === 0) ? 10 : 5;
                if (i === 0) tickH = 12;

                // 畫右側刻度
                if (xRight < width) {
                    ctx.beginPath();
                    ctx.moveTo(xRight, rulerY);
                    ctx.lineTo(xRight, rulerY + tickH);
                    ctx.stroke();
                    if (i % 5 === 0) { // 修改：移除 || i === 1，只標記 0, 5, 10...
                        ctx.fillText(i, xRight, rulerY + 14);
                    }
                }

                // 畫左側刻度 (排除0)
                if (i !== 0 && xLeft > 0) {
                    ctx.beginPath();
                    ctx.moveTo(xLeft, rulerY);
                    ctx.lineTo(xLeft, rulerY + tickH);
                    ctx.stroke();
                    if (i % 5 === 0) { // 修改：移除 || i === 1
                        ctx.fillText(-i, xLeft, rulerY + 14);
                    }
                }
            }
            
            // 標籤
            ctx.fillStyle = '#6B7280'; // gray-500
            ctx.fillText("(mm)", width - 20, rulerY + 14);
        }


        // --- 4. 事件處理與更新 ---

        function updateValues() {
            params.lambda = parseInt(elements.inputLambda.value);
            params.a = parseFloat(elements.inputA.value);
            params.D = parseFloat(elements.inputBigD.value);
            params.screenWidth = parseInt(elements.inputWidth.value); 

            elements.valLambda.innerText = `${params.lambda} nm`;
            elements.valLambda.style.color = wavelengthToColor(params.lambda);
            elements.valA.innerText = `${params.a.toFixed(2)} mm`;
            elements.valBigD.innerText = `${params.D.toFixed(1)} m`;
            elements.valWidth.innerText = `${params.screenWidth} mm`; 

            const dy = calculateDeltaY();
            elements.resultDy.innerText = `${dy.toFixed(2)} mm`;
            
            elements.screenWidthLabel.innerText = params.screenWidth;

            drawSetup();
            drawFringesAndRuler();
        }

        elements.inputLambda.addEventListener('input', updateValues);
        elements.inputA.addEventListener('input', updateValues);
        elements.inputBigD.addEventListener('input', updateValues);
        elements.inputWidth.addEventListener('input', updateValues); 
        
        window.addEventListener('resize', () => {
            drawSetup();
            drawFringesAndRuler();
        });

        setTimeout(() => {
            updateValues();
        }, 100);

    </script>
</body>
</html>