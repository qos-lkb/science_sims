<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OTTV 進階模擬器 (3D) / Advanced Simulator 3D</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- MathJax for LaTeX Rendering -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    <script type="text/javascript" id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
    </script>

    <!-- Three.js & OrbitControls -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <style>
        /* 自定義滑桿樣式 - 更清晰 */
        input[type=range] {
            -webkit-appearance: none; 
            width: 100%; 
            background: transparent; 
        }
        
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 24px;
            width: 24px;
            border-radius: 50%;
            background: #ffffff;
            border: 2px solid currentColor; /* 使用當前文字顏色 */
            cursor: pointer;
            margin-top: -8px; 
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            transition: transform 0.1s;
        }

        input[type=range]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 8px;
            cursor: pointer;
            background: #e2e8f0;
            border-radius: 4px;
        }

        /* 針對不同滑桿顏色的 Thumb 邊框設置 */
        #input-wwr::-webkit-slider-thumb { border-color: #2563eb; }
        #input-sc::-webkit-slider-thumb { border-color: #06b6d4; }
        #input-ug::-webkit-slider-thumb { border-color: #ef4444; }
        #input-uw::-webkit-slider-thumb { border-color: #78716c; }

        /* Canvas Container */
        #canvas-container {
            width: 100%;
            height: 100%;
            outline: none;
        }
        canvas {
            outline: none;
        }
    </style>
</head>
<body class="bg-slate-100 font-sans text-slate-800 h-screen flex flex-col overflow-hidden">

    <!-- 1. Header -->
    <nav class="bg-slate-900 text-white p-3 shadow-lg flex-none z-10">
        <div class="container mx-auto flex justify-between items-center">
            <div class="flex items-center space-x-3">
                <div class="bg-yellow-500 text-slate-900 font-bold rounded-full w-8 h-8 flex items-center justify-center">Ph</div>
                <h1 class="text-lg md:text-xl font-bold tracking-wide" id="app-title">OTTV 建築物理模擬 (3D)</h1>
            </div>
            <div class="flex space-x-3">
                <button onclick="toggleModal(true)" class="text-yellow-400 hover:text-yellow-300 font-semibold text-sm border border-yellow-400 rounded px-3 py-1 hover:bg-yellow-400/10 transition">
                    <i class="fas fa-info-circle"></i> <span id="btn-help">定義與公式</span>
                </button>
                <button onclick="toggleLanguage()" class="bg-slate-700 hover:bg-slate-600 text-white text-xs font-bold py-1 px-3 rounded transition">
                    中 / EN
                </button>
            </div>
        </div>
    </nav>

    <!-- Main Layout: Grid 1:3 比例 -->
    <main class="flex-grow container mx-auto p-4 md:p-6 grid grid-cols-1 lg:grid-cols-3 gap-6 overflow-hidden h-full">
        
        <!-- Left Column: Controls & Calc (1/3) -->
        <div class="lg:col-span-1 flex flex-col gap-4 h-full overflow-hidden pr-1 pb-1">
            
            <!-- 3. Control Panel (Sliders) -->
            <div class="bg-white p-5 rounded-xl shadow-md border border-slate-200 flex-shrink-0 overflow-y-auto max-h-[50vh]">
                <h3 class="text-sm font-bold text-slate-500 uppercase tracking-wider mb-5 border-b pb-2" id="controls-title">變數控制 / Variables</h3>
                
                <div class="flex flex-col gap-6">
                    
                    <!-- Slider 1: WWR -->
                    <div class="relative">
                        <div class="flex justify-between mb-2">
                            <label class="font-bold text-slate-700 text-sm flex items-center whitespace-nowrap">
                                <span class="w-3 h-3 rounded-full bg-blue-500 mr-2"></span>
                                <span id="label-wwr">窗牆比例 (WWR)</span>
                            </label>
                            <span id="val-wwr" class="font-mono font-bold text-blue-600 text-lg">30%</span>
                        </div>
                        <input type="range" id="input-wwr" min="10" max="90" value="30" step="5"
                            class="accent-blue-600">
                    </div>

                    <!-- Slider 2: SC -->
                    <div class="relative">
                        <div class="flex justify-between mb-2">
                            <label class="font-bold text-slate-700 text-sm flex items-center whitespace-nowrap">
                                <span class="w-3 h-3 rounded-full bg-cyan-400 mr-2"></span>
                                <span id="label-sc">遮蔽係數 (SC)</span>
                            </label>
                            <span id="val-sc" class="font-mono font-bold text-cyan-600 text-lg">0.7</span>
                        </div>
                        <input type="range" id="input-sc" min="0.1" max="1.0" value="0.7" step="0.1"
                            class="accent-cyan-500">
                        <p class="text-[10px] text-gray-400 mt-1 text-right" id="hint-sc">1.0 = 透明, 0.1 = 全遮光</p>
                    </div>

                    <!-- Slider 3: Ug -->
                    <div class="relative">
                        <div class="flex justify-between mb-2">
                            <label class="font-bold text-slate-700 text-sm flex items-center whitespace-nowrap">
                                <span class="w-3 h-3 rounded-full bg-red-400 mr-2"></span>
                                <span id="label-ug">玻璃 U-Value ($U_g$)</span>
                            </label>
                            <span id="val-ug" class="font-mono font-bold text-red-600 text-lg">5.0</span>
                        </div>
                        <input type="range" id="input-ug" min="1.0" max="6.0" value="5.0" step="0.5"
                            class="accent-red-500">
                         <p class="text-[10px] text-gray-400 mt-1 text-right" id="hint-ug">單位: $W/m^2K$ (低 = 隔熱好)</p>
                    </div>

                    <!-- Slider 4: Uw -->
                    <div class="relative">
                        <div class="flex justify-between mb-2">
                            <label class="font-bold text-slate-700 text-sm flex items-center whitespace-nowrap">
                                <span class="w-3 h-3 rounded-full bg-stone-500 mr-2"></span>
                                <span id="label-uw">牆體 U-Value ($U_w$)</span>
                            </label>
                            <span id="val-uw" class="font-mono font-bold text-stone-600 text-lg">2.0</span>
                        </div>
                        <input type="range" id="input-uw" min="0.5" max="3.5" value="2.0" step="0.5"
                            class="accent-stone-500">
                        <p class="text-[10px] text-gray-400 mt-1 text-right" id="hint-uw">單位: $W/m^2K$</p>
                    </div>
                </div>
            </div>

            <!-- Calculation Section (Stacked below controls) -->
            <div class="flex flex-col bg-white rounded-xl shadow-md border border-slate-200 overflow-hidden flex-grow min-h-0">
                <div class="bg-slate-800 text-slate-100 p-4 border-b border-slate-700 flex-none">
                    <h2 class="text-md font-bold flex items-center justify-between">
                        <div class="flex items-center">
                            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 7h6m0 10v-3m-3 3h.01M9 17h.01M9 14h.01M12 14h.01M15 11h.01M12 11h.01M9 11h.01M7 21h10a2 2 0 002-2V5a2 2 0 00-2-2H7a2 2 0 00-2 2v14a2 2 0 002 2z"></path></svg>
                            <span id="calc-title">實時計算</span>
                        </div>
                        <div class="text-right">
                            <span id="result-ottv" class="text-2xl font-mono font-bold text-green-400">0.00</span>
                            <span class="text-xs text-green-500 ml-1">W/m²</span>
                        </div>
                    </h2>
                </div>

                <div class="p-4 overflow-y-auto space-y-4 bg-slate-50 flex-grow">
                    <!-- Wall Heat -->
                    <div class="bg-white p-3 rounded border border-stone-200 shadow-sm">
                        <h4 class="text-xs font-bold text-stone-500 uppercase mb-1 flex justify-between">
                            <span id="title-wall-heat">1. 牆體傳熱</span>
                            <span class="text-stone-700 font-mono" id="res-qw"></span>
                        </h4>
                        <div class="text-sm text-stone-800 overflow-x-hidden">
                            <div id="math-wall" class="text-xs text-stone-600 font-mono"></div>
                        </div>
                    </div>

                    <!-- Glass Heat -->
                    <div class="bg-white p-3 rounded border border-blue-200 shadow-sm">
                        <h4 class="text-xs font-bold text-blue-500 uppercase mb-1 flex justify-between">
                            <span id="title-glass-heat">2. 玻璃傳熱</span>
                            <span class="text-blue-700 font-mono" id="res-qg"></span>
                        </h4>
                        <div class="text-sm text-blue-800 overflow-x-hidden">
                            <div id="math-glass" class="text-xs text-blue-600 font-mono"></div>
                        </div>
                    </div>

                    <!-- Summary -->
                    <div class="pt-2 border-t border-dashed border-gray-300">
                         <div id="math-total" class="text-sm font-bold text-center text-slate-700"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right Column: Visualization (2/3) -->
        <div class="lg:col-span-2 flex flex-col h-full overflow-hidden">
            <!-- 2. Visualization Area -->
            <div class="bg-slate-900 rounded-xl shadow-lg border border-slate-700 h-full flex flex-col relative overflow-hidden group">
                
                <!-- Info Overlay -->
                <div class="absolute top-4 left-4 z-10">
                     <div class="bg-white/90 backdrop-blur px-3 py-1.5 rounded shadow-sm text-xs font-mono text-slate-700 border border-white/20">
                         <span id="env-info">TD_eq: 12K | ΔT: 8K | SF: 160</span>
                    </div>
                </div>
                
                <!-- 3D Canvas Container -->
                <div id="canvas-container" class="cursor-move"></div>

                <!-- Instruction Overlay -->
                <div class="absolute bottom-4 right-4 z-10 pointer-events-none opacity-50 group-hover:opacity-100 transition-opacity">
                    <span class="bg-black/60 text-white text-[10px] px-2 py-1 rounded">
                        <i class="fas fa-mouse"></i> Drag to Rotate | Scroll to Zoom
                    </span>
                </div>
            </div>
        </div>

    </main>

    <!-- Modal -->
    <div id="info-modal" class="fixed inset-0 bg-black/70 backdrop-blur-sm hidden z-50 flex items-center justify-center p-4 transition-opacity">
        <div class="bg-white rounded-xl shadow-2xl max-w-2xl w-full max-h-[90vh] overflow-y-auto transform scale-100 transition-transform">
            <div class="p-6">
                <div class="flex justify-between items-center border-b pb-3 mb-4">
                    <h3 class="text-xl font-bold text-slate-800" id="modal-title">OTTV 參數定義</h3>
                    <button onclick="toggleModal(false)" class="text-gray-400 hover:text-red-500 text-2xl font-bold">&times;</button>
                </div>
                
                <div class="space-y-4 text-gray-700 text-sm leading-relaxed" id="modal-content">
                    <p>OTTV (Overall Thermal Transfer Value) 是評估建築外殼熱效能的指標。本模擬器使用簡化公式：</p>
                    <div class="bg-slate-100 p-3 rounded text-center my-2">
                        $$ OTTV = (1-WWR)Q_{w} + WWR \times Q_{g} $$
                    </div>
                    
                    <h4 class="font-bold text-base text-slate-900 mt-4 border-l-4 border-blue-500 pl-2">可控變數 (Variables)</h4>
                    <ul class="list-disc list-inside ml-2 space-y-2">
                        <li><strong>WWR (窗牆比)</strong>: 玻璃面積佔外牆總面積的比例。數值越大，接收的太陽熱能通常越多。</li>
                        <li><strong>$U_g$ (玻璃傳導值)</strong>: 玻璃的隔熱能力。數值越低越好（例如雙層中空玻璃 U 值約 2.0，單層約 5.8）。</li>
                        <li><strong>$SC$ (遮蔽係數)</strong>: 玻璃阻擋太陽輻射的能力。數值越低代表阻擋越多熱能（例如貼了反光膜）。</li>
                        <li><strong>$U_w$ (牆體傳導值)</strong>: 混凝土牆的隔熱能力。加裝隔熱層可降低此數值。</li>
                    </ul>

                    <h4 class="font-bold text-base text-slate-900 mt-4 border-l-4 border-gray-500 pl-2">環境常數 (Constants)</h4>
                    <ul class="list-disc list-inside ml-2 space-y-1 text-gray-500">
                        <li>$TD_{eq}$ (牆體等效溫差): 12 K</li>
                        <li>$\Delta T$ (室內外溫差): 8 K</li>
                        <li>$SF$ (太陽輻射因子): 160 $W/m^2$</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <!-- Logic -->
    <script>
        // State
        const state = {
            wwr: 30, // %
            sc: 0.7,
            ug: 5.0,
            uw: 2.0
        };

        // Constants (Environmental)
        const env = {
            TDeq: 12,
            DT: 8,
            SF: 160
        };

        // DOM Elements
        const els = {
            inputWwr: document.getElementById('input-wwr'),
            inputSc: document.getElementById('input-sc'),
            inputUg: document.getElementById('input-ug'),
            inputUw: document.getElementById('input-uw'),
            valWwr: document.getElementById('val-wwr'),
            valSc: document.getElementById('val-sc'),
            valUg: document.getElementById('val-ug'),
            valUw: document.getElementById('val-uw'),
            mathWall: document.getElementById('math-wall'),
            mathGlass: document.getElementById('math-glass'),
            mathTotal: document.getElementById('math-total'),
            resQw: document.getElementById('res-qw'),
            resQg: document.getElementById('res-qg'),
            resOttv: document.getElementById('result-ottv'),
            modal: document.getElementById('info-modal'),
            visualTitle: document.getElementById('app-title')
        };

        // Three.js Globals
        let scene, camera, renderer, controls;
        let buildingGroup, wallMesh, sunMesh;
        let windows = []; // Array to store 4 window meshes
        
        // --- Three.js Initialization ---
        function init3D() {
            const container = document.getElementById('canvas-container');
            
            // 1. Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0f172a); // Slate-900 matching
            scene.fog = new THREE.Fog(0x0f172a, 10, 60);

            // 2. Camera
            camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 100);
            camera.position.set(15, 12, 15); // Perspective from corner

            // 3. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            // 4. Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 1.0;

            // 5. Lights
            // Ambient
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            
            // Sun Light (Directional)
            const sunLight = new THREE.DirectionalLight(0xffaa00, 1.2);
            sunLight.position.set(20, 20, 10);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            scene.add(sunLight);

            // 6. Objects
            
            // Ground
            const planeGeometry = new THREE.PlaneGeometry(100, 100);
            const planeMaterial = new THREE.MeshStandardMaterial({ color: 0x1e293b });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = -5; // Lower ground
            plane.receiveShadow = true;
            scene.add(plane);

            // Building Group
            buildingGroup = new THREE.Group();
            scene.add(buildingGroup);

            // Building Core (Concrete Prism)
            // Size: 6 width, 10 height, 6 depth
            const bWidth = 6;
            const bHeight = 10;
            const bDepth = 6;
            
            const wallGeo = new THREE.BoxGeometry(bWidth, bHeight, bDepth);
            const wallMat = new THREE.MeshStandardMaterial({ 
                color: 0x808080, 
                roughness: 0.9,
                metalness: 0.1
            });
            wallMesh = new THREE.Mesh(wallGeo, wallMat);
            wallMesh.castShadow = true;
            wallMesh.receiveShadow = true;
            buildingGroup.add(wallMesh);

            // Windows (4 sides)
            // Logic: Create 4 planes slightly offset from the faces
            const winMat = new THREE.MeshPhysicalMaterial({
                color: 0x38bdf8,
                metalness: 0.2,
                roughness: 0.1,
                transparent: true,
                opacity: 0.6,
                transmission: 0.6, // Glass-like
                side: THREE.DoubleSide
            });

            // Initial Geometry (will be scaled)
            const winGeo = new THREE.PlaneGeometry(1, 1); 

            // Create 4 windows
            const positions = [
                { x: 0, y: 0, z: bDepth/2 + 0.05, rotY: 0 },       // Front
                { x: 0, y: 0, z: -bDepth/2 - 0.05, rotY: Math.PI }, // Back
                { x: bWidth/2 + 0.05, y: 0, z: 0, rotY: Math.PI/2 }, // Right
                { x: -bWidth/2 - 0.05, y: 0, z: 0, rotY: -Math.PI/2 } // Left
            ];

            positions.forEach(pos => {
                const mesh = new THREE.Mesh(winGeo, winMat);
                mesh.position.set(pos.x, pos.y, pos.z);
                mesh.rotation.y = pos.rotY;
                buildingGroup.add(mesh);
                windows.push(mesh);
            });

            // Sun (Visual Sphere)
            const sunGeo = new THREE.SphereGeometry(2, 32, 32);
            const sunMat = new THREE.MeshBasicMaterial({ color: 0xffdd00 });
            sunMesh = new THREE.Mesh(sunGeo, sunMat);
            sunMesh.position.copy(sunLight.position);
            scene.add(sunMesh);

            // Handle Resize
            window.addEventListener('resize', onWindowResize, false);
            
            animate();
        }

        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            if(!container) return;
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // --- Main Logic ---

        function update() {
            // Read Values
            state.wwr = parseInt(els.inputWwr.value);
            state.sc = parseFloat(els.inputSc.value);
            state.ug = parseFloat(els.inputUg.value);
            state.uw = parseFloat(els.inputUw.value);

            // Update Labels
            els.valWwr.innerText = state.wwr + '%';
            els.valSc.innerText = state.sc.toFixed(1);
            els.valUg.innerText = state.ug.toFixed(1);
            els.valUw.innerText = state.uw.toFixed(1);

            // --- 3D Visual Updates ---
            if(windows.length > 0) {
                // Building Dimensions (from init3D)
                const bWidth = 6;
                const bHeight = 10;
                
                // Calculate Window Dimensions based on WWR
                // Area of one facade = 6 * 10 = 60
                // Window Area = 60 * (WWR/100)
                // Let's assume aspect ratio of window mimics facade (0.6)
                // w * h = Area
                // w / h = 0.6 => w = 0.6h
                // 0.6h^2 = Area => h = sqrt(Area/0.6)
                
                const faceArea = bWidth * bHeight;
                const winArea = faceArea * (state.wwr / 100);
                
                let h = Math.sqrt(winArea / (bWidth/bHeight));
                let w = h * (bWidth/bHeight);

                // Clamp to not exceed building
                const margin = 0.2;
                if(h > bHeight - margin) {
                    h = bHeight - margin;
                    w = winArea / h;
                }
                if(w > bWidth - margin) {
                    w = bWidth - margin;
                    h = winArea / w;
                }

                // Apply to all 4 windows
                windows.forEach(win => {
                    win.scale.set(w, h, 1);
                    
                    // Update Material (SC effects)
                    const opacity = 1.0 - (state.sc * 0.7); // Darker when SC is low
                    win.material.opacity = opacity;
                    
                    const lightBlue = new THREE.Color(0x38bdf8);
                    const darkBlue = new THREE.Color(0x021f30); // Very dark for low SC
                    win.material.color.lerpColors(darkBlue, lightBlue, state.sc);
                    win.material.roughness = state.sc * 0.3; 
                });
            }

            // --- Calculations ---
            const wwrRatio = state.wwr / 100;
            const wallPart = (1 - wwrRatio);
            
            const Qw = env.TDeq * state.uw;
            const Qg_cond = env.DT * state.ug;
            const Qg_solar = env.SF * state.sc;
            const Qg = Qg_cond + Qg_solar;
            const OTTV = (wallPart * Qw) + (wwrRatio * Qg);

            // Render Results
            els.resQw.innerText = Qw.toFixed(1);
            els.resQg.innerText = Qg.toFixed(1);
            els.resOttv.innerText = OTTV.toFixed(2);

            // Render Math
            els.mathWall.innerHTML = `
                $$ 
                \\begin{aligned}
                Q_{w} &= ${env.TDeq} \\times ${state.uw} = ${Qw.toFixed(1)} \\\\
                Contribution &= ${(1-wwrRatio).toFixed(2)} \\times ${Qw.toFixed(1)} = \\mathbf{${(wallPart * Qw).toFixed(1)}}
                \\end{aligned}
                $$
            `;

            els.mathGlass.innerHTML = `
                $$ 
                \\begin{aligned}
                Q_{g} &= (${env.DT} \\times ${state.ug}) + (${env.SF} \\times ${state.sc}) = ${Qg.toFixed(1)} \\\\
                Contribution &= ${wwrRatio.toFixed(2)} \\times ${Qg.toFixed(1)} = \\mathbf{${(wwrRatio * Qg).toFixed(1)}}
                \\end{aligned}
                $$
            `;

            els.mathTotal.innerText = `$$ Total = ${(wallPart*Qw).toFixed(1)} + ${(wwrRatio*Qg).toFixed(1)} = ${OTTV.toFixed(2)} \\; W/m^2 $$`;

            if(window.MathJax) {
                MathJax.typesetPromise([els.mathWall, els.mathGlass, els.mathTotal]).catch(e => {});
            }
        }

        // Language System
        let curLang = 'zh';
        const txt = {
            zh: {
                title: "OTTV 建築物理模擬 (3D)",
                btnHelp: "定義與公式",
                controlsTitle: "變數控制",
                lblWwr: "窗牆比例 (WWR)",
                lblSc: "遮蔽係數 (SC)",
                hintSc: "1.0 = 透明, 0.1 = 全遮光",
                lblUg: "玻璃 U-Value ($U_g$)",
                hintUg: "單位: $W/m^2K$ (低 = 隔熱好)",
                lblUw: "牆體 U-Value ($U_w$)",
                hintUw: "單位: $W/m^2K$ (混凝土)",
                calcTitle: "實時計算",
                lblWallHeat: "1. 牆體傳熱 (Wall)",
                lblGlassHeat: "2. 玻璃傳熱 (Glass)",
                modalTitle: "OTTV 參數定義",
                modalContent: `
                    <p>OTTV (Overall Thermal Transfer Value) 是評估建築外殼熱效能的指標。</p>
                    <div class="bg-slate-100 p-3 rounded text-center my-2">$$ OTTV = (1-WWR)Q_{w} + WWR \\times Q_{g} $$</div>
                    <ul class="list-disc list-inside ml-2 space-y-2">
                        <li><strong>WWR (窗牆比)</strong>: 玻璃面積佔外牆總面積的比例。</li>
                        <li><strong>$U_g$</strong>: 玻璃傳導係數 (Conduction)。</li>
                        <li><strong>$SC$</strong>: 遮蔽係數 (Radiation)。</li>
                    </ul>
                `
            },
            en: {
                title: "OTTV Physics Simulation (3D)",
                btnHelp: "Definition & Formula",
                controlsTitle: "Variables Control",
                lblWwr: "Window-Wall Ratio (WWR)",
                lblSc: "Shading Coeff. (SC)",
                hintSc: "1.0 = Clear, 0.1 = Blocked",
                lblUg: "Glass U-Value ($U_g$)",
                hintUg: "Unit: $W/m^2K$ (Lower is better)",
                lblUw: "Wall U-Value ($U_w$)",
                hintUw: "Unit: $W/m^2K$ (Concrete)",
                calcTitle: "Live Calculation",
                lblWallHeat: "1. Wall Heat Transfer",
                lblGlassHeat: "2. Glass Heat Transfer",
                modalTitle: "OTTV Parameters",
                modalContent: `
                    <p>OTTV measures the average heat gain through the building envelope.</p>
                    <div class="bg-slate-100 p-3 rounded text-center my-2">$$ OTTV = (1-WWR)Q_{w} + WWR \\times Q_{g} $$</div>
                    <ul class="list-disc list-inside ml-2 space-y-2">
                        <li><strong>WWR</strong>: Ratio of window area to gross wall area.</li>
                        <li><strong>$U_g$</strong>: Glass U-value.</li>
                        <li><strong>$SC$</strong>: Shading Coefficient.</li>
                    </ul>
                `
            }
        };

        function toggleLanguage() {
            curLang = curLang === 'zh' ? 'en' : 'zh';
            const t = txt[curLang];
            
            document.getElementById('app-title').innerText = t.title;
            document.getElementById('btn-help').innerText = t.btnHelp;
            document.getElementById('controls-title').innerText = t.controlsTitle;
            document.getElementById('label-wwr').innerText = t.lblWwr;
            document.getElementById('label-sc').innerText = t.lblSc;
            document.getElementById('hint-sc').innerText = t.hintSc;
            document.getElementById('label-ug').innerText = t.lblUg;
            document.getElementById('hint-ug').innerText = t.hintUg;
            document.getElementById('label-uw').innerText = t.lblUw;
            document.getElementById('hint-uw').innerText = t.hintUw;
            document.getElementById('calc-title').innerText = t.calcTitle;
            document.getElementById('title-wall-heat').innerText = t.lblWallHeat;
            document.getElementById('title-glass-heat').innerText = t.lblGlassHeat;
            // 移除了 visual-title 的更新，因為該 ID 在這個版本中不存在
            document.getElementById('modal-title').innerText = t.modalTitle;
            document.getElementById('modal-content').innerHTML = t.modalContent;
            
            MathJax.typesetPromise([document.getElementById('modal-content'), document.getElementById('label-ug'), document.getElementById('label-uw')]);
            update();
        }

        function toggleModal(show) {
            const m = els.modal;
            if(show) m.classList.remove('hidden');
            else m.classList.add('hidden');
        }

        // Listeners
        els.inputWwr.addEventListener('input', update);
        els.inputSc.addEventListener('input', update);
        els.inputUg.addEventListener('input', update);
        els.inputUw.addEventListener('input', update);

        window.addEventListener('load', () => {
            init3D();
            update();
            // Trigger resize once to fix canvas size
            setTimeout(onWindowResize, 100);
        });

    </script>
</body>
</html>