<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>çª—å£å¼å†·æ°£æ©Ÿé‹ä½œåŸç†æ¨¡æ“¬ (é«˜æ¸…ç‰ˆ)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Noto Sans TC', sans-serif;
            background-color: #f0f4f8;
        }
        .glass-panel {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }
        /* Custom Slider */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 24px;
            width: 24px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            margin-top: -8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            border: 2px solid white;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 8px;
            cursor: pointer;
            background: #dbeafe;
            border-radius: 4px;
        }
        
        canvas {
            border-radius: 12px;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.05);
            background: white;
            width: 100%; 
            height: auto;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center p-4">

    <!-- Header -->
    <header class="w-full max-w-5xl mb-4 flex justify-between items-center">
        <div>
            <h1 class="text-2xl font-bold text-slate-800">çª—å£å¼å†·æ°£æ©Ÿé‹ä½œåŸç†</h1>
            <p class="text-slate-500 text-sm">ç‰©ç†ç§‘æ•™å­¸æ¨¡æ“¬ï¼šVapor Compression Cycle</p>
        </div>
        <div class="flex gap-4">
            <div class="bg-blue-100 text-blue-800 px-4 py-2 rounded-lg text-center shadow-sm border border-blue-200">
                <div class="text-xs uppercase tracking-wider font-semibold">å®¤å…§æº«åº¦</div>
                <div class="text-2xl font-bold" id="indoorTempDisplay">28.0Â°C</div>
            </div>
            <div class="bg-orange-100 text-orange-800 px-4 py-2 rounded-lg text-center shadow-sm border border-orange-200">
                <div class="text-xs uppercase tracking-wider font-semibold">å®¤å¤–æº«åº¦</div>
                <div class="text-2xl font-bold">32.0Â°C</div>
            </div>
        </div>
    </header>

    <!-- Main Simulation Area -->
    <main class="relative w-full max-w-5xl bg-white rounded-2xl shadow-xl overflow-hidden flex flex-col md:flex-row border border-slate-200">
        
        <!-- Canvas Container -->
        <div class="relative flex-grow bg-slate-50 p-4 flex justify-center items-center min-h-[500px]">
            
            <!-- Background Dividers (Indoor/Outdoor) -->
            <div class="absolute inset-0 flex pointer-events-none">
                <div class="w-1/2 h-full bg-blue-50/50 border-r-2 border-dashed border-slate-300 flex items-start justify-center pt-4">
                    <span class="text-blue-300 font-bold text-4xl opacity-20 select-none">å®¤å…§ (INDOOR)</span>
                </div>
                <div class="w-1/2 h-full bg-orange-50/50 flex items-start justify-center pt-4">
                    <span class="text-orange-300 font-bold text-4xl opacity-20 select-none">å®¤å¤– (OUTDOOR)</span>
                </div>
            </div>

            <!-- The Canvas -->
            <canvas id="simCanvas"></canvas>
        </div>

        <!-- Sidebar Controls & Info -->
        <div class="w-full md:w-80 bg-slate-50 border-l border-slate-200 p-6 flex flex-col gap-6">
            
            <!-- Controls -->
            <div class="bg-white p-4 rounded-xl shadow-sm border border-slate-100">
                <label class="block text-sm font-bold text-slate-700 mb-2 flex justify-between">
                    <span>é‹ä½œåŠŸç‡ (Power)</span>
                    <span id="powerValue" class="text-blue-600">0%</span>
                </label>
                <input type="range" id="powerSlider" min="0" max="100" value="0" step="1">
                <div class="flex justify-between text-xs text-slate-400 mt-1">
                    <span>é—œé–‰</span>
                    <span>æœ€å¤§</span>
                </div>
            </div>

            <!-- Legend / Status -->
            <div class="flex-grow space-y-3">
                <h3 class="font-bold text-slate-700 border-b pb-2 text-sm">è£½å†·åŠ‘ç‹€æ…‹ (Refrigerant)</h3>
                
                <!-- State 1 -->
                <div class="flex items-center gap-3 text-sm bg-white p-2 rounded border border-slate-100 shadow-sm">
                    <div class="w-4 h-4 rounded-full bg-red-500 flex-shrink-0 animate-pulse border border-red-600"></div>
                    <div>
                        <span class="font-bold text-slate-800 block text-xs">é«˜æº«é«˜å£“æ°£é«”</span>
                        <span class="text-slate-500 text-[10px]">å£“ç¸®æ©Ÿ â” å†·å‡å™¨</span>
                    </div>
                </div>

                <!-- State 2 -->
                <div class="flex items-center gap-3 text-sm bg-white p-2 rounded border border-slate-100 shadow-sm">
                    <div class="w-4 h-4 rounded-full bg-orange-500 flex-shrink-0 border border-orange-600"></div>
                    <div>
                        <span class="font-bold text-slate-800 block text-xs">ä¸­æº«é«˜å£“æ¶²é«”</span>
                        <span class="text-slate-500 text-[10px]">å†·å‡å™¨ â” è†¨è„¹é–¥</span>
                    </div>
                </div>

                <!-- State 3 -->
                <div class="flex items-center gap-3 text-sm bg-white p-2 rounded border border-slate-100 shadow-sm">
                    <div class="w-4 h-4 rounded-full bg-cyan-300 flex-shrink-0 border border-cyan-400"></div>
                    <div>
                        <span class="font-bold text-slate-800 block text-xs">ä½æº«ä½å£“æ¶²é«”(æ··åˆ)</span>
                        <span class="text-slate-500 text-[10px]">è†¨è„¹é–¥ â” è’¸ç™¼å™¨</span>
                    </div>
                </div>

                <!-- State 4 -->
                <div class="flex items-center gap-3 text-sm bg-white p-2 rounded border border-slate-100 shadow-sm">
                    <div class="w-4 h-4 rounded-full bg-blue-500 flex-shrink-0 border-2 border-white ring-1 ring-blue-500"></div>
                    <div>
                        <span class="font-bold text-slate-800 block text-xs">ä½æº«ä½å£“æ°£é«”</span>
                        <span class="text-slate-500 text-[10px]">è’¸ç™¼å™¨ â” å£“ç¸®æ©Ÿ</span>
                    </div>
                </div>
            </div>

            <!-- Theory Box -->
            <div class="bg-blue-50 p-3 rounded-xl border border-blue-100 text-xs text-blue-800 leading-relaxed">
                <strong>ğŸ’¡ ç‰©ç†åŸç†:</strong>
                <ul class="list-disc pl-4 mt-1 space-y-1">
                    <li><span class="font-bold">è’¸ç™¼å™¨ (å¸ç†±)</span>ï¼šè£½å†·åŠ‘è’¸ç™¼ï¼Œå¸æ”¶å®¤å…§ç†±é‡ã€‚</li>
                    <li><span class="font-bold">å£“ç¸®æ©Ÿ (ä½œåŠŸ)</span>ï¼šæ°£é«”è¢«å£“ç¸®ï¼Œæº«åº¦å£“åŠ›æ€¥å‡ã€‚</li>
                    <li><span class="font-bold">å†·å‡å™¨ (æ•£ç†±)</span>ï¼šç†±é‡æ’åˆ°å®¤å¤–ï¼Œæ°£é«”å‡çµæˆæ¶²é«”ã€‚</li>
                    <li><span class="font-bold">è†¨è„¹é–¥ (é™å£“)</span>ï¼šé™åˆ¶æµé‡ï¼Œä½¿è£½å†·åŠ‘æ€¥åŠ‡é™å£“é™æº«ã€‚</li>
                </ul>
            </div>
        </div>
    </main>

    <script>
        // Configuration
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        const indoorTempDisplay = document.getElementById('indoorTempDisplay');
        const powerSlider = document.getElementById('powerSlider');
        const powerValueText = document.getElementById('powerValue');

        // Logical dimensions (for drawing coordinates)
        const LOGICAL_WIDTH = 800;
        const LOGICAL_HEIGHT = 500;

        // State
        let power = 0; 
        let roomTemp = 28.0;
        let targetRoomTemp = 28.0;
        const outdoorTemp = 32.0;
        let frameCount = 0;

        // Component Coordinates
        const components = {
            evaporator: { x: 130, y: 200, w: 140, h: 200, label: "è’¸ç™¼å™¨\nEvaporator", color: "#e0f2fe" },
            compressor: { x: 360, y: 60, w: 80, h: 80, label: "å£“ç¸®æ©Ÿ\nCompressor", color: "#334155" },
            condenser: { x: 530, y: 200, w: 140, h: 200, label: "å†·å‡å™¨\nCondenser", color: "#ffedd5" },
            expansionValve: { x: 380, y: 420, w: 40, h: 60, label: "è†¨è„¹é–¥\nExp. Valve", color: "#94a3b8" }
        };

        // Helper to generate S-shaped (serpentine) path points
        function generateSPath(startX, startY, width, height, rows, direction) {
            const points = [];
            const rowHeight = height / rows;
            const inset = 20;
            
            // direction: 'up' (bottom to top) or 'down' (top to bottom)
            // Evaporator goes UP (enters bottom, leaves top)
            // Condenser goes DOWN (enters top, leaves bottom)

            if (direction === 'up') {
                for (let i = rows - 1; i >= 0; i--) {
                    const y = startY + (i * rowHeight) + rowHeight / 2;
                    if ((rows - 1 - i) % 2 === 0) {
                        points.push({ x: startX + inset, y: y });
                        points.push({ x: startX + width - inset, y: y });
                    } else {
                        points.push({ x: startX + width - inset, y: y });
                        points.push({ x: startX + inset, y: y });
                    }
                }
            } else {
                for (let i = 0; i < rows; i++) {
                    const y = startY + (i * rowHeight) + rowHeight / 2;
                    if (i % 2 === 0) {
                        points.push({ x: startX + inset, y: y });
                        points.push({ x: startX + width - inset, y: y });
                    } else {
                        points.push({ x: startX + width - inset, y: y });
                        points.push({ x: startX + inset, y: y });
                    }
                }
            }
            return points;
        }

        // Define Pipe Paths
        // We pre-calculate these to handle the complex S-shapes
        let paths = [];

        function initPaths() {
            // 1. Evaporator Internal (Bottom to Top) -> Compressor
            const evapPoints = generateSPath(components.evaporator.x, components.evaporator.y, components.evaporator.w, components.evaporator.h, 5, 'up');
            // Add connection to Compressor
            evapPoints.push({x: components.evaporator.x + 20, y: 100}); // Up
            evapPoints.push({x: components.compressor.x, y: 100}); // Right to Comp

            const path1 = {
                points: evapPoints,
                color: "#3b82f6", // Blue
                innerColor: "#bfdbfe",
                state: "gas",
                tempBase: 5,
                width: 8
            };

            // 2. Compressor -> Condenser (Top)
            const path2 = {
                points: [
                    {x: components.compressor.x + components.compressor.w, y: 100},
                    {x: components.condenser.x + 20, y: 100},
                    {x: components.condenser.x + 20, y: components.condenser.y + 20}
                ],
                color: "#ef4444", // Red
                innerColor: "#fecaca",
                state: "gas",
                tempBase: 85,
                width: 8
            };

            // 3. Condenser Internal (Top to Bottom) -> Expansion Valve
            const condPoints = generateSPath(components.condenser.x, components.condenser.y, components.condenser.w, components.condenser.h, 5, 'down');
            // Add connection to Valve
            // Last point of condPoints is bottom right or left
            const lastCond = condPoints[condPoints.length-1];
            condPoints.push({x: lastCond.x, y: 450}); // Down
            condPoints.push({x: components.expansionValve.x + components.expansionValve.w, y: 450}); // Left to Valve

            const path3 = {
                points: condPoints,
                color: "#f97316", // Orange
                innerColor: "#fed7aa",
                state: "liquid",
                tempBase: 45,
                width: 8
            };

            // 4. Expansion Valve -> Evaporator (Bottom)
            const path4 = {
                points: [
                    {x: components.expansionValve.x, y: 450},
                    {x: components.evaporator.x + 20, y: 450},
                    {x: components.evaporator.x + 20, y: components.evaporator.y + components.evaporator.h - 20} // Connect to start of S-coil
                ],
                color: "#22d3ee", // Cyan
                innerColor: "#cffafe",
                state: "mix",
                tempBase: 2,
                width: 8
            };

            paths = [path1, path2, path3, path4];
            
            // Calculate path lengths for constant speed animation
            paths.forEach(p => {
                let len = 0;
                for(let i=0; i<p.points.length-1; i++) {
                    const dx = p.points[i+1].x - p.points[i].x;
                    const dy = p.points[i+1].y - p.points[i].y;
                    len += Math.sqrt(dx*dx + dy*dy);
                }
                p.totalLength = len;
            });
        }

        const particles = [];
        const maxParticles = 120;

        function init() {
            resizeCanvas();
            initPaths();
            
            // Create Particles
            for(let i=0; i<maxParticles; i++) {
                particles.push({
                    pathIdx: Math.floor(Math.random() * 4),
                    distance: Math.random() * 100, // random start distance
                });
            }
            
            window.addEventListener('resize', resizeCanvas);
            animate();
        }

        function resizeCanvas() {
            // Handle High DPI (Retina)
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.parentElement.getBoundingClientRect();
            
            canvas.width = LOGICAL_WIDTH * dpr;
            canvas.height = LOGICAL_HEIGHT * dpr;
            
            canvas.style.width = "100%";
            canvas.style.height = "auto";
            canvas.style.maxWidth = LOGICAL_WIDTH + "px";
            
            ctx.scale(dpr, dpr);
            
            // Scale coordinates if container is smaller than logical width (Responsive)
            // Simplification: We draw to logical size, then CSS handles fit. 
            // But canvas scale is strictly for DPI here.
            // To fit smaller screens, we rely on CSS width:100% and viewBox concept.
            // Actually, for simple canvas, scaling the context to match the visual ratio is tricky.
            // Let's keep logical 800x500 and assume standard desktop/tablet view.
            // If we want true responsive scaling of content:
            const scaleX = rect.width / LOGICAL_WIDTH;
            // But we want to keep aspect ratio. CSS handles layout. 
            // The canvas internal pixels are set.
        }

        function drawPipePath(path) {
            if (path.points.length < 2) return;

            ctx.lineCap = "round";
            ctx.lineJoin = "round";

            // 1. Outer Stroke (Pipe Wall)
            ctx.beginPath();
            ctx.moveTo(path.points[0].x, path.points[0].y);
            for(let i=1; i<path.points.length; i++) {
                // Simple Lineto for now, can be curved but Lineto is clearer for S-bends
                ctx.lineTo(path.points[i].x, path.points[i].y);
            }
            ctx.strokeStyle = "#475569"; // Dark slate
            ctx.lineWidth = path.width + 2; // Border
            ctx.stroke();

            // 2. Inner Fill (Fluid Color)
            ctx.beginPath();
            ctx.moveTo(path.points[0].x, path.points[0].y);
            for(let i=1; i<path.points.length; i++) {
                ctx.lineTo(path.points[i].x, path.points[i].y);
            }
            ctx.strokeStyle = path.innerColor; 
            ctx.lineWidth = path.width;
            ctx.stroke();

            // 3. Highlight (Shiny tube effect)
            ctx.beginPath();
            ctx.moveTo(path.points[0].x, path.points[0].y);
            for(let i=1; i<path.points.length; i++) {
                ctx.lineTo(path.points[i].x, path.points[i].y);
            }
            ctx.strokeStyle = "rgba(255,255,255,0.4)"; 
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function drawComponents() {
            ctx.font = "bold 14px 'Noto Sans TC', sans-serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            // Draw Compressor Box
            const comp = components.compressor;
            ctx.fillStyle = comp.color;
            ctx.beginPath();
            ctx.arc(comp.x + comp.w/2, comp.y + comp.h/2, 40, 0, Math.PI*2);
            ctx.fill();
            ctx.lineWidth = 3;
            ctx.strokeStyle = "#1e293b";
            ctx.stroke();
            
            ctx.fillStyle = "#fff";
            ctx.fillText("å£“ç¸®æ©Ÿ", comp.x + comp.w/2, comp.y + comp.h/2 - 8);
            ctx.font = "10px sans-serif";
            ctx.fillText("(Work)", comp.x + comp.w/2, comp.y + comp.h/2 + 8);


            // Draw Expansion Valve
            const valve = components.expansionValve;
            ctx.fillStyle = valve.color;
            ctx.strokeStyle = "#475569";
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            // Bowtie shape
            ctx.moveTo(valve.x, valve.y); 
            ctx.lineTo(valve.x + valve.w, valve.y);
            ctx.lineTo(valve.x, valve.y + valve.h);
            ctx.lineTo(valve.x + valve.w, valve.y + valve.h);
            ctx.lineTo(valve.x, valve.y);
            ctx.fill();
            ctx.stroke();
            
            ctx.fillStyle = "#1e293b";
            ctx.font = "bold 12px 'Noto Sans TC'";
            ctx.fillText("è†¨è„¹é–¥", valve.x + valve.w/2, valve.y + valve.h + 15);

            // Labels for Heat Exchangers (Background boxes are implicit or drawn lightly)
            // Evaporator Area
            const evap = components.evaporator;
            ctx.fillStyle = "rgba(224, 242, 254, 0.5)";
            ctx.roundRect(evap.x - 10, evap.y - 10, evap.w + 20, evap.h + 20, 10);
            ctx.fill();
            ctx.fillStyle = "#0369a1";
            ctx.font = "bold 16px 'Noto Sans TC'";
            ctx.fillText("è’¸ç™¼å™¨ (å¸ç†±)", evap.x + evap.w/2, evap.y - 25);

            // Condenser Area
            const cond = components.condenser;
            ctx.fillStyle = "rgba(255, 237, 213, 0.5)";
            ctx.roundRect(cond.x - 10, cond.y - 10, cond.w + 20, cond.h + 20, 10);
            ctx.fill();
            ctx.fillStyle = "#c2410c";
            ctx.fillText("å†·å‡å™¨ (æ•£ç†±)", cond.x + cond.w/2, cond.y - 25);

            // Heat Transfer Effects
            if (power > 0) {
                // Cold Air (Blue Arrows out of Evap)
                ctx.fillStyle = `rgba(59, 130, 246, ${power/100})`;
                ctx.font = "24px sans-serif";
                ctx.fillText("â„ï¸", evap.x - 30, evap.y + evap.h/2);
                ctx.font = "14px sans-serif";
                ctx.fillText("å†·é¢¨", evap.x - 30, evap.y + evap.h/2 + 20);

                // Hot Air (Red Arrows out of Cond)
                ctx.fillStyle = `rgba(239, 68, 68, ${power/100})`;
                ctx.font = "24px sans-serif";
                ctx.fillText("â™¨ï¸", cond.x + cond.w + 30, cond.y + cond.h/2);
                ctx.font = "14px sans-serif";
                ctx.fillText("ç†±é¢¨", cond.x + cond.w + 30, cond.y + cond.h/2 + 20);
            }
        }

        function drawParticles() {
            particles.forEach(p => {
                const path = paths[p.pathIdx];
                
                // Normalize distance to progress (0 to 1)
                let progress = p.distance / path.totalLength;
                
                if (progress >= 1) {
                    // Move to next path
                    p.pathIdx = (p.pathIdx + 1) % 4;
                    p.distance = 0;
                    progress = 0;
                }

                // Find coordinates
                // We need to walk the segments to find where 'distance' falls
                let currentDist = 0;
                let targetX = 0, targetY = 0;

                for(let i=0; i<path.points.length-1; i++) {
                    const p1 = path.points[i];
                    const p2 = path.points[i+1];
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const segLen = Math.sqrt(dx*dx + dy*dy);

                    if (currentDist + segLen >= p.distance) {
                        // Particle is in this segment
                        const segProg = (p.distance - currentDist) / segLen;
                        targetX = p1.x + dx * segProg;
                        targetY = p1.y + dy * segProg;
                        break;
                    }
                    currentDist += segLen;
                }

                // Draw Particle
                ctx.fillStyle = path.color;
                let radius = 3;
                
                // State styles
                if (path.state === 'gas') {
                    ctx.globalAlpha = 0.7;
                    radius = 4;
                    // Slight jitter
                    targetX += (Math.random()-0.5)*2;
                    targetY += (Math.random()-0.5)*2;
                } else {
                    ctx.globalAlpha = 1.0;
                    radius = 3;
                }

                ctx.beginPath();
                ctx.arc(targetX, targetY, radius, 0, Math.PI*2);
                ctx.fill();
                ctx.globalAlpha = 1;

                // Move
                if (power > 0) {
                    const speed = 1.5 + (power/100) * 2.5; // Pixels per frame
                    p.distance += speed;
                }
            });
        }

        function drawFloatLabels() {
             // Draw Pipe Readings (Temperature)
             paths.forEach((path, idx) => {
                // Pick a representative point (middle of total length roughly)
                let sampleDist = path.totalLength / 2;
                let currentDist = 0;
                let labelX = 0, labelY = 0;

                // Find coords for label
                for(let i=0; i<path.points.length-1; i++) {
                    const p1 = path.points[i];
                    const p2 = path.points[i+1];
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const segLen = Math.sqrt(dx*dx + dy*dy);

                    if (currentDist + segLen >= sampleDist) {
                        labelX = p1.x + dx * 0.5;
                        labelY = p1.y + dy * 0.5;
                        break;
                    }
                    currentDist += segLen;
                }

                // Adjust label position slightly off pipe
                if (idx === 0) { labelX -= 40; labelY += 0; } // Evap internal
                if (idx === 2) { labelX += 40; labelY += 0; } // Cond internal
                if (idx === 1) { labelY -= 20; } // Top pipe
                if (idx === 3) { labelY += 25; } // Bottom pipe

                // Temp Calc
                let displayTemp = path.tempBase;
                if (power > 0) {
                    if (idx === 1) displayTemp += (power/100) * 15; 
                    if (idx === 3) displayTemp -= (power/100) * 5;  
                }

                // Draw Bubble
                ctx.font = "bold 12px Arial";
                const text = displayTemp.toFixed(1) + "Â°C";
                const textW = ctx.measureText(text).width;
                
                ctx.fillStyle = "rgba(255,255,255,0.9)";
                ctx.strokeStyle = path.color;
                ctx.lineWidth = 1;
                
                ctx.beginPath();
                ctx.roundRect(labelX - textW/2 - 4, labelY - 10, textW + 8, 20, 4);
                ctx.fill();
                ctx.stroke();

                ctx.fillStyle = "#0f172a";
                ctx.fillText(text, labelX, labelY);
            });
        }

        function updatePhysics() {
            let target = 0;
            let rate = 0.0;

            if (power > 0) {
                const coolingPotential = (power / 100) * (outdoorTemp - 16);
                target = outdoorTemp - coolingPotential;
                rate = 0.05; 
            } else {
                target = outdoorTemp;
                rate = 0.02;
            }

            const diff = target - roomTemp;
            if (Math.abs(diff) > 0.1) {
                roomTemp += diff * rate * 0.1;
            }
            indoorTempDisplay.innerText = roomTemp.toFixed(1) + "Â°C";
        }

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear scaled context
            
            // Draw Pipes (Bottom Layer)
            paths.forEach(drawPipePath);
            
            // Draw Components (Middle Layer)
            drawComponents();

            // Draw Particles (Top Layer)
            drawParticles();

            // Draw Text Overlays
            drawFloatLabels();
            
            if (frameCount % 10 === 0) {
                updatePhysics();
            }

            frameCount++;
            requestAnimationFrame(animate);
        }

        // Event Listeners
        powerSlider.addEventListener('input', (e) => {
            power = parseInt(e.target.value);
            powerValueText.innerText = power + "%";
            
            if(power === 0) {
                powerValueText.className = "text-slate-400";
            } else if (power < 50) {
                powerValueText.className = "text-blue-500";
            } else {
                powerValueText.className = "text-blue-700 font-bold";
            }
        });

        // Fix RoundRect for older browsers just in case
        if (!ctx.roundRect) {
            ctx.roundRect = function(x, y, w, h, r) {
                this.beginPath();
                this.moveTo(x + r, y);
                this.lineTo(x + w - r, y);
                this.quadraticCurveTo(x + w, y, x + w, y + r);
                this.lineTo(x + w, y + h - r);
                this.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                this.lineTo(x + r, y + h);
                this.quadraticCurveTo(x, y + h, x, y + h - r);
                this.lineTo(x, y + r);
                this.quadraticCurveTo(x, y, x + r, y);
                this.closePath();
            };
        }

        init();

    </script>
</body>
</html>