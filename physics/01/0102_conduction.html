<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>固體熱傳導物理模擬</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #0f172a; /* Slate 900 */
            color: #e2e8f0;
            overflow: hidden; /* Prevent scrolling on mobile */
            touch-action: none;
        }
        canvas {
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border-radius: 8px;
            cursor: crosshair;
        }
        .controls {
            background: rgba(30, 41, 59, 0.9);
            backdrop-filter: blur(4px);
        }
    </style>
</head>
<body class="flex flex-col h-screen items-center justify-center font-sans">

    <!-- Header / Instructions -->
    <div class="absolute top-4 left-4 z-10 pointer-events-none">
        <h1 class="text-2xl font-bold text-blue-400 mb-1">固體熱傳導模擬</h1>
        <p class="text-sm text-slate-400 max-w-md">
            模擬粒子在固體晶格中的振動與能量傳遞。<br>
            <span class="text-yellow-400">操作：</span> 點擊並拖曳滑鼠（或手指）來加熱粒子。
        </p>
    </div>

    <!-- Main Canvas -->
    <canvas id="simCanvas" class="bg-slate-800 border border-slate-700"></canvas>

    <!-- Legend -->
    <div class="absolute top-4 right-4 bg-slate-800 p-3 rounded-lg border border-slate-700 shadow-lg flex flex-col gap-2">
        <span class="text-xs text-center font-bold text-slate-300">溫度 (動能)</span>
        <div class="h-32 w-4 rounded-full bg-gradient-to-t from-blue-600 via-green-500 via-yellow-500 to-red-600 mx-auto relative"></div>
        <div class="flex justify-between text-[10px] text-slate-400 px-1">
            <span>冷</span>
            <span>熱</span>
        </div>
    </div>

    <!-- Controls -->
    <div class="controls fixed bottom-6 p-4 rounded-xl border border-slate-600 flex flex-wrap gap-4 items-center justify-center shadow-2xl z-20 w-[90%] max-w-2xl">
        
        <div class="flex flex-col items-center">
            <label class="text-xs text-slate-400 mb-1">熱源強度</label>
            <input type="range" id="heatPower" min="1" max="10" value="5" class="w-24 accent-red-500">
        </div>

        <div class="flex flex-col items-center">
            <label class="text-xs text-slate-400 mb-1">固體剛性 (彈簧係數)</label>
            <input type="range" id="stiffness" min="0.01" max="0.2" step="0.01" value="0.05" class="w-24 accent-blue-500">
        </div>

        <div class="h-8 w-px bg-slate-600 mx-2"></div>

        <button id="btnReset" class="px-4 py-2 bg-slate-700 hover:bg-slate-600 text-white rounded transition shadow border border-slate-500">
            重置系統
        </button>
        
        <button id="btnCool" class="px-4 py-2 bg-blue-600 hover:bg-blue-500 text-white rounded transition shadow border border-blue-400">
            快速冷卻
        </button>
    </div>

<script>
/**
 * Physics Simulation Logic
 * Model: Mass-Spring-Damper System (Lattice)
 */

const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');

// Simulation Parameters
let COLUMNS = 25;
let ROWS = 15;
let SPACING = 30;
let DAMPING = 0.98; // Energy loss over time
let STIFFNESS = 0.05; // Hooke's law constant
let HEAT_POWER = 5;

// State
let particles = [];
let springs = [];
let isDragging = false;
let mouseX = 0;
let mouseY = 0;
let animationId;

// UI Elements
const heatSlider = document.getElementById('heatPower');
const stiffnessSlider = document.getElementById('stiffness');
const btnReset = document.getElementById('btnReset');
const btnCool = document.getElementById('btnCool');

// Particle Class
class Particle {
    constructor(x, y, isPinned = false) {
        this.ox = x; // Original X (Equilibrium)
        this.oy = y; // Original Y (Equilibrium)
        this.x = x;  // Current X
        this.y = y;  // Current Y
        this.vx = 0; // Velocity X
        this.vy = 0; // Velocity Y
        this.fx = 0; // Force Accumulator X
        this.fy = 0; // Force Accumulator Y
        this.isPinned = isPinned; // Edges are pinned to keep the solid in place
        this.mass = 1;
        this.kineticEnergy = 0;
    }

    update() {
        if (this.isPinned) return;

        // Verlet Integration / Euler roughly
        this.vx += this.fx / this.mass;
        this.vy += this.fy / this.mass;

        // Apply Damping (Resistance)
        this.vx *= DAMPING;
        this.vy *= DAMPING;

        this.x += this.vx;
        this.y += this.vy;

        // Calculate Kinetic Energy (for color) - proportional to v^2
        const speedSq = this.vx * this.vx + this.vy * this.vy;
        // Smooth average for display stability
        this.kineticEnergy = this.kineticEnergy * 0.9 + speedSq * 0.1;

        // Reset forces
        this.fx = 0;
        this.fy = 0;
    }

    draw() {
        // Map energy to color
        // 0 -> Blue (240), High -> Red (0)
        // Normalize energy: Assuming max reasonable speed squared is around 20-50
        let heat = Math.min(this.kineticEnergy / 15, 1); 
        
        // Color interpolation HSL
        // Blue (240) -> Cyan (180) -> Green (120) -> Yellow (60) -> Red (0)
        const hue = 240 - (heat * 240);
        const lightness = 50 + (heat * 20); // Get brighter as it gets hotter

        ctx.beginPath();
        ctx.arc(this.x, this.y, SPACING * 0.35, 0, Math.PI * 2);
        ctx.fillStyle = `hsl(${hue}, 100%, ${lightness}%)`;
        ctx.fill();
        
        // High heat glow
        if (heat > 0.8) {
            ctx.shadowBlur = 10;
            ctx.shadowColor = 'red';
        } else {
            ctx.shadowBlur = 0;
        }
    }
}

// Spring Class
class Spring {
    constructor(p1, p2) {
        this.p1 = p1;
        this.p2 = p2;
        // Calculate resting distance
        const dx = p2.ox - p1.ox;
        const dy = p2.oy - p1.oy;
        this.restLength = Math.sqrt(dx * dx + dy * dy);
    }

    update() {
        const dx = this.p2.x - this.p1.x;
        const dy = this.p2.y - this.p1.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Hooke's Law: F = k * (currentLength - restLength)
        const forceMagnitude = (distance - this.restLength) * STIFFNESS;
        
        // Direction unit vector
        const nx = dx / distance;
        const ny = dy / distance;

        const fx = nx * forceMagnitude;
        const fy = ny * forceMagnitude;

        // Apply forces to particles (Newton's 3rd Law)
        if (!this.p1.isPinned) {
            this.p1.fx += fx;
            this.p1.fy += fy;
        }
        if (!this.p2.isPinned) {
            this.p2.fx -= fx;
            this.p2.fy -= fy;
        }
    }

    draw() {
        // Color spring based on tension/average temp of connected particles
        const avgEnergy = (this.p1.kineticEnergy + this.p2.kineticEnergy) / 2;
        const alpha = Math.min(0.2 + avgEnergy * 0.1, 0.8); // More visible when energetic

        ctx.beginPath();
        ctx.moveTo(this.p1.x, this.p1.y);
        ctx.lineTo(this.p2.x, this.p2.y);
        ctx.strokeStyle = `rgba(200, 200, 200, ${alpha})`;
        ctx.lineWidth = 1;
        ctx.stroke();
    }
}

// Initialization
function init() {
    resizeCanvas();
    createGrid();
    loop();
}

function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    // Recalculate grid fit
    SPACING = Math.min(canvas.width / (COLUMNS + 2), canvas.height / (ROWS + 2));
    if (SPACING > 40) SPACING = 40;
    if (SPACING < 15) SPACING = 15;
}

function createGrid() {
    particles = [];
    springs = [];

    const startX = (canvas.width - (COLUMNS - 1) * SPACING) / 2;
    const startY = (canvas.height - (ROWS - 1) * SPACING) / 2;

    // 1. Create Particles
    for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLUMNS; x++) {
            const px = startX + x * SPACING;
            const py = startY + y * SPACING;
            
            // Pin the edges to hold the sheet in place
            // const isPinned = x === 0 || x === COLUMNS - 1 || y === 0 || y === ROWS - 1;
            // Only pin corners to allow more flex? Or borders? Let's pin borders for a stable solid.
            const isPinned = (x === 0 || x === COLUMNS - 1 || y === 0 || y === ROWS - 1);
            
            particles.push(new Particle(px, py, isPinned));
        }
    }

    // 2. Create Springs (Connections)
    for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLUMNS; x++) {
            const i = y * COLUMNS + x;
            
            // Connect Right
            if (x < COLUMNS - 1) {
                springs.push(new Spring(particles[i], particles[i + 1]));
            }
            // Connect Down
            if (y < ROWS - 1) {
                springs.push(new Spring(particles[i], particles[i + COLUMNS]));
            }
            // Structural diagonal springs (makes it a solid rather than a net)
            if (x < COLUMNS - 1 && y < ROWS - 1) {
                springs.push(new Spring(particles[i], particles[i + COLUMNS + 1]));
                springs.push(new Spring(particles[i + 1], particles[i + COLUMNS]));
            }
        }
    }
}

// Interaction Logic
function applyHeatAtMouse() {
    if (!isDragging) return;

    const influenceRadius = SPACING * 2.5;
    const influenceRadiusSq = influenceRadius * influenceRadius;

    particles.forEach(p => {
        if (p.isPinned) return;

        const dx = p.x - mouseX;
        const dy = p.y - mouseY;
        const distSq = dx * dx + dy * dy;

        if (distSq < influenceRadiusSq) {
            // Add random kinetic energy (Heat)
            // Random direction
            const angle = Math.random() * Math.PI * 2;
            const force = HEAT_POWER * Math.random();
            
            p.vx += Math.cos(angle) * force;
            p.vy += Math.sin(angle) * force;
        }
    });
}

// Animation Loop
function loop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // 1. Apply User Heat
    applyHeatAtMouse();

    // 2. Physics Update
    // Apply Spring Forces
    springs.forEach(s => s.update());
    
    // Update Particles (apply accumulated forces)
    particles.forEach(p => p.update());

    // 3. Render
    springs.forEach(s => s.draw());
    particles.forEach(p => p.draw());

    animationId = requestAnimationFrame(loop);
}

// Event Listeners
window.addEventListener('resize', () => {
    resizeCanvas();
    createGrid(); // Re-create to fit new screen
});

canvas.addEventListener('mousedown', (e) => {
    isDragging = true;
    mouseX = e.clientX;
    mouseY = e.clientY;
});

canvas.addEventListener('mousemove', (e) => {
    mouseX = e.clientX;
    mouseY = e.clientY;
});

window.addEventListener('mouseup', () => {
    isDragging = false;
});

// Touch support
canvas.addEventListener('touchstart', (e) => {
    isDragging = true;
    const touch = e.touches[0];
    mouseX = touch.clientX;
    mouseY = touch.clientY;
    e.preventDefault(); // Prevent scroll
}, {passive: false});

canvas.addEventListener('touchmove', (e) => {
    const touch = e.touches[0];
    mouseX = touch.clientX;
    mouseY = touch.clientY;
    e.preventDefault();
}, {passive: false});

window.addEventListener('touchend', () => {
    isDragging = false;
});

// UI Control Listeners
heatSlider.addEventListener('input', (e) => {
    HEAT_POWER = parseFloat(e.target.value);
});

stiffnessSlider.addEventListener('input', (e) => {
    STIFFNESS = parseFloat(e.target.value);
});

btnReset.addEventListener('click', () => {
    createGrid();
});

btnCool.addEventListener('click', () => {
    particles.forEach(p => {
        p.vx *= 0.1;
        p.vy *= 0.1;
    });
});

// Start
init();

</script>
</body>
</html>