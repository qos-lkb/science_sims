<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>熱傳遞：對流模擬 (Convection Simulation)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700&display=swap');
        body {
            font-family: 'Noto Sans TC', sans-serif;
            background-color: #f3f4f6;
            touch-action: manipulation;
        }
        canvas {
            touch-action: none;
            background: radial-gradient(circle at 50% 50%, #ffffff 0%, #e6e6e6 100%);
            box-shadow: inset 0 0 20px rgba(0,0,0,0.1);
            border-radius: 16px;
        }
        .slider-thumb::-webkit-slider-thumb {
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #ef4444;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center justify-center p-4">

    <!-- Header -->
    <header class="text-center mb-6 w-full max-w-2xl">
        <h1 class="text-2xl md:text-3xl font-bold text-gray-800 mb-2">♨️ 水煲中的熱對流模擬</h1>
        <p class="text-gray-600 text-sm md:text-base">觀察中央加熱後，熱水上升與冷水下降形成的循環路徑。</p>
    </header>

    <!-- Main Simulation Container -->
    <div class="bg-white p-4 rounded-2xl shadow-xl w-full max-w-2xl border border-gray-200">
        
        <!-- Stats & Legend -->
        <div class="flex justify-between items-center mb-4 text-xs md:text-sm text-gray-600 font-medium">
            <div class="flex items-center gap-2">
                <span class="w-3 h-3 rounded-full bg-blue-600 inline-block"></span> 冷 (25°C)
            </div>
            <div class="flex items-center gap-2">
                <span class="w-3 h-3 rounded-full bg-purple-500 inline-block"></span> 溫 (60°C)
            </div>
            <div class="flex items-center gap-2">
                <span class="w-3 h-3 rounded-full bg-red-600 inline-block"></span> 熱 (100°C)
            </div>
        </div>

        <!-- Canvas Wrapper -->
        <div class="relative w-full flex justify-center">
            <canvas id="simCanvas" class="w-full border border-gray-300"></canvas>
            
            <!-- Overlay Labels -->
            <div class="absolute bottom-4 left-1/2 transform -translate-x-1/2 bg-black/70 text-white px-3 py-1 rounded-full text-xs pointer-events-none whitespace-nowrap">
                中央加熱元件 (Central Heating)
            </div>
        </div>

        <!-- Controls -->
        <div class="mt-6 bg-gray-50 p-4 rounded-xl border border-gray-200">
            <div class="flex flex-col gap-4">
                
                <!-- Power Control -->
                <div>
                    <div class="flex justify-between items-center mb-2">
                        <label for="powerSlider" class="font-bold text-gray-700 flex items-center gap-2">
                            ⚡ 電功率 (Power)
                        </label>
                        <span id="powerValue" class="text-red-600 font-mono font-bold text-lg">0 W</span>
                    </div>
                    <input type="range" id="powerSlider" min="0" max="2000" value="0" step="100" 
                           class="slider-thumb w-full h-3 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                    <div class="flex justify-between text-xs text-gray-400 mt-1">
                        <span>關閉</span>
                        <span>最大火力</span>
                    </div>
                </div>

                <!-- Checkbox for flow lines -->
                <div class="flex items-center gap-2">
                    <input type="checkbox" id="showLines" checked class="w-4 h-4 text-blue-600 rounded focus:ring-blue-500">
                    <label for="showLines" class="text-sm text-gray-700 select-none cursor-pointer">顯示對流路徑 (Flow Paths)</label>
                </div>

                <!-- Info Stats -->
                <div class="grid grid-cols-2 gap-4 mt-2">
                    <div class="bg-white p-3 rounded-lg shadow-sm border border-gray-100 text-center">
                        <div class="text-xs text-gray-500 mb-1">平均水溫</div>
                        <div id="avgTemp" class="text-xl font-bold text-gray-800">25°C</div>
                    </div>
                    <div class="bg-white p-3 rounded-lg shadow-sm border border-gray-100 text-center">
                        <div class="text-xs text-gray-500 mb-1">對流狀態</div>
                        <div id="stateText" class="text-lg font-bold text-blue-600">靜止</div>
                    </div>
                </div>

                <!-- Reset Button -->
                <button id="resetBtn" class="w-full mt-2 bg-gray-800 hover:bg-gray-900 text-white font-bold py-2 px-4 rounded-lg transition-colors flex items-center justify-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                        <path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/>
                        <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/>
                    </svg>
                    重置模擬
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- Configuration ---
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        const powerSlider = document.getElementById('powerSlider');
        const powerValueDisplay = document.getElementById('powerValue');
        const avgTempDisplay = document.getElementById('avgTemp');
        const stateTextDisplay = document.getElementById('stateText');
        const resetBtn = document.getElementById('resetBtn');
        const showLinesCheckbox = document.getElementById('showLines');

        // Physics Constants
        let POWER = 0; // Watts
        const PARTICLE_COUNT = 400;
        const ROOM_TEMP = 25;
        const BOILING_POINT = 100;
        const KETTLE_WIDTH_RATIO = 0.7;
        const KETTLE_HEIGHT_RATIO = 0.8;
        
        // Simulation State
        let particles = [];
        let bubbles = [];
        let frameId;
        let width, height;
        let kettleBounds = {};
        let centerAxisX = 0;
        
        // Smoothing for display value
        let displayAvgTemp = ROOM_TEMP; 

        // --- Classes ---

        class Particle {
            constructor() {
                this.reset(true);
            }

            reset(randomY = false) {
                // Initial position
                this.x = kettleBounds.x + Math.random() * kettleBounds.w;
                this.y = randomY 
                    ? kettleBounds.y + Math.random() * kettleBounds.h 
                    : kettleBounds.y + kettleBounds.h - 10; 
                
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = (Math.random() - 0.5) * 0.5;
                this.temp = ROOM_TEMP + (Math.random() * 5);
                this.radius = 2 + Math.random() * 2;
            }

            update() {
                const kBottom = kettleBounds.y + kettleBounds.h;
                const kTop = kettleBounds.y;
                const kLeft = kettleBounds.x;
                const kRight = kettleBounds.x + kettleBounds.w;
                const distToCenter = this.x - centerAxisX;
                
                // 1. Heat Source (Centralized at bottom)
                const isAboveHeater = Math.abs(distToCenter) < kettleBounds.w * 0.2;
                const isAtBottom = (kBottom - this.y) < 40;

                if (isAboveHeater && isAtBottom) {
                    // Heat gain
                    const heatGain = (POWER / 2000) * 2.0; 
                    this.temp += heatGain;
                }

                // 2. Cooling Logic
                const isAtSurface = (this.y - kTop) < 20;
                if (isAtSurface) {
                    // Slight surface evaporation cooling
                    this.temp -= 0.05; 
                }
                
                // General Ambient cooling (very slow)
                if (this.temp > ROOM_TEMP) {
                    this.temp -= 0.005; 
                }

                // Clamp Temp
                if (this.temp > BOILING_POINT + 5) this.temp = BOILING_POINT + 5;
                if (this.temp < ROOM_TEMP) this.temp = ROOM_TEMP;

                // 3. Flow Field / Forces
                // A. Buoyancy (MODIFIED: Reduced speed)
                // Reduced coefficient from -0.006 to -0.0025
                let buoyancy = (this.temp - displayAvgTemp) * -0.0025;
                // Reduced extra boost from -0.02 to -0.005
                if (this.temp > displayAvgTemp + 5) buoyancy -= 0.005;
                this.vy += buoyancy;

                // B. Convection Current Guidance (Force Field)
                if (POWER > 100) {
                    const flowStrength = (POWER / 2000) * 0.12; 

                    // Horizontal Flow Logic
                    // MODIFIED: Increased range (0.25 -> 0.35) to make them turn earlier/lower
                    if (this.y < kTop + kettleBounds.h * 0.35) {
                        // Top region: PUSH OUTWARD
                        if (distToCenter > 0) this.vx += flowStrength; 
                        else this.vx -= flowStrength;
                        
                        // Add slight downward pressure near top to prevent sticking to ceiling
                        if (this.y < kTop + kettleBounds.h * 0.1) {
                             this.vy += flowStrength * 0.2;
                        }
                    } else if (this.y > kBottom - kettleBounds.h * 0.2) {
                        // Bottom region: SUCK INWARD
                        if (distToCenter > 0) this.vx -= flowStrength; 
                        else this.vx += flowStrength; 
                    }

                    // Vertical Flow Logic
                    if (Math.abs(distToCenter) < kettleBounds.w * 0.25) {
                        // Center: Encourage UP (Reduced strength 0.4 -> 0.2)
                        this.vy -= flowStrength * 0.2;
                    } else if (Math.abs(distToCenter) > kettleBounds.w * 0.35) {
                        // Sides: Encourage DOWN
                        this.vy += flowStrength * 0.4;
                    }
                }

                // C. Random Turbulence
                const energy = this.temp / 100;
                this.vx += (Math.random() - 0.5) * energy * 0.4;
                this.vy += (Math.random() - 0.5) * energy * 0.2;

                // D. Damping
                this.vx *= 0.96;
                this.vy *= 0.96;

                // 4. Update Position
                this.x += this.vx;
                this.y += this.vy;

                // 5. Boiling (Bubbles)
                if (this.temp >= 98 && Math.abs(distToCenter) < kettleBounds.w * 0.3 && Math.random() < (POWER/100000)) {
                    createBubble(this.x, this.y);
                }

                // 6. Boundaries
                if (this.x < kLeft) { this.x = kLeft; this.vx *= -0.5; }
                if (this.x > kRight) { this.x = kRight; this.vx *= -0.5; }
                if (this.y > kBottom) { this.y = kBottom; this.vy *= -0.5; }
                if (this.y < kTop) {
                    this.y = kTop;
                    this.vy = Math.abs(this.vy) * 0.1;
                    // Horizontal spread at surface
                    if (this.temp > 60) {
                        this.vx += (this.x < centerAxisX ? -1 : 1) * 0.5; // Reduced spread force
                    }
                }
            }

            draw() {
                let t = (this.temp - ROOM_TEMP) / (BOILING_POINT - ROOM_TEMP);
                t = Math.max(0, Math.min(1, t));
                
                let hue;
                if (t < 0.3) {
                    hue = 240 - (t / 0.3) * 40;
                } else if (t < 0.7) {
                    hue = 200 - ((t - 0.3) / 0.4) * 160;
                } else {
                    hue = 40 - ((t - 0.7) / 0.3) * 40;
                }
                
                const sat = 80 + (t * 20) + '%';
                const light = 55 + (t * 10) + '%';
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = `hsla(${hue}, ${sat}, ${light}, 0.7)`;
                ctx.fill();
            }
        }

        class Bubble {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = -2 - Math.random() * 2;
                this.radius = 1 + Math.random() * 3;
                this.active = true;
            }

            update() {
                this.y += this.vy;
                this.x += this.vx;
                this.radius += 0.05;
                this.x += Math.sin(this.y * 0.1) * 0.5; // Wobble

                if (this.y < kettleBounds.y) {
                    this.active = false;
                }
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.fill();
            }
        }

        function createBubble(x, y) {
            bubbles.push(new Bubble(x, y));
        }

        // --- Initialization ---

        function resize() {
            const parent = canvas.parentElement;
            canvas.width = parent.clientWidth;
            canvas.height = Math.min(500, parent.clientWidth * 0.8); 
            
            width = canvas.width;
            height = canvas.height;

            const kw = width * KETTLE_WIDTH_RATIO;
            const kh = height * KETTLE_HEIGHT_RATIO;
            kettleBounds = {
                x: (width - kw) / 2,
                y: (height - kh) / 2 + 20,
                w: kw,
                h: kh
            };
            centerAxisX = width / 2;
        }

        function initParticles() {
            particles = [];
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                particles.push(new Particle());
            }
            bubbles = [];
        }

        // --- Visuals ---

        function drawKettle() {
            ctx.save();
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.strokeStyle = '#374151';

            const kx = kettleBounds.x;
            const ky = kettleBounds.y;
            const kw = kettleBounds.w;
            const kh = kettleBounds.h;

            // Glass Body
            ctx.beginPath();
            ctx.moveTo(kx, ky);
            ctx.lineTo(kx + kw, ky);
            ctx.bezierCurveTo(kx + kw + 20, ky + kh/2, kx + kw, ky + kh, kx + kw - 20, ky + kh);
            ctx.lineTo(kx + 20, ky + kh);
            ctx.bezierCurveTo(kx, ky + kh, kx - 20, ky + kh/2, kx, ky);
            ctx.stroke();

            // Handle
            ctx.beginPath();
            ctx.moveTo(kx + kw + 5, ky + kh * 0.2);
            ctx.bezierCurveTo(kx + kw + 60, ky + kh * 0.2, kx + kw + 60, ky + kh * 0.8, kx + kw + 5, ky + kh * 0.8);
            ctx.lineWidth = 8;
            ctx.strokeStyle = '#1f2937';
            ctx.stroke();
            ctx.lineWidth = 4;
            ctx.strokeStyle = '#4b5563';
            ctx.stroke();
            
            ctx.restore();
        }

        function drawCentralHeater() {
            const kx = kettleBounds.x;
            const ky = kettleBounds.y;
            const kw = kettleBounds.w;
            const kh = kettleBounds.h;
            
            const heaterWidth = kw * 0.3;
            const heaterX = centerAxisX - heaterWidth/2;
            const heaterY = ky + kh - 15;

            ctx.save();
            const glowIntensity = POWER / 2000;
            const r = 80 + (175 * glowIntensity);
            const g = 80 * (1 - glowIntensity);
            const b = 80 * (1 - glowIntensity);
            const color = `rgb(${r},${g},${b})`;

            ctx.fillStyle = '#4b5563';
            ctx.fillRect(heaterX, heaterY, heaterWidth, 10);

            ctx.strokeStyle = color;
            ctx.lineWidth = 6;
            ctx.lineCap = 'round';
            ctx.shadowBlur = POWER > 0 ? 15 : 0;
            ctx.shadowColor = 'red';

            ctx.beginPath();
            const coils = 6;
            const coilStep = heaterWidth / coils;
            for(let i=0; i<coils; i++) {
                const cx = heaterX + 5 + i*coilStep;
                ctx.moveTo(cx, heaterY);
                ctx.lineTo(cx + coilStep/2, heaterY - 8);
                ctx.lineTo(cx + coilStep, heaterY);
            }
            ctx.stroke();
            ctx.restore();
        }

        // --- Math Helpers for Bezier Curves ---
        // Get point at t (0 to 1) on cubic bezier
        function getCubicBezierXY(t, p0, p1, p2, p3) {
            const cX = 3 * (p1.x - p0.x);
            const bX = 3 * (p2.x - p1.x) - cX;
            const aX = p3.x - p0.x - cX - bX;

            const cY = 3 * (p1.y - p0.y);
            const bY = 3 * (p2.y - p1.y) - cY;
            const aY = p3.y - p0.y - cY - bY;

            const x = (aX * Math.pow(t, 3)) + (bX * Math.pow(t, 2)) + (cX * t) + p0.x;
            const y = (aY * Math.pow(t, 3)) + (bY * Math.pow(t, 2)) + (cY * t) + p0.y;

            return { x, y };
        }

        // Get tangent angle at t (0 to 1)
        function getCubicBezierAngle(t, p0, p1, p2, p3) {
            // Derivative of cubic bezier
            const dx = 3 * Math.pow(1 - t, 2) * (p1.x - p0.x) + 
                       6 * (1 - t) * t * (p2.x - p1.x) + 
                       3 * Math.pow(t, 2) * (p3.x - p2.x);
            
            const dy = 3 * Math.pow(1 - t, 2) * (p1.y - p0.y) + 
                       6 * (1 - t) * t * (p2.y - p1.y) + 
                       3 * Math.pow(t, 2) * (p3.y - p2.y);
            
            return Math.atan2(dy, dx);
        }

        function drawConvectionLines() {
            if (!showLinesCheckbox.checked) return;

            const kx = kettleBounds.x;
            const ky = kettleBounds.y;
            const kw = kettleBounds.w;
            const kh = kettleBounds.h;
            const cx = centerAxisX;

            ctx.save();
            ctx.globalAlpha = 0.4; 
            ctx.strokeStyle = '#4b5563'; // darker gray
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]); 

            // --- Right Loop Definition ---
            // We split the loop into two cubic bezier segments for a full smooth oval-ish shape
            
            // Segment 1: Bottom-Center -> Top-Right (Up & Out)
            const r1_p0 = { x: cx + 10, y: ky + kh - 20 };
            const r1_p1 = { x: cx + 10, y: ky + kh * 0.2 }; // Control point goes UP
            const r1_p2 = { x: kx + kw * 0.8, y: ky + 20 };  // Control point goes OUT
            const r1_p3 = { x: kx + kw - 20, y: ky + kh * 0.4 }; // End near top side

            // Segment 2: Top-Right -> Bottom-Center (Down & In)
            const r2_p0 = r1_p3;
            const r2_p1 = { x: kx + kw + 10, y: ky + kh * 0.8 }; // Control point goes DOWN
            const r2_p2 = { x: cx + kw * 0.3, y: ky + kh - 10 }; // Control point goes IN
            const r2_p3 = r1_p0; // Loop back to start

            // Draw Right Path
            ctx.beginPath();
            ctx.moveTo(r1_p0.x, r1_p0.y);
            ctx.bezierCurveTo(r1_p1.x, r1_p1.y, r1_p2.x, r1_p2.y, r1_p3.x, r1_p3.y);
            ctx.bezierCurveTo(r2_p1.x, r2_p1.y, r2_p2.x, r2_p2.y, r2_p3.x, r2_p3.y);
            ctx.stroke();

            // Draw Right Arrows (Calculated exactly on the curve)
            // Arrow 1: On the way Up (t=0.5 of seg 1)
            const rArrow1 = getCubicBezierXY(0.5, r1_p0, r1_p1, r1_p2, r1_p3);
            const rAngle1 = getCubicBezierAngle(0.5, r1_p0, r1_p1, r1_p2, r1_p3);
            drawArrowHeadAtPoint(rArrow1.x, rArrow1.y, rAngle1);

            // Arrow 2: On the way Down (t=0.5 of seg 2)
            const rArrow2 = getCubicBezierXY(0.5, r2_p0, r2_p1, r2_p2, r2_p3);
            const rAngle2 = getCubicBezierAngle(0.5, r2_p0, r2_p1, r2_p2, r2_p3);
            drawArrowHeadAtPoint(rArrow2.x, rArrow2.y, rAngle2);


            // --- Left Loop Definition (Mirror) ---
            
            // Segment 1: Bottom-Center -> Top-Left (Up & Out)
            const l1_p0 = { x: cx - 10, y: ky + kh - 20 };
            const l1_p1 = { x: cx - 10, y: ky + kh * 0.2 }; 
            const l1_p2 = { x: kx + kw * 0.2, y: ky + 20 };  
            const l1_p3 = { x: kx + 20, y: ky + kh * 0.4 }; 

            // Segment 2: Top-Left -> Bottom-Center (Down & In)
            const l2_p0 = l1_p3;
            const l2_p1 = { x: kx - 10, y: ky + kh * 0.8 }; 
            const l2_p2 = { x: cx - kw * 0.3, y: ky + kh - 10 }; 
            const l2_p3 = l1_p0; 

            // Draw Left Path
            ctx.beginPath();
            ctx.moveTo(l1_p0.x, l1_p0.y);
            ctx.bezierCurveTo(l1_p1.x, l1_p1.y, l1_p2.x, l1_p2.y, l1_p3.x, l1_p3.y);
            ctx.bezierCurveTo(l2_p1.x, l2_p1.y, l2_p2.x, l2_p2.y, l2_p3.x, l2_p3.y);
            ctx.stroke();

            // Draw Left Arrows
            const lArrow1 = getCubicBezierXY(0.5, l1_p0, l1_p1, l1_p2, l1_p3);
            const lAngle1 = getCubicBezierAngle(0.5, l1_p0, l1_p1, l1_p2, l1_p3);
            drawArrowHeadAtPoint(lArrow1.x, lArrow1.y, lAngle1);

            const lArrow2 = getCubicBezierXY(0.5, l2_p0, l2_p1, l2_p2, l2_p3);
            const lAngle2 = getCubicBezierAngle(0.5, l2_p0, l2_p1, l2_p2, l2_p3);
            drawArrowHeadAtPoint(lArrow2.x, lArrow2.y, lAngle2);

            ctx.restore();
        }

        function drawArrowHeadAtPoint(x, y, angle) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.beginPath();
            ctx.moveTo(-5, -5); // Back left
            ctx.lineTo(5, 0);   // Tip
            ctx.lineTo(-5, 5);  // Back right
            ctx.closePath();
            ctx.fillStyle = '#4b5563'; // Gray-600
            ctx.fill();
            ctx.restore();
        }

        // --- Main Loop ---

        function animate() {
            ctx.clearRect(0, 0, width, height);

            let totalTemp = 0;
            particles.forEach(p => {
                p.update();
                totalTemp += p.temp;
            });
            
            for (let i = bubbles.length - 1; i >= 0; i--) {
                bubbles[i].update();
                if (!bubbles[i].active) bubbles.splice(i, 1);
            }

            // Stats Smoothing
            const currentAvg = totalTemp / particles.length;
            displayAvgTemp += (currentAvg - displayAvgTemp) * 0.05; 

            avgTempDisplay.textContent = Math.round(displayAvgTemp) + "°C";
            
            if (POWER === 0 && displayAvgTemp < 30) {
                stateTextDisplay.textContent = "靜止 (Static)";
                stateTextDisplay.className = "text-lg font-bold text-gray-600";
            } else if (displayAvgTemp >= 95) {
                stateTextDisplay.textContent = "沸騰 (Boiling)";
                stateTextDisplay.className = "text-lg font-bold text-red-600 animate-pulse";
            } else if (POWER > 0) {
                stateTextDisplay.textContent = "對流加熱中 (Heating)";
                stateTextDisplay.className = "text-lg font-bold text-orange-500";
            } else {
                stateTextDisplay.textContent = "冷卻中 (Cooling)";
                stateTextDisplay.className = "text-lg font-bold text-blue-500";
            }

            drawConvectionLines();
            particles.forEach(p => p.draw());
            bubbles.forEach(b => b.draw());
            drawCentralHeater();
            drawKettle();

            frameId = requestAnimationFrame(animate);
        }

        // --- Events ---

        powerSlider.addEventListener('input', (e) => {
            POWER = parseInt(e.target.value);
            powerValueDisplay.textContent = POWER + " W";
        });

        resetBtn.addEventListener('click', () => {
            POWER = 0;
            powerSlider.value = 0;
            powerValueDisplay.textContent = "0 W";
            displayAvgTemp = ROOM_TEMP;
            initParticles();
        });

        window.addEventListener('resize', () => {
            resize();
            initParticles();
        });

        window.onload = () => {
            resize();
            initParticles();
            animate();
        };

    </script>
</body>
</html>