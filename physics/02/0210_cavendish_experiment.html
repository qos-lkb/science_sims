<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>卡文迪許扭秤實驗 (The Cavendish Experiment)</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Phosphor Icons -->
    <script src="https://unpkg.com/@phosphor-icons/web"></script>

    <!-- MathJax -->
    <script>
        window.MathJax = {
            tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
            svg: { fontCache: 'global' }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <style>
        /* Custom scrollbar for better aesthetics */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f5f9; 
        }
        ::-webkit-scrollbar-thumb {
            background: #cbd5e1; 
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #94a3b8; 
        }
        
        /* Modal Animation Classes */
        .modal-enter {
            opacity: 0;
            transform: scale(0.95);
        }
        .modal-enter-active {
            opacity: 1;
            transform: scale(1);
            transition: opacity 0.2s ease-out, transform 0.2s ease-out;
        }
        .modal-exit {
            opacity: 1;
            transform: scale(1);
        }
        .modal-exit-active {
            opacity: 0;
            transform: scale(0.95);
            transition: opacity 0.2s ease-in, transform 0.2s ease-in;
        }
    </style>
</head>
<body class="bg-slate-50 font-sans text-slate-800 overflow-hidden h-screen flex flex-col">

    <!-- 1. Header Bar -->
    <header class="bg-white border-b border-slate-200 px-6 py-3 flex items-center justify-between shadow-sm z-10 shrink-0">
        <div class="flex items-center gap-3">
            <div class="p-2 bg-yellow-100 rounded-lg text-yellow-600">
                <i class="ph-fill ph-lightbulb text-2xl"></i>
            </div>
            <div>
                <h1 class="text-xl font-bold text-slate-900 leading-tight" id="app-title">卡文迪許扭秤實驗</h1>
                <p class="text-xs text-slate-500 hidden md:block" id="app-subtitle">利用精密扭秤測量微弱的萬有引力，進而推算地球質量與萬有引力常數 G。</p>
            </div>
        </div>
        <div class="flex items-center gap-2">
            <button id="btn-theory" class="flex items-center gap-2 px-3 py-2 text-sm font-medium text-purple-700 bg-purple-50 hover:bg-purple-100 rounded-lg transition-colors">
                <i class="ph ph-book-open text-lg"></i>
                <span class="hidden sm:inline" id="txt-theory-btn">物理原理</span>
            </button>
            <button id="btn-lang" class="flex items-center gap-2 px-3 py-2 text-sm font-medium text-slate-700 bg-slate-100 hover:bg-slate-200 rounded-lg transition-colors border border-slate-200">
                <i class="ph ph-translate text-lg"></i>
                <span>中 / Eng</span>
            </button>
        </div>
    </header>

    <!-- 2. Main Layout (Scrollable Content) -->
    <div class="flex-1 overflow-auto p-4 md:p-6">
        <div class="max-w-7xl mx-auto grid grid-cols-1 lg:grid-cols-12 gap-6">
            
            <!-- Left Column: Controls (4 cols) -->
            <div class="lg:col-span-4 space-y-6">
                <div class="bg-white p-6 rounded-xl shadow-sm border border-slate-200">
                    <h2 class="text-lg font-semibold mb-4 text-slate-700 flex items-center gap-2">
                        <i class="ph ph-ruler text-xl"></i> <span id="txt-controls-title">參數控制台</span>
                    </h2>
                    
                    <div class="space-y-6">
                        <!-- Mass Slider -->
                        <div>
                            <div class="flex justify-between mb-2">
                                <label class="text-sm font-medium text-slate-600" id="txt-mass-label">大鉛球質量 (M)</label>
                                <span class="text-sm font-bold text-blue-600 bg-blue-50 px-2 rounded">
                                    <span id="val-mass">150</span> kg
                                </span>
                            </div>
                            <input type="range" id="input-mass" min="50" max="250" step="10" value="150" class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600">
                        </div>

                        <!-- Distance Slider -->
                        <div>
                            <div class="flex justify-between mb-2">
                                <label class="text-sm font-medium text-slate-600" id="txt-dist-label">質心距離 (r)</label>
                                <span class="text-sm font-bold text-blue-600 bg-blue-50 px-2 rounded">
                                    <span id="val-dist">0.2</span> m
                                </span>
                            </div>
                            <input type="range" id="input-dist" min="0.1" max="0.5" step="0.01" value="0.2" class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600">
                        </div>

                        <!-- Action Buttons -->
                        <div class="grid grid-cols-4 gap-2 pt-2">
                            <button id="btn-sim-toggle" class="col-span-3 py-3 px-4 rounded-lg flex items-center justify-center gap-2 font-bold transition-all shadow-sm bg-blue-600 text-white hover:bg-blue-700 hover:shadow-md">
                                <i class="ph-fill ph-play text-lg" id="icon-sim-toggle"></i> 
                                <span id="txt-sim-toggle">開始測量</span>
                            </button>
                            
                            <button id="btn-light-toggle" class="col-span-1 rounded-lg flex items-center justify-center transition-colors border bg-emerald-100 text-emerald-700 border-emerald-200" title="光槓桿開關">
                                <i class="ph-fill ph-info text-xl"></i>
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Column: Visualization & Results (8 cols) -->
            <div class="lg:col-span-8 flex flex-col gap-6">
                
                <!-- Main Canvas -->
                <div class="bg-white rounded-xl shadow-md border border-slate-200 overflow-hidden relative">
                    <div class="absolute top-0 left-0 right-0 bg-slate-100/80 px-4 py-2 text-xs font-mono text-slate-500 border-b border-slate-200 flex justify-between z-10">
                        <span id="txt-view-top">視角: 俯視圖</span>
                        <span>SCALE: 1:100</span>
                    </div>
                    
                    <div class="aspect-[16/10] w-full bg-slate-50 relative">
                        <canvas id="sim-canvas" width="800" height="500" class="w-full h-full object-contain"></canvas>
                    </div>

                    <!-- Status Overlay -->
                    <div class="absolute bottom-4 right-4 pointer-events-none">
                        <div id="status-badge" class="px-3 py-1 rounded-full text-xs font-bold border shadow-sm backdrop-blur-sm bg-slate-500/10 text-slate-600 border-slate-200">
                            系統待機
                        </div>
                    </div>
                </div>

                <!-- Real-time Data Board -->
                <div class="bg-white p-6 rounded-xl shadow-sm border border-slate-200">
                    <h2 class="text-lg font-semibold mb-4 text-slate-700 flex items-center gap-2">
                        <i class="ph ph-arrows-clockwise text-xl"></i> <span id="txt-data-title">即時數據與計算</span>
                    </h2>

                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                        <div class="p-4 bg-blue-50/50 rounded-lg border border-blue-100">
                            <div class="text-xs font-medium text-slate-500 mb-1"><span id="txt-force">引力 Force</span> ($F$)</div>
                            <div class="text-xl font-mono font-bold text-blue-700" id="val-force">0.00 N</div>
                        </div>
                        
                        <div class="p-4 bg-purple-50/50 rounded-lg border border-purple-100">
                            <div class="text-xs font-medium text-slate-500 mb-1"><span id="txt-torque">力矩 Torque</span> ($\tau$)</div>
                            <div class="text-xl font-mono font-bold text-purple-700" id="val-torque">0.00 N·m</div>
                        </div>

                        <div class="p-4 bg-emerald-50/50 rounded-lg border border-emerald-100">
                            <div class="text-xs font-medium text-slate-500 mb-1"><span id="txt-angle">扭轉角 Angle</span> ($\theta$)</div>
                            <div class="text-xl font-mono font-bold text-emerald-700" id="val-angle">0.00 rad</div>
                        </div>
                    </div>

                    <!-- Calculation Walkthrough -->
                    <div class="border-t border-slate-200 pt-5">
                        <div class="flex flex-col md:flex-row items-center justify-between gap-6">
                            
                            <div class="flex-1">
                                <h3 class="text-sm font-bold text-slate-700 mb-2" id="txt-calc-title">反推計算萬有引力常數 G</h3>
                                <div class="text-sm text-slate-600 bg-slate-50 p-3 rounded border border-slate-200">
                                    <div class="mb-2 flex items-center gap-2">
                                        <span id="txt-calc-formula">公式：</span> 
                                        <span>$G = \frac{\kappa \theta r^2}{M m d}$</span>
                                    </div>
                                    <div class="text-xs text-slate-400">
                                        <span id="txt-calc-desc">代入當前測量的 $\theta$ 值與已知參數...</span>
                                    </div>
                                </div>
                            </div>

                            <div class="text-center min-w-[240px] p-4 bg-slate-900 rounded-lg shadow-inner border border-slate-700">
                                <div class="text-xs text-slate-400 mb-2 uppercase tracking-wider" id="txt-calc-result">計算出的常數 G</div>
                                <div class="text-3xl font-mono font-bold tracking-tight transition-colors text-slate-600" id="val-calc-g">
                                    ---
                                </div>
                                <div class="text-xs text-slate-500 mt-2 font-mono">
                                    <span id="txt-standard">標準值:</span> <span>$6.67 \times 10^{-11}$</span>
                                </div>
                            </div>

                        </div>
                    </div>
                </div>

            </div>
        </div>
    </div>

    <!-- 3. Theory Modal -->
    <div id="theory-modal" class="fixed inset-0 z-50 hidden flex items-center justify-center p-4 bg-black/60 backdrop-blur-sm transition-opacity duration-200 opacity-0 pointer-events-none">
        <div class="bg-slate-800 text-slate-100 p-6 rounded-2xl shadow-2xl max-w-lg w-full relative border border-slate-700 transform scale-95 transition-transform duration-200">
            <button id="btn-close-modal" class="absolute top-4 right-4 text-slate-400 hover:text-white transition-colors">
                <i class="ph ph-x text-2xl"></i>
            </button>

            <h3 class="font-bold text-xl mb-6 text-white flex items-center gap-3">
                <div class="p-2 bg-purple-500/20 rounded-lg">
                    <i class="ph-fill ph-calculator text-purple-400 text-2xl"></i>
                </div>
                <span id="modal-title">物理原理</span>
            </h3>
            
            <div class="space-y-5 text-sm leading-relaxed text-slate-300">
                <div>
                    <p class="mb-2" id="modal-p1">當大球 $M$ 靠近小球 $m$ 時，萬有引力提供力矩 $\tau$ ：</p>
                    <div class="p-3 bg-slate-900/50 rounded-lg text-center text-yellow-400 overflow-x-auto border border-slate-700/50">
                        $\tau = G \frac{Mm}{r^2} d$
                    </div>
                </div>
                
                <div>
                    <p class="mb-2" id="modal-p2">懸絲扭轉 $\theta$ 產生恢復力矩，平衡時：</p>
                    <div class="p-3 bg-slate-900/50 rounded-lg text-center text-yellow-400 overflow-x-auto border border-slate-700/50">
                        $\kappa \theta = \tau$
                    </div>
                </div>

                <div class="pt-5 border-t border-slate-700">
                    <p class="font-semibold text-white mb-2 flex items-center gap-2">
                         <i class="ph-fill ph-lightbulb text-emerald-400"></i> <span id="modal-optical-title">光槓桿 (Optical Lever)</span>
                    </p>
                    <p id="modal-optical-desc">鏡面轉動 $\theta$ ，反射光偏轉 $2\theta$ 。這使得微小的轉動也能在遠處標尺上被清晰讀取。</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script>
        // --- Translations ---
        const TEXT = {
            zh: {
                title: "卡文迪許扭秤實驗",
                subtitle: "利用精密扭秤測量微弱的萬有引力，進而推算地球質量與萬有引力常數 G。",
                controlsTitle: "參數控制台",
                massLabel: "大鉛球質量 (M)",
                distLabel: "質心距離 (r)",
                reset: "重置實驗",
                start: "開始測量",
                theoryBtn: "物理原理",
                theoryTitle: "物理原理",
                theoryP1: "當大球 $M$ 靠近小球 $m$ 時，萬有引力提供力矩 $\\tau$ ：",
                theoryP2: "懸絲扭轉 $\\theta$ 產生恢復力矩，平衡時：",
                opticalLever: "光槓桿 (Optical Lever)",
                opticalDesc: "鏡面轉動 $\\theta$ ，反射光偏轉 $2\\theta$ 。這使得微小的轉動也能在遠處標尺上被清晰讀取。",
                viewTop: "視角: 俯視圖",
                statusActive: "模擬進行中",
                statusStandby: "系統待機",
                dataTitle: "即時數據與計算",
                force: "引力 Force",
                torque: "力矩 Torque",
                angle: "扭轉角 Angle",
                calcTitle: "反推計算萬有引力常數 G",
                calcFormula: "公式：",
                calcDesc: "代入當前測量的 $\\theta$ 值與已知參數...",
                calcResult: "計算出的常數 G",
                standard: "標準值:"
            },
            en: {
                title: "The Cavendish Experiment",
                subtitle: "Using a torsion balance to measure gravitational force and calculate the gravitational constant G.",
                controlsTitle: "Control Panel",
                massLabel: "Large Mass (M)",
                distLabel: "Distance (r)",
                reset: "Reset",
                start: "Start",
                theoryBtn: "Theory",
                theoryTitle: "Physics Principles",
                theoryP1: "When large mass $M$ approaches small mass $m$, gravity creates a torque $\\tau$:",
                theoryP2: "The wire twists by $\\theta$, creating a restoring torque. At equilibrium:",
                opticalLever: "Optical Lever",
                opticalDesc: "Mirror rotates by $\\theta$, reflected light deviates by $2\\theta$. This magnifies small rotations.",
                viewTop: "VIEW: TOP-DOWN",
                statusActive: "SIMULATION ACTIVE",
                statusStandby: "SYSTEM STANDBY",
                dataTitle: "Real-time Data",
                force: "Force",
                torque: "Torque",
                angle: "Angle",
                calcTitle: "Calculating Constant G",
                calcFormula: "Formula:",
                calcDesc: "Substituting measured $\\theta$ and known parameters...",
                calcResult: "Calculated Constant G",
                standard: "Standard:"
            }
        };

        // --- App State ---
        const state = {
            bigMass: 150,
            distance: 0.2,
            isSimulating: false,
            showLight: true,
            lang: 'zh',
            currentAngle: 0,
            velocity: 0,
            equilibriumAngle: 0
        };

        // Constants
        const CONSTANTS = {
            smallMass: 0.75,
            rodLength: 1.8,
            torsionConstant: 0.0005,
            G_REAL: 6.67430e-11
        };

        // DOM Elements
        const canvas = document.getElementById('sim-canvas');
        const ctx = canvas.getContext('2d');
        const els = {
            title: document.getElementById('app-title'),
            subtitle: document.getElementById('app-subtitle'),
            theoryBtnText: document.getElementById('txt-theory-btn'),
            controlsTitle: document.getElementById('txt-controls-title'),
            massLabel: document.getElementById('txt-mass-label'),
            distLabel: document.getElementById('txt-dist-label'),
            simToggleText: document.getElementById('txt-sim-toggle'),
            viewTop: document.getElementById('txt-view-top'),
            statusBadge: document.getElementById('status-badge'),
            dataTitle: document.getElementById('txt-data-title'),
            forceLabel: document.getElementById('txt-force'),
            torqueLabel: document.getElementById('txt-torque'),
            angleLabel: document.getElementById('txt-angle'),
            calcTitle: document.getElementById('txt-calc-title'),
            calcFormula: document.getElementById('txt-calc-formula'),
            calcDesc: document.getElementById('txt-calc-desc'),
            calcResult: document.getElementById('txt-calc-result'),
            standard: document.getElementById('txt-standard'),
            modalTitle: document.getElementById('modal-title'),
            modalP1: document.getElementById('modal-p1'),
            modalP2: document.getElementById('modal-p2'),
            modalOpticalTitle: document.getElementById('modal-optical-title'),
            modalOpticalDesc: document.getElementById('modal-optical-desc'),
            
            valMass: document.getElementById('val-mass'),
            valDist: document.getElementById('val-dist'),
            valForce: document.getElementById('val-force'),
            valTorque: document.getElementById('val-torque'),
            valAngle: document.getElementById('val-angle'),
            valCalcG: document.getElementById('val-calc-g'),

            inputMass: document.getElementById('input-mass'),
            inputDist: document.getElementById('input-dist'),
            
            btnSimToggle: document.getElementById('btn-sim-toggle'),
            iconSimToggle: document.getElementById('icon-sim-toggle'),
            btnLightToggle: document.getElementById('btn-light-toggle'),
            btnTheory: document.getElementById('btn-theory'),
            btnLang: document.getElementById('btn-lang'),
            btnCloseModal: document.getElementById('btn-close-modal'),
            modal: document.getElementById('theory-modal')
        };

        // --- Logic ---

        function updatePhysics() {
            // Force F = G * (M*m) / r^2
            const force = (CONSTANTS.G_REAL * state.bigMass * CONSTANTS.smallMass) / (state.distance * state.distance);
            
            // Torque = Force * d
            const torque = force * CONSTANTS.rodLength;

            // Equilibrium Angle
            state.equilibriumAngle = torque / CONSTANTS.torsionConstant;
            
            // Return current values for display
            return { force, torque };
        }

        // Animation Loop
        let lastTime = 0;
        function loop(timestamp) {
            if (!lastTime) lastTime = timestamp;
            const dt = 0.016; // Fix at approx 60fps for consistency or usage (timestamp - lastTime) / 1000

            // Physics Update (Spring / Harmonic Oscillator)
            const k_spring = 2.0;
            const damping = 0.98;
            
            const target = state.isSimulating ? state.equilibriumAngle : 0;
            const displacement = target - state.currentAngle;
            const acceleration = displacement * k_spring;
            
            state.velocity += acceleration * dt;
            state.velocity *= damping;
            state.currentAngle += state.velocity * dt;

            // Calculate derived G
            // G = (kappa * theta * r^2) / (M * m * d)
            const calculatedG = (CONSTANTS.torsionConstant * state.currentAngle * Math.pow(state.distance, 2)) / 
                                (state.bigMass * CONSTANTS.smallMass * CONSTANTS.rodLength);

            // Draw
            draw();

            // Update Realtime Data Text (Using HTML for speed, not MathJax)
            const physics = updatePhysics();
            
            els.valForce.innerHTML = formatSciHTML(physics.force) + ' N';
            els.valTorque.innerHTML = formatSciHTML(physics.torque) + ' N·m';
            els.valAngle.innerHTML = formatSciHTML(state.currentAngle) + ' rad';
            
            if (state.isSimulating && state.currentAngle > 0.0000001) {
                els.valCalcG.innerHTML = formatSciHTML(calculatedG);
                els.valCalcG.className = "text-3xl font-mono font-bold tracking-tight transition-colors text-green-500";
            } else {
                els.valCalcG.innerHTML = "---";
                els.valCalcG.className = "text-3xl font-mono font-bold tracking-tight transition-colors text-slate-600";
            }

            requestAnimationFrame(loop);
        }

        // Canvas Drawing
        function draw() {
            const width = canvas.width;
            const height = canvas.height;
            const centerX = width / 2;
            const centerY = height / 2;

            ctx.clearRect(0, 0, width, height);

            const pxPerMeter = 100; 
            const rodPx = CONSTANTS.rodLength * pxPerMeter; 
            const visualAngle = state.currentAngle * 5000000; 

            // 1. Environment
            ctx.beginPath();
            ctx.arc(centerX, centerY, 190, 0, 2 * Math.PI);
            ctx.fillStyle = '#f8fafc';
            ctx.fill();
            ctx.strokeStyle = '#cbd5e1';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(centerX, centerY, 180, 0, 2 * Math.PI);
            ctx.strokeStyle = '#94a3b8';
            ctx.lineWidth = 4;
            ctx.stroke();

            ctx.save();
            // 2. Rotate Context
            ctx.translate(centerX, centerY);
            ctx.rotate(visualAngle);

            // 3. Rod
            ctx.beginPath();
            ctx.moveTo(-rodPx / 2, 0);
            ctx.lineTo(rodPx / 2, 0);
            ctx.strokeStyle = '#334155'; 
            ctx.lineWidth = 6;
            ctx.lineCap = 'round';
            ctx.stroke();
            
            ctx.beginPath();
            ctx.arc(0, 0, 6, 0, 2 * Math.PI);
            ctx.fillStyle = '#1e293b';
            ctx.fill();

            // 4. Small Masses
            const smallRadius = 12;
            drawSphere(ctx, -rodPx/2, 0, smallRadius, 'red');
            drawSphere(ctx, rodPx/2, 0, smallRadius, 'red');

            ctx.fillStyle = 'white';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('m', -rodPx/2, 0);
            ctx.fillText('m', rodPx/2, 0);

            // 5. Mirror
            ctx.fillStyle = '#bfdbfe'; 
            ctx.strokeStyle = '#1d4ed8';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.rect(-3, -12, 6, 24);
            ctx.fill();
            ctx.stroke();

            ctx.restore();

            // 6. Large Masses (M)
            if (state.isSimulating) {
                const mPosR = rodPx / 2;
                const gapPx = (state.distance * pxPerMeter); 
                // We draw M relative to the canvas center, calculating positions
                // However, M is fixed in the simulation frame relative to the REST position of small masses.
                // Rest position of m1 is (rodPx/2, 0) (before rotation).
                // M should be at (mPosR, -gapPx) roughly.
                
                const largeRadius = 30;
                drawSphere(ctx, centerX + mPosR, centerY - gapPx, largeRadius, 'dark');
                drawSphere(ctx, centerX - mPosR, centerY + gapPx, largeRadius, 'dark');

                ctx.fillStyle = 'white';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('M', centerX + mPosR, centerY - gapPx);
                ctx.fillText('M', centerX - mPosR, centerY + gapPx);

                // Force Lines
                // Current m positions
                const cosA = Math.cos(visualAngle);
                const sinA = Math.sin(visualAngle);
                const m1x = centerX + (rodPx/2) * cosA;
                const m1y = centerY + (rodPx/2) * sinA;
                const m2x = centerX - (rodPx/2) * cosA;
                const m2y = centerY - (rodPx/2) * sinA;

                ctx.strokeStyle = '#f59e0b'; 
                ctx.lineWidth = 2;
                ctx.setLineDash([4, 4]);
                
                ctx.beginPath();
                ctx.moveTo(m1x, m1y);
                ctx.lineTo(centerX + mPosR, centerY - gapPx);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(m2x, m2y);
                ctx.lineTo(centerX - mPosR, centerY + gapPx);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // 7. Laser
            if (state.showLight) {
                const laserOrigin = { x: centerX, y: height - 10 };
                const scaleRadius = 280;
                
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#10b981';
                ctx.strokeStyle = '#10b981'; 
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.8;
                
                ctx.beginPath();
                ctx.moveTo(laserOrigin.x, laserOrigin.y);
                ctx.lineTo(centerX, centerY);
                ctx.stroke();

                const reflectAngle = -Math.PI / 2 + (2 * visualAngle); 
                const hitX = centerX + scaleRadius * Math.cos(reflectAngle);
                const hitY = centerY + scaleRadius * Math.sin(reflectAngle);

                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(hitX, hitY);
                ctx.stroke();

                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;

                // Scale Arc
                ctx.strokeStyle = '#475569';
                ctx.lineWidth = 12;
                ctx.lineCap = 'butt';
                ctx.beginPath();
                ctx.arc(centerX, centerY, scaleRadius, Math.PI + 0.5, 2 * Math.PI - 0.5);
                ctx.stroke();
                
                // Ticks
                ctx.strokeStyle = '#cbd5e1';
                ctx.lineWidth = 2;
                for (let i = -10; i <= 10; i++) {
                    const ang = -Math.PI/2 + (i * 0.05);
                    const rIn = scaleRadius - 5;
                    const rOut = scaleRadius + 5;
                    ctx.beginPath();
                    ctx.moveTo(centerX + rIn*Math.cos(ang), centerY + rIn*Math.sin(ang));
                    ctx.lineTo(centerX + rOut*Math.cos(ang), centerY + rOut*Math.sin(ang));
                    ctx.stroke();
                }

                // Spot
                ctx.fillStyle = '#10b981';
                ctx.beginPath();
                ctx.arc(hitX, hitY, 6, 0, 2 * Math.PI);
                ctx.fill();
                ctx.fillStyle = '#d1fae5';
                ctx.beginPath();
                ctx.arc(hitX, hitY, 2, 0, 2 * Math.PI);
                ctx.fill();
            }
        }

        function drawSphere(ctx, x, y, radius, colorBase) {
            ctx.beginPath();
            const gradient = ctx.createRadialGradient(
                x - radius * 0.3, y - radius * 0.3, radius * 0.1,
                x, y, radius
            );
            if (colorBase === 'grey') {
                gradient.addColorStop(0, '#f3f4f6');
                gradient.addColorStop(0.3, '#9ca3af');
                gradient.addColorStop(1, '#374151');
            } else if (colorBase === 'red') {
                gradient.addColorStop(0, '#fca5a5');
                gradient.addColorStop(0.3, '#ef4444');
                gradient.addColorStop(1, '#991b1b');
            } else if (colorBase === 'dark') {
                gradient.addColorStop(0, '#6b7280');
                gradient.addColorStop(0.3, '#374151');
                gradient.addColorStop(1, '#111827');
            }
            ctx.fillStyle = gradient;
            ctx.arc(x, y, radius, 0, 2 * Math.PI);
            ctx.fill();
            
            // Shadow
            ctx.globalCompositeOperation = 'destination-over';
            ctx.beginPath();
            ctx.ellipse(x + 2, y + 2, radius, radius * 0.8, 0, 0, 2 * Math.PI);
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.fill();
            ctx.globalCompositeOperation = 'source-over';
        }

        function formatSciHTML(num) {
            if (typeof num !== 'number' || !isFinite(num) || num === 0) return "0.00";
            const exponent = Math.floor(Math.log10(Math.abs(num)));
            const mantissa = num / Math.pow(10, exponent);
            return `${mantissa.toFixed(2)} × 10<sup>${exponent}</sup>`;
        }

        // --- Interaction ---

        function updateLang() {
            const t = TEXT[state.lang];
            
            els.title.innerText = t.title;
            els.subtitle.innerText = t.subtitle;
            els.theoryBtnText.innerText = t.theoryBtn;
            els.controlsTitle.innerText = t.controlsTitle;
            els.massLabel.innerText = t.massLabel;
            els.distLabel.innerText = t.distLabel;
            els.simToggleText.innerText = state.isSimulating ? t.reset : t.start;
            els.viewTop.innerText = t.viewTop;
            els.statusBadge.innerText = state.isSimulating ? t.statusActive : t.statusStandby;
            els.dataTitle.innerText = t.dataTitle;
            els.forceLabel.innerText = t.force;
            els.torqueLabel.innerText = t.torque;
            els.angleLabel.innerText = t.angle;
            els.calcTitle.innerText = t.calcTitle;
            els.calcFormula.innerText = t.calcFormula;
            els.calcDesc.innerHTML = t.calcDesc; // Note innerHTML for mathjax if needed
            els.calcResult.innerText = t.calcResult;
            els.standard.innerText = t.standard;
            
            // Modal
            els.modalTitle.innerText = t.theoryTitle;
            els.modalP1.innerHTML = t.theoryP1;
            els.modalP2.innerHTML = t.theoryP2;
            els.modalOpticalTitle.innerText = t.opticalLever;
            els.modalOpticalDesc.innerHTML = t.opticalDesc;

            // Retrigger MathJax
            if(window.MathJax && window.MathJax.typesetPromise) {
                // We need to re-typeset the whole body or specific sections
                // Using timeout to ensure DOM update is complete
                setTimeout(() => {
                    MathJax.typesetPromise();
                }, 50);
            }
        }

        function setModalOpen(open) {
            if(open) {
                els.modal.classList.remove('hidden');
                // Trigger reflow for transition
                void els.modal.offsetWidth;
                els.modal.classList.remove('opacity-0', 'pointer-events-none');
                els.modal.firstElementChild.classList.remove('scale-95');
                els.modal.firstElementChild.classList.add('scale-100');
            } else {
                els.modal.classList.add('opacity-0', 'pointer-events-none');
                els.modal.firstElementChild.classList.remove('scale-100');
                els.modal.firstElementChild.classList.add('scale-95');
                setTimeout(() => {
                   if(els.modal.classList.contains('opacity-0')) { // check if still closed
                       els.modal.classList.add('hidden');
                   }
                }, 200);
            }
        }

        // Event Listeners
        els.inputMass.addEventListener('input', (e) => {
            state.bigMass = Number(e.target.value);
            els.valMass.innerText = state.bigMass;
        });

        els.inputDist.addEventListener('input', (e) => {
            state.distance = Number(e.target.value);
            els.valDist.innerText = state.distance;
        });

        els.btnSimToggle.addEventListener('click', () => {
            state.isSimulating = !state.isSimulating;
            const t = TEXT[state.lang];
            
            if(state.isSimulating) {
                els.btnSimToggle.classList.remove('bg-blue-600', 'text-white', 'hover:bg-blue-700');
                els.btnSimToggle.classList.add('bg-amber-100', 'text-amber-800', 'hover:bg-amber-200', 'border', 'border-amber-200');
                els.iconSimToggle.classList.replace('ph-play', 'ph-pause');
                els.simToggleText.innerText = t.reset;
                
                els.statusBadge.classList.replace('bg-slate-500/10', 'bg-green-500/10');
                els.statusBadge.classList.replace('text-slate-600', 'text-green-700');
                els.statusBadge.classList.replace('border-slate-200', 'border-green-200');
                els.statusBadge.innerText = t.statusActive;
            } else {
                els.btnSimToggle.classList.add('bg-blue-600', 'text-white', 'hover:bg-blue-700');
                els.btnSimToggle.classList.remove('bg-amber-100', 'text-amber-800', 'hover:bg-amber-200', 'border', 'border-amber-200');
                els.iconSimToggle.classList.replace('ph-pause', 'ph-play');
                els.simToggleText.innerText = t.start;

                els.statusBadge.classList.replace('bg-green-500/10', 'bg-slate-500/10');
                els.statusBadge.classList.replace('text-green-700', 'text-slate-600');
                els.statusBadge.classList.replace('border-green-200', 'border-slate-200');
                els.statusBadge.innerText = t.statusStandby;
            }
        });

        els.btnLightToggle.addEventListener('click', () => {
            state.showLight = !state.showLight;
            if(state.showLight) {
                els.btnLightToggle.className = "col-span-1 rounded-lg flex items-center justify-center transition-colors border bg-emerald-100 text-emerald-700 border-emerald-200";
            } else {
                els.btnLightToggle.className = "col-span-1 rounded-lg flex items-center justify-center transition-colors border bg-slate-100 text-slate-500 border-slate-200";
            }
        });

        els.btnLang.addEventListener('click', () => {
            state.lang = state.lang === 'zh' ? 'en' : 'zh';
            updateLang();
        });

        els.btnTheory.addEventListener('click', () => setModalOpen(true));
        els.btnCloseModal.addEventListener('click', () => setModalOpen(false));

        // Initial Start
        updateLang();
        requestAnimationFrame(loop);

    </script>
</body>
</html>