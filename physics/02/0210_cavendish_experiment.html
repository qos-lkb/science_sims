import React, { useState, useEffect, useRef, useMemo, useCallback } from 'react';
import { Ruler, Info, RefreshCw, Play, Pause, Lightbulb, Calculator, BookOpen, Languages, X } from 'lucide-react';

// --- Translation Data ---
const TEXT = {
  zh: {
    title: "卡文迪許扭秤實驗",
    subtitle: "利用精密扭秤測量微弱的萬有引力，進而推算地球質量與萬有引力常數 G。",
    controlsTitle: "參數控制台",
    massLabel: "大鉛球質量 (M)",
    distLabel: "質心距離 (r)",
    reset: "重置實驗",
    start: "開始測量",
    lightToggle: "光槓桿",
    theoryBtn: "物理原理",
    theoryTitle: "物理原理",
    // Use $...$ delimiters for math terms
    theoryP1: "當大球 $M$ 靠近小球 $m$ 時，萬有引力提供力矩 $\\tau$ ：",
    theoryP2: "懸絲扭轉 $\\theta$ 產生恢復力矩，平衡時：",
    opticalLever: "光槓桿 (Optical Lever)",
    opticalDesc: "鏡面轉動 $\\theta$ ，反射光偏轉 $2\\theta$ 。這使得微小的轉動也能在遠處標尺上被清晰讀取。",
    viewTop: "視角: 俯視圖",
    statusActive: "模擬進行中",
    statusStandby: "系統待機",
    dataTitle: "即時數據與計算",
    force: "引力 Force",
    torque: "力矩 Torque",
    angle: "扭轉角 Angle",
    calcTitle: "反推計算萬有引力常數 G",
    calcFormula: "公式：",
    calcDescPre: "代入當前測量的 ",
    calcDescPost: " 值與已知參數...",
    calcResult: "計算出的常數 G",
    standard: "標準值:"
  },
  en: {
    title: "The Cavendish Experiment",
    subtitle: "Using a torsion balance to measure gravitational force and calculate the gravitational constant G.",
    controlsTitle: "Control Panel",
    massLabel: "Large Mass (M)",
    distLabel: "Distance (r)",
    reset: "Reset",
    start: "Start",
    lightToggle: "Light Beam",
    theoryBtn: "Theory",
    theoryTitle: "Physics Principles",
    theoryP1: "When large mass $M$ approaches small mass $m$, gravity creates a torque $\\tau$:",
    theoryP2: "The wire twists by $\\theta$, creating a restoring torque. At equilibrium:",
    opticalLever: "Optical Lever",
    opticalDesc: "Mirror rotates by $\\theta$, reflected light deviates by $2\\theta$. This magnifies small rotations.",
    viewTop: "VIEW: TOP-DOWN",
    statusActive: "SIMULATION ACTIVE",
    statusStandby: "SYSTEM STANDBY",
    dataTitle: "Real-time Data",
    force: "Force",
    torque: "Torque",
    angle: "Angle",
    calcTitle: "Calculating Constant G",
    calcFormula: "Formula:",
    calcDescPre: "Substituting measured ",
    calcDescPost: " and known parameters...",
    calcResult: "Calculated Constant G",
    standard: "Standard:"
  }
};

// MathJax Helper Component (Single Equation)
// Modified to retry rendering if MathJax is not ready immediately
const MathEquation = ({ tex }) => {
  const ref = useRef(null);
  
  useEffect(() => {
    let intervalId = null;

    const renderMath = () => {
      if (window.MathJax && window.MathJax.typesetPromise && ref.current) {
        ref.current.innerHTML = `\\( ${tex} \\)`;
        window.MathJax.typesetPromise([ref.current]).catch((err) => {
           // Silent error catch
        });
        return true;
      }
      return false;
    };

    // Try immediately
    if (!renderMath()) {
      // If failed (MathJax not loaded yet), poll until it is ready
      intervalId = setInterval(() => {
        if (renderMath()) {
          clearInterval(intervalId);
        }
      }, 200);
    }

    return () => {
      if (intervalId) clearInterval(intervalId);
    };
  }, [tex]);

  return <span ref={ref} />;
};

// Helper to render text with mixed MathJax: "Text $math$ text"
const TextWithMath = ({ text }) => {
  // Split string by '$' delimiter
  const parts = text.split('$');
  return (
    <span>
      {parts.map((part, index) => {
        // Odd indices are the math parts (inside $...$)
        if (index % 2 === 1) {
          return <MathEquation key={index} tex={part} />;
        }
        return <span key={index}>{part}</span>;
      })}
    </span>
  );
};

const CavendishSim = () => {
  // --- State Variables ---
  const [bigMass, setBigMass] = useState(150); // kg (M)
  const [distance, setDistance] = useState(0.2); // meters (r) between centers
  const [isSimulating, setIsSimulating] = useState(false);
  const [showLight, setShowLight] = useState(true);
  const [lang, setLang] = useState('zh'); // 'zh' or 'en'
  const [showTheoryModal, setShowTheoryModal] = useState(false);
  
  const t = TEXT[lang];

  // Physics constants
  const smallMass = 0.75; // kg (m)
  const rodLength = 1.8; // meters (d)
  const torsionConstant = 0.0005; // N*m/rad (kappa)
  const G_REAL = 6.67430e-11; // Actual G constant
  
  // Animation State
  const [currentAngle, setCurrentAngle] = useState(0); // theta (radians)
  
  // Refs
  const velocityRef = useRef(0);
  const angleRef = useRef(0);
  const requestRef = useRef();
  const timeRef = useRef();
  const simulationTargetsRef = useRef({ active: false, targetAngle: 0 });

  // --- Load MathJax ---
  useEffect(() => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
        svg: { fontCache: 'global' }
      };
      const script = document.createElement('script');
      script.src = "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js";
      script.async = true;
      document.head.appendChild(script);
    }
  }, []);

  // --- Physics Calculations ---
  
  // Force: F = G * (M*m) / r^2
  const currentForce = useMemo(() => {
    return (G_REAL * bigMass * smallMass) / (distance * distance);
  }, [bigMass, distance]);

  // Torque: tau = F * d
  const currentTorque = currentForce * rodLength;

  // Equilibrium: tau = kappa * theta
  const equilibriumAngle = currentTorque / torsionConstant;

  // Derived G for display
  const calculatedG = (torsionConstant * currentAngle * Math.pow(distance, 2)) / (bigMass * smallMass * rodLength);

  // Sync Animation State
  useEffect(() => {
    simulationTargetsRef.current = {
      active: isSimulating,
      targetAngle: equilibriumAngle
    };
  }, [isSimulating, equilibriumAngle]);

  // --- Animation Loop ---
  const animate = useCallback((time) => {
    if (timeRef.current !== undefined) {
      const dt = 0.016; 
      const damping = 0.98; 
      const k_spring = 2.0; 
      
      const { active, targetAngle } = simulationTargetsRef.current;
      const target = active ? targetAngle : 0;
      
      const displacement = target - angleRef.current;
      const acceleration = displacement * k_spring;
      
      velocityRef.current += acceleration * dt;
      velocityRef.current *= damping;
      angleRef.current += velocityRef.current * dt;

      setCurrentAngle(angleRef.current);
    }
    timeRef.current = time;
    requestRef.current = requestAnimationFrame(animate);
  }, []);

  useEffect(() => {
    requestRef.current = requestAnimationFrame(animate);
    return () => {
      if (requestRef.current) cancelAnimationFrame(requestRef.current);
    };
  }, [animate]);

  // --- Helper: Draw 3D Sphere ---
  const drawSphere = (ctx, x, y, radius, colorBase) => {
    ctx.beginPath();
    const gradient = ctx.createRadialGradient(
      x - radius * 0.3, y - radius * 0.3, radius * 0.1,
      x, y, radius
    );
    if (colorBase === 'grey') {
      gradient.addColorStop(0, '#f3f4f6');
      gradient.addColorStop(0.3, '#9ca3af');
      gradient.addColorStop(1, '#374151');
    } else if (colorBase === 'red') {
      gradient.addColorStop(0, '#fca5a5');
      gradient.addColorStop(0.3, '#ef4444');
      gradient.addColorStop(1, '#991b1b');
    } else if (colorBase === 'dark') {
      gradient.addColorStop(0, '#6b7280');
      gradient.addColorStop(0.3, '#374151');
      gradient.addColorStop(1, '#111827');
    }
    ctx.fillStyle = gradient;
    ctx.arc(x, y, radius, 0, 2 * Math.PI);
    ctx.fill();
    
    // Shadow
    ctx.globalCompositeOperation = 'destination-over';
    ctx.beginPath();
    ctx.ellipse(x + 2, y + 2, radius, radius * 0.8, 0, 0, 2 * Math.PI);
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.fill();
    ctx.globalCompositeOperation = 'source-over';
  };

  // --- Canvas Rendering ---
  const canvasRef = useRef(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    const centerX = width / 2;
    const centerY = height / 2;
    
    // Clear
    ctx.clearRect(0, 0, width, height);

    // Styling Constants
    const pxPerMeter = 100; 
    const rodPx = rodLength * pxPerMeter; 
    const visualAngle = currentAngle * 5000000; // Exaggerated visual angle

    // 1. Draw Housing / Environment
    ctx.beginPath();
    ctx.arc(centerX, centerY, 190, 0, 2 * Math.PI);
    ctx.fillStyle = '#f8fafc';
    ctx.fill();
    ctx.strokeStyle = '#cbd5e1';
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.beginPath();
    ctx.arc(centerX, centerY, 180, 0, 2 * Math.PI);
    ctx.strokeStyle = '#94a3b8';
    ctx.lineWidth = 4;
    ctx.stroke();

    ctx.save();
    // 2. Rotate Context for Torsion Balance
    ctx.translate(centerX, centerY);
    ctx.rotate(visualAngle);

    // 3. Torsion Rod
    ctx.beginPath();
    ctx.moveTo(-rodPx / 2, 0);
    ctx.lineTo(rodPx / 2, 0);
    ctx.strokeStyle = '#334155'; 
    ctx.lineWidth = 6;
    ctx.lineCap = 'round';
    ctx.stroke();
    
    ctx.beginPath();
    ctx.arc(0, 0, 6, 0, 2 * Math.PI);
    ctx.fillStyle = '#1e293b';
    ctx.fill();

    // 4. Small Masses (m)
    const smallRadius = 12;
    drawSphere(ctx, -rodPx/2, 0, smallRadius, 'red');
    drawSphere(ctx, rodPx/2, 0, smallRadius, 'red');

    ctx.fillStyle = 'white';
    ctx.font = 'bold 12px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('m', -rodPx/2, 0);
    ctx.fillText('m', rodPx/2, 0);

    // 5. Mirror
    ctx.fillStyle = '#bfdbfe'; 
    ctx.strokeStyle = '#1d4ed8';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.rect(-3, -12, 6, 24);
    ctx.fill();
    ctx.stroke();

    ctx.restore();

    // 6. Large Masses (M)
    const mPosR = rodPx / 2;
    const gapPx = (distance * pxPerMeter); 
    const mVisualR = gapPx; 

    if (isSimulating) {
        const largeRadius = 30;
        drawSphere(ctx, mPosR, -mVisualR, largeRadius, 'dark');
        drawSphere(ctx, -mPosR, mVisualR, largeRadius, 'dark');

        ctx.fillStyle = 'white';
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('M', mPosR, -mVisualR);
        ctx.fillText('M', -mPosR, mVisualR);

        // Force Visuals
        ctx.save();
        ctx.translate(centerX, centerY);
        ctx.rotate(visualAngle); 
        ctx.restore();

        const cosA = Math.cos(visualAngle);
        const sinA = Math.sin(visualAngle);
        const m1x = centerX + (rodPx/2) * cosA;
        const m1y = centerY + (rodPx/2) * sinA;
        const m2x = centerX - (rodPx/2) * cosA;
        const m2y = centerY - (rodPx/2) * sinA;

        ctx.strokeStyle = '#f59e0b'; 
        ctx.lineWidth = 2;
        ctx.setLineDash([4, 4]);
        
        ctx.beginPath();
        ctx.moveTo(m1x, m1y);
        ctx.lineTo(centerX + mPosR, centerY - mVisualR);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(m2x, m2y);
        ctx.lineTo(centerX - mPosR, centerY + mVisualR);
        ctx.stroke();
        ctx.setLineDash([]);
    }

    // 7. Optical Lever / Laser
    if (showLight) {
        const laserOrigin = { x: centerX, y: height - 10 };
        const scaleRadius = 280;
        
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#10b981';
        ctx.strokeStyle = '#10b981'; 
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.8;
        
        ctx.beginPath();
        ctx.moveTo(laserOrigin.x, laserOrigin.y);
        ctx.lineTo(centerX, centerY);
        ctx.stroke();

        const reflectAngle = -Math.PI / 2 + (2 * visualAngle); 
        const hitX = centerX + scaleRadius * Math.cos(reflectAngle);
        const hitY = centerY + scaleRadius * Math.sin(reflectAngle);

        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.lineTo(hitX, hitY);
        ctx.stroke();

        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;

        ctx.strokeStyle = '#475569';
        ctx.lineWidth = 12;
        ctx.lineCap = 'butt';
        ctx.beginPath();
        ctx.arc(centerX, centerY, scaleRadius, Math.PI + 0.5, 2 * Math.PI - 0.5);
        ctx.stroke();
        
        ctx.strokeStyle = '#cbd5e1';
        ctx.lineWidth = 2;
        for (let i = -10; i <= 10; i++) {
            const ang = -Math.PI/2 + (i * 0.05);
            const rIn = scaleRadius - 5;
            const rOut = scaleRadius + 5;
            ctx.beginPath();
            ctx.moveTo(centerX + rIn*Math.cos(ang), centerY + rIn*Math.sin(ang));
            ctx.lineTo(centerX + rOut*Math.cos(ang), centerY + rOut*Math.sin(ang));
            ctx.stroke();
        }

        ctx.fillStyle = '#10b981';
        ctx.beginPath();
        ctx.arc(hitX, hitY, 6, 0, 2 * Math.PI);
        ctx.fill();
        ctx.fillStyle = '#d1fae5';
        ctx.beginPath();
        ctx.arc(hitX, hitY, 2, 0, 2 * Math.PI);
        ctx.fill();
    }

  }, [bigMass, distance, isSimulating, showLight, currentAngle]);

  // --- Formatters ---
  const formatSci = (num) => {
    if (typeof num !== 'number' || !isFinite(num) || num === 0) return "0.00";
    const exponent = Math.floor(Math.log10(Math.abs(num)));
    const mantissa = num / Math.pow(10, exponent);
    return `${mantissa.toFixed(2)} \\times 10^{${exponent}}`;
  };

  return (
    <div className="flex flex-col w-full h-screen bg-slate-50 font-sans text-slate-800 overflow-hidden">
      
      {/* 1. Header Bar */}
      <header className="bg-white border-b border-slate-200 px-6 py-3 flex items-center justify-between shadow-sm z-10">
        <div className="flex items-center gap-3">
            <div className="p-2 bg-yellow-100 rounded-lg text-yellow-600">
                <Lightbulb size={24} />
            </div>
            <div>
                <h1 className="text-xl font-bold text-slate-900 leading-tight">{t.title}</h1>
                <p className="text-xs text-slate-500 hidden md:block">{t.subtitle}</p>
            </div>
        </div>
        <div className="flex items-center gap-2">
            <button 
                onClick={() => setShowTheoryModal(true)}
                className="flex items-center gap-2 px-3 py-2 text-sm font-medium text-purple-700 bg-purple-50 hover:bg-purple-100 rounded-lg transition-colors"
            >
                <BookOpen size={18} />
                <span className="hidden sm:inline">{t.theoryBtn}</span>
            </button>
            <button 
                onClick={() => setLang(prev => prev === 'zh' ? 'en' : 'zh')}
                className="flex items-center gap-2 px-3 py-2 text-sm font-medium text-slate-700 bg-slate-100 hover:bg-slate-200 rounded-lg transition-colors border border-slate-200"
            >
                <Languages size={18} />
                <span>中 / Eng</span>
            </button>
        </div>
      </header>

      {/* 2. Main Layout (Scrollable Content) */}
      <div className="flex-1 overflow-auto p-4 md:p-6">
        <div className="max-w-7xl mx-auto grid grid-cols-1 lg:grid-cols-12 gap-6">
            
            {/* Left Column: Controls (4 cols) */}
            <div className="lg:col-span-4 space-y-6">
                <div className="bg-white p-6 rounded-xl shadow-sm border border-slate-200">
                    <h2 className="text-lg font-semibold mb-4 text-slate-700 flex items-center gap-2">
                    <Ruler className="w-5 h-5" /> {t.controlsTitle}
                    </h2>
                    
                    <div className="space-y-6">
                    {/* Mass Slider */}
                    <div>
                        <div className="flex justify-between mb-2">
                        <label className="text-sm font-medium text-slate-600">{t.massLabel}</label>
                        <span className="text-sm font-bold text-blue-600 bg-blue-50 px-2 rounded">
                            {bigMass} kg
                        </span>
                        </div>
                        <input 
                        type="range" min="50" max="250" step="10"
                        value={bigMass}
                        onChange={(e) => setBigMass(Number(e.target.value))}
                        className="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600"
                        />
                    </div>

                    {/* Distance Slider */}
                    <div>
                        <div className="flex justify-between mb-2">
                        <label className="text-sm font-medium text-slate-600">{t.distLabel}</label>
                        <span className="text-sm font-bold text-blue-600 bg-blue-50 px-2 rounded">
                            {distance} m
                        </span>
                        </div>
                        <input 
                        type="range" min="0.1" max="0.5" step="0.01"
                        value={distance}
                        onChange={(e) => setDistance(Number(e.target.value))}
                        className="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600"
                        />
                    </div>

                    {/* Action Buttons */}
                    <div className="grid grid-cols-4 gap-2 pt-2">
                        <button
                        onClick={() => setIsSimulating(!isSimulating)}
                        className={`col-span-3 py-3 px-4 rounded-lg flex items-center justify-center gap-2 font-bold transition-all shadow-sm ${
                            isSimulating 
                            ? 'bg-amber-100 text-amber-800 hover:bg-amber-200 border border-amber-200' 
                            : 'bg-blue-600 text-white hover:bg-blue-700 hover:shadow-md'
                        }`}
                        >
                        {isSimulating ? (
                            <><Pause size={18} /> {t.reset}</>
                        ) : (
                            <><Play size={18} /> {t.start}</>
                        )}
                        </button>
                        
                        <button
                        onClick={() => setShowLight(!showLight)}
                        className={`col-span-1 rounded-lg flex items-center justify-center transition-colors border ${
                            showLight 
                            ? 'bg-emerald-100 text-emerald-700 border-emerald-200' 
                            : 'bg-slate-100 text-slate-500 border-slate-200'
                        }`}
                        title={t.lightToggle}
                        >
                        <Info size={20} />
                        </button>
                    </div>
                    </div>
                </div>
            </div>

            {/* Right Column: Visualization & Results (8 cols) */}
            <div className="lg:col-span-8 flex flex-col gap-6">
            
            {/* Main Canvas */}
            <div className="bg-white rounded-xl shadow-md border border-slate-200 overflow-hidden relative">
                <div className="absolute top-0 left-0 right-0 bg-slate-100/80 px-4 py-2 text-xs font-mono text-slate-500 border-b border-slate-200 flex justify-between z-10">
                <span>{t.viewTop}</span>
                <span>SCALE: 1:100</span>
                </div>
                
                <div className="aspect-[16/10] w-full bg-slate-50 relative">
                    <canvas 
                    ref={canvasRef}
                    width={800}
                    height={500}
                    className="w-full h-full object-contain"
                    />
                </div>

                {/* Status Overlay */}
                <div className="absolute bottom-4 right-4 pointer-events-none">
                <div className={`px-3 py-1 rounded-full text-xs font-bold border shadow-sm backdrop-blur-sm ${
                    isSimulating 
                    ? 'bg-green-500/10 text-green-700 border-green-200' 
                    : 'bg-slate-500/10 text-slate-600 border-slate-200'
                }`}>
                    {isSimulating ? t.statusActive : t.statusStandby}
                </div>
                </div>
            </div>

            {/* Real-time Data Board */}
            <div className="bg-white p-6 rounded-xl shadow-sm border border-slate-200">
                <h2 className="text-lg font-semibold mb-4 text-slate-700 flex items-center gap-2">
                <RefreshCw className="w-5 h-5" /> {t.dataTitle}
                </h2>

                <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                <div className="p-4 bg-blue-50/50 rounded-lg border border-blue-100">
                    <div className="text-xs font-medium text-slate-500 mb-1">{t.force} (<MathEquation tex="F" />)</div>
                    <div className="text-xl font-mono font-bold text-blue-700">
                    <MathEquation tex={formatSci(currentForce) + "\\, \\text{N}"} />
                    </div>
                </div>
                
                <div className="p-4 bg-purple-50/50 rounded-lg border border-purple-100">
                    <div className="text-xs font-medium text-slate-500 mb-1">{t.torque} (<MathEquation tex="\tau" />)</div>
                    <div className="text-xl font-mono font-bold text-purple-700">
                    <MathEquation tex={formatSci(currentTorque) + "\\, \\text{N}\\cdot\\text{m}"} />
                    </div>
                </div>

                <div className="p-4 bg-emerald-50/50 rounded-lg border border-emerald-100">
                    <div className="text-xs font-medium text-slate-500 mb-1">{t.angle} (<MathEquation tex="\theta" />)</div>
                    <div className="text-xl font-mono font-bold text-emerald-700">
                    <MathEquation tex={formatSci(currentAngle) + "\\, \\text{rad}"} />
                    </div>
                </div>
                </div>

                {/* Calculation Walkthrough */}
                <div className="border-t border-slate-200 pt-5">
                <div className="flex flex-col md:flex-row items-center justify-between gap-6">
                    
                    <div className="flex-1">
                    <h3 className="text-sm font-bold text-slate-700 mb-2">{t.calcTitle}</h3>
                    <div className="text-sm text-slate-600 bg-slate-50 p-3 rounded border border-slate-200">
                        <div className="mb-2 flex items-center gap-2">
                            <span>{t.calcFormula}</span> 
                            <MathEquation tex="G = \frac{\kappa \theta r^2}{M m d}" />
                        </div>
                        <div className="text-xs text-slate-400 flex items-center gap-1 flex-wrap">
                            {t.calcDescPre} <MathEquation tex="\theta" /> {t.calcDescPost}
                        </div>
                    </div>
                    </div>

                    <div className="text-center min-w-[240px] p-4 bg-slate-900 rounded-lg shadow-inner border border-slate-700">
                    <div className="text-xs text-slate-400 mb-2 uppercase tracking-wider">{t.calcResult}</div>
                    <div className={`text-3xl font-mono font-bold tracking-tight transition-colors ${
                        isSimulating && currentAngle > 0.0000001 ? "text-green-400" : "text-slate-600"
                    }`}>
                        {isSimulating && currentAngle > 0.0000001
                        ? <MathEquation tex={formatSci(calculatedG)} />
                        : "---"}
                    </div>
                    <div className="text-xs text-slate-500 mt-2 font-mono">
                        {t.standard} <MathEquation tex="6.67 \times 10^{-11}" />
                    </div>
                    </div>

                </div>
                </div>
            </div>

            </div>
        </div>
      </div>

      {/* 3. Theory Modal */}
      {showTheoryModal && (
        <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/60 backdrop-blur-sm animate-in fade-in duration-200">
            <div className="bg-slate-800 text-slate-100 p-6 rounded-2xl shadow-2xl max-w-lg w-full relative border border-slate-700 animate-in zoom-in-95 duration-200">
                <button 
                    onClick={() => setShowTheoryModal(false)}
                    className="absolute top-4 right-4 text-slate-400 hover:text-white transition-colors"
                >
                    <X size={24} />
                </button>

                <h3 className="font-bold text-xl mb-6 text-white flex items-center gap-3">
                    <div className="p-2 bg-purple-500/20 rounded-lg">
                        <Calculator className="w-6 h-6 text-purple-400" />
                    </div>
                    {t.theoryTitle}
                </h3>
                
                <div className="space-y-5 text-sm leading-relaxed text-slate-300">
                    <div>
                        <p className="mb-2"><TextWithMath text={t.theoryP1} /></p>
                        <div className="p-3 bg-slate-900/50 rounded-lg text-center text-yellow-400 overflow-x-auto border border-slate-700/50">
                            <MathEquation tex="\tau = G \frac{Mm}{r^2} d" />
                        </div>
                    </div>
                    
                    <div>
                        <p className="mb-2"><TextWithMath text={t.theoryP2} /></p>
                        <div className="p-3 bg-slate-900/50 rounded-lg text-center text-yellow-400 overflow-x-auto border border-slate-700/50">
                            <MathEquation tex="\kappa \theta = \tau" />
                        </div>
                    </div>

                    <div className="pt-5 border-t border-slate-700">
                        <p className="font-semibold text-white mb-2 flex items-center gap-2">
                             <Lightbulb className="w-4 h-4 text-emerald-400" /> {t.opticalLever}
                        </p>
                        <p><TextWithMath text={t.opticalDesc} /></p>
                    </div>
                </div>
            </div>
        </div>
      )}

    </div>
  );
};

export default CavendishSim;