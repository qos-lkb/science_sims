<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>斯涅耳定律 - 折射率實驗</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- MathJax Configuration & Loader -->
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']] // Allow $...$ for inline math
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    <script type="text/javascript" id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
    </script>

    <style>
        body {
            font-family: 'Noto Sans TC', sans-serif;
            touch-action: manipulation; /* Improve touch handling on mobile */
        }
        input[type=range] {
            -webkit-appearance: none; 
            background: transparent; 
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
        }
        input[type=range]:focus {
            outline: none;
        }
        /* Custom slider styling for better visibility */
        .slider-thumb::-webkit-slider-thumb {
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #4F46E5;
            cursor: pointer;
            margin-top: -8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        .slider-track::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #E5E7EB;
            border-radius: 2px;
        }
        /* Fix for MathJax causing layout shifts or overflow in strict flex containers */
        mjx-container { 
            display: inline-grid;
            overflow: hidden;
        }
        /* Modal Animation Classes */
        .modal-active {
            opacity: 1 !important;
            pointer-events: auto !important;
        }
        .modal-content-active {
            transform: scale(1) !important;
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800 flex flex-col min-h-screen">

    <!-- Header -->
    <header class="bg-indigo-600 text-white p-4 shadow-lg relative z-20">
        <div class="max-w-7xl mx-auto flex justify-between items-center">
            <div class="flex items-center gap-3">
                <i class="fa-solid fa-rainbow text-2xl"></i>
                <div>
                    <h1 class="text-xl font-bold" data-i18n="title">斯涅耳定律虛擬實驗室</h1>
                    <p class="text-xs text-indigo-200" data-i18n="subtitle">測定透明介質的折射率 (Snell's Law)</p>
                </div>
            </div>
            
            <div class="flex items-center gap-3">
                <!-- Theory Button -->
                <button onclick="openTheoryModal()" class="bg-white/20 hover:bg-white/30 text-white px-3 py-1 rounded text-sm transition font-bold tracking-wide border border-white/30 backdrop-blur-sm flex items-center gap-1">
                    <i class="fa-solid fa-book-open"></i> <span data-i18n="btnTheory">原理</span>
                </button>

                <!-- Language Switcher -->
                <button onclick="toggleLanguage()" class="bg-indigo-500 hover:bg-indigo-400 px-3 py-1 rounded text-sm transition font-bold tracking-wide border border-indigo-400">
                    <i class="fa-solid fa-globe mr-1"></i> <span id="lang-display">中 / EN</span>
                </button>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-grow p-4 max-w-7xl mx-auto w-full grid grid-cols-1 lg:grid-cols-2 gap-6 relative z-0">
        
        <!-- Left Column: Simulation & Controls -->
        <div class="space-y-6">
            <!-- Canvas Container -->
            <div class="bg-white rounded-xl shadow-md p-1 overflow-hidden relative border border-gray-200">
                <div class="absolute top-4 left-4 bg-white/90 backdrop-blur p-2 rounded shadow text-sm z-10 pointer-events-none">
                    <div class="flex items-center gap-2 text-red-600 font-bold">
                        <span class="w-3 h-3 rounded-full bg-red-500 inline-block"></span>
                        <span data-i18n="lblI">入射角 ($i$)</span>: <span id="val-i">30.0</span>°
                    </div>
                    <div class="flex items-center gap-2 text-blue-600 font-bold mt-1">
                        <span class="w-3 h-3 rounded-full bg-blue-500 inline-block"></span>
                        <span data-i18n="lblR">折射角 ($r$)</span>: <span id="val-r">0.0</span>°
                    </div>
                </div>
                <canvas id="simCanvas" class="w-full h-auto bg-gray-50 block cursor-pointer" height="400" width="600"></canvas>
                <p class="text-center text-xs text-gray-400 py-1" data-i18n="hint">點擊或拖曳畫布可直接改變角度</p>
            </div>

            <!-- Controls -->
            <div class="bg-white rounded-xl shadow-md p-6 border border-gray-200">
                <h2 class="text-lg font-semibold mb-4 flex items-center gap-2">
                    <i class="fa-solid fa-sliders text-indigo-500"></i> <span data-i18n="ctrlTitle">實驗參數控制</span>
                </h2>
                
                <div class="space-y-6">
                    <!-- Incident Angle Slider -->
                    <div>
                        <div class="flex justify-between mb-2">
                            <label class="font-medium text-gray-700" data-i18n="ctrlAngle">入射角 ($i$)</label>
                            <span class="text-indigo-600 font-mono font-bold" id="display-angle">30°</span>
                        </div>
                        <input type="range" id="angleSlider" min="0" max="85" step="0.5" value="30" 
                            class="slider-thumb slider-track w-full appearance-none bg-transparent">
                        <div class="flex justify-between text-xs text-gray-400 mt-1">
                            <span data-i18n="txtNormal">0° (法線)</span>
                            <span>85°</span>
                        </div>
                    </div>

                    <!-- Refractive Index Slider -->
                    <div>
                        <div class="flex justify-between mb-2">
                            <label class="font-medium text-gray-700" data-i18n="ctrlN">透明介質折射率 ($n$)</label>
                            <span class="text-indigo-600 font-mono font-bold" id="display-ri">1.50</span>
                        </div>
                        <input type="range" id="nSlider" min="1.00" max="2.50" step="0.01" value="1.50" 
                            class="slider-thumb slider-track w-full appearance-none bg-transparent">
                        <div class="flex justify-between text-xs text-gray-400 mt-1">
                            <span data-i18n="txtAir">1.0 (空氣)</span>
                            <span data-i18n="txtGlass">1.5 (玻璃)</span>
                            <span data-i18n="txtDiamond">2.4 (鑽石)</span>
                        </div>
                    </div>

                    <!-- Action Buttons (Updated Layout) -->
                    <div class="pt-2 grid grid-cols-2 gap-3">
                        <button onclick="recordData()" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg shadow transition flex items-center justify-center gap-2 active:scale-95">
                            <i class="fa-solid fa-plus-circle"></i> <span data-i18n="btnRecord">記錄數據點</span>
                        </button>
                        <button onclick="resetExperiment()" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-4 rounded-lg shadow transition flex items-center justify-center gap-2 active:scale-95">
                            <i class="fa-solid fa-rotate-right"></i> <span data-i18n="btnReset">重置實驗</span>
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right Column: Analysis -->
        <div class="space-y-6">
            
            <!-- Graph Section -->
            <div class="bg-white rounded-xl shadow-md p-4 border border-gray-200">
                <h2 class="text-lg font-semibold mb-2 flex items-center gap-2">
                    <i class="fa-solid fa-chart-line text-indigo-500"></i> <span data-i18n="graphTitle">$\sin(i)$ 對 $\sin(r)$ 關係圖</span>
                </h2>
                <div class="relative w-full h-64 bg-white border border-gray-100 rounded">
                    <canvas id="graphCanvas" class="w-full h-full block"></canvas>
                </div>
                <div class="mt-4 p-4 bg-indigo-50 rounded-lg border border-indigo-100 flex flex-col sm:flex-row justify-between items-center gap-4">
                    <div class="text-center sm:text-left">
                        <p class="text-sm text-gray-600" data-i18n="slope">最佳擬合直線斜率 (Slope)</p>
                        <p class="text-2xl font-bold text-indigo-700" id="slopeValue">--</p>
                    </div>
                    <div class="text-center sm:text-right">
                        <p class="text-sm text-gray-600" data-i18n="calcN">計算得出的折射率 ($n$)</p>
                        <p class="text-2xl font-bold text-green-600" id="calcN">--</p>
                    </div>
                </div>
                <div class="text-xs text-gray-500 mt-2 text-center bg-gray-50 p-2 rounded" id="theoryBlock" data-i18n-html="theory">
                    <!-- Default Theory Block (visible under graph) -->
                    <p class="mb-1 font-semibold">理論依據:</p>
                    <p>$$n_1 \sin(i) = n_2 \sin(r)$$</p>
                    <p>設 $n_1=1$ (空氣)，則 $\sin(i) = n \sin(r)$。</p>
                    <p class="mt-1">$$m = \frac{\Delta \sin(i)}{\Delta \sin(r)} \approx n$$</p>
                </div>
            </div>

            <!-- Data Table -->
            <div class="bg-white rounded-xl shadow-md p-6 border border-gray-200 overflow-hidden">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-lg font-semibold flex items-center gap-2">
                        <i class="fa-solid fa-table text-indigo-500"></i> <span data-i18n="tableTitle">實驗數據表</span>
                    </h2>
                    <button onclick="clearData()" class="text-sm text-red-500 hover:text-red-700 font-medium">
                        <i class="fa-solid fa-trash"></i> <span data-i18n="btnClear">清除數據</span>
                    </button>
                </div>
                <div class="overflow-x-auto">
                    <table class="min-w-full text-sm text-left text-gray-500">
                        <thead class="text-xs text-gray-700 uppercase bg-gray-100">
                            <tr>
                                <th scope="col" class="px-4 py-3 rounded-tl-lg">#</th>
                                <th scope="col" class="px-4 py-3">$i$ (°)</th>
                                <th scope="col" class="px-4 py-3">$r$ (°)</th>
                                <th scope="col" class="px-4 py-3 bg-blue-50 text-blue-700">$\sin(i)$ (y)</th>
                                <th scope="col" class="px-4 py-3 bg-green-50 text-green-700 rounded-tr-lg">$\sin(r)$ (x)</th>
                            </tr>
                        </thead>
                        <tbody id="dataTableBody">
                            <!-- Data rows will appear here -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </main>

    <!-- Theory Modal -->
    <div id="theoryModal" class="fixed inset-0 bg-gray-900/60 backdrop-blur-sm hidden items-center justify-center z-50 opacity-0 transition-opacity duration-300" onclick="if(event.target === this) closeTheoryModal()">
        <div id="theoryModalContent" class="bg-white rounded-xl shadow-2xl max-w-lg w-full m-4 p-8 transform scale-95 transition-transform duration-300 relative border border-indigo-100">
            <!-- Close Button -->
            <button onclick="closeTheoryModal()" class="absolute top-4 right-4 text-gray-400 hover:text-red-500 transition p-2">
                <i class="fa-solid fa-xmark text-xl"></i>
            </button>
            
            <!-- Header -->
            <div class="flex items-center gap-3 mb-6 border-b border-gray-100 pb-4">
                <div class="bg-indigo-100 p-2 rounded-lg text-indigo-600">
                    <i class="fa-solid fa-book-open text-xl"></i>
                </div>
                <h3 class="text-2xl font-bold text-gray-800" data-i18n="modalTitle">實驗原理解說</h3>
            </div>

            <!-- Content -->
            <div class="space-y-4 text-gray-600 leading-relaxed max-h-[60vh] overflow-y-auto pr-2" data-i18n-html="modalContent">
                <!-- Content injected by JS -->
            </div>

            <!-- Footer -->
            <div class="mt-8 pt-4 border-t border-gray-100 text-right">
                <button onclick="closeTheoryModal()" class="bg-indigo-600 hover:bg-indigo-700 text-white px-6 py-2 rounded-lg transition font-medium shadow-md active:scale-95">
                    <span data-i18n="btnClose">明白</span>
                </button>
            </div>
        </div>
    </div>

    <footer class="text-center p-4 text-gray-400 text-xs" data-i18n="footer">
        &copy; 2023 物理實驗室教學工具
    </footer>

    <script>
        // Math Utilities
        const degToRad = (deg) => deg * (Math.PI / 180);
        const radToDeg = (rad) => rad * (180 / Math.PI);

        // State
        let state = {
            angleIncident: 30,
            refractiveIndex: 1.5,
            dataPoints: [] // { i, r, sinI, sinR }
        };

        // Interaction State
        let isDragging = false; 
        let currentLang = 'zh';

        // Translation Data
        const i18n = {
            zh: {
                title: "斯涅耳定律虛擬實驗室",
                subtitle: "測定透明介質的折射率 (Snell's Law)",
                lblI: "入射角 ($i$)",
                lblR: "折射角 ($r$)",
                hint: "點擊或拖曳畫布可直接改變角度",
                ctrlTitle: "實驗參數控制",
                ctrlAngle: "入射角 ($i$)",
                ctrlN: "透明介質折射率 ($n$)",
                txtNormal: "0° (法線)",
                txtAir: "1.0 (空氣)",
                txtGlass: "1.5 (玻璃)",
                txtDiamond: "2.4 (鑽石)",
                btnRecord: "記錄數據點",
                btnReset: "重置實驗",
                graphTitle: "$\\sin(i)$ 對 $\\sin(r)$ 關係圖",
                slope: "最佳擬合直線斜率 (Slope)",
                calcN: "計算得出的折射率 ($n$)",
                theory: `<p class="mb-1 font-semibold">理論依據:</p><p>$$n_1 \\sin(i) = n_2 \\sin(r)$$</p><p>設 $n_1=1$ (空氣)，則 $\\sin(i) = n \\sin(r)$。</p><p class="mt-1">$$m = \\frac{\\Delta \\sin(i)}{\\Delta \\sin(r)} \\approx n$$</p>`,
                tableTitle: "實驗數據表",
                btnClear: "清除數據",
                emptyTable: "尚未記錄數據。調整角度並點擊「記錄數據點」。",
                footer: "&copy; 2023 物理實驗室教學工具",
                
                // Modal
                btnTheory: "原理",
                modalTitle: "實驗原理解說",
                modalContent: `
                    <p class="font-bold text-gray-800 text-lg border-b border-gray-200 pb-1 mb-2">1. 斯涅耳定律 (Snell's Law)</p>
                    <p>當光線從介質 1 進入介質 2 時，入射角 $\\theta_1$ 與折射角 $\\theta_2$ 的關係如下：</p>
                    <div class="bg-indigo-50 p-3 rounded text-center my-3 border border-indigo-100">
                        $$n_1 \\sin(\\theta_1) = n_2 \\sin(\\theta_2)$$
                    </div>
                    <ul class="list-disc pl-5 space-y-1 text-sm bg-gray-50 p-3 rounded mb-4">
                        <li>$n_1$：介質 1 (空氣) 的折射率，通常約為 1.00。</li>
                        <li>$n_2$：介質 2 (半圓形透明塊) 的折射率。</li>
                        <li>$\\theta_1$：入射角 $i$ (相對於法線)。</li>
                        <li>$\\theta_2$：折射角 $r$ (相對於法線)。</li>
                    </ul>

                    <p class="font-bold text-gray-800 text-lg border-b border-gray-200 pb-1 mb-2 mt-6">2. 實驗目的與圖表分析</p>
                    <p>將公式重寫，假設光從空氣 ($n_1 \\approx 1$) 進入介質：</p>
                    <p class="text-center my-1">$$1 \\cdot \\sin(i) = n \\cdot \\sin(r) \\implies \\sin(i) = n \\cdot \\sin(r)$$</p>
                    <p class="mt-2">這符合直線方程 <span class="font-mono text-indigo-600 font-bold">y = m ⋅ x</span> 的形式：</p>
                    <ul class="list-disc pl-5 space-y-1 text-sm mt-2">
                        <li>Y 軸 ($y$)：$\\sin(i)$</li>
                        <li>X 軸 ($x$)：$\\sin(r)$</li>
                        <li>斜率 ($m$)：折射率 $n$</li>
                    </ul>
                    <p class="mt-2">因此，通過測量多組 $i$ 和 $r$，繪製關係圖並找出最佳擬合直線的<strong>斜率</strong>，即可求得透明塊的折射率。</p>
                    
                    <p class="font-bold text-gray-800 text-lg border-b border-gray-200 pb-1 mb-2 mt-6">3. 為什麼使用半圓形玻璃塊？</p>
                    <div class="flex gap-4 items-start">
                        <div class="flex-1">
                            <p>光線從上方的平直面進入玻璃塊時發生折射。但當光線從玻璃塊底部的<strong>圓弧面射出</strong>時，因為光線是沿著半徑方向行進的，這意味著光線與曲面邊界<strong>垂直</strong> (入射角為 0°)。</p>
                            <p class="mt-2 text-sm text-gray-600 bg-yellow-50 p-2 rounded border border-yellow-100"><i class="fa-solid fa-lightbulb text-yellow-500 mr-1"></i> 關鍵點：光線在離開圓弧面時<strong>不發生偏折</strong>。這讓我們能直接測量光線在玻璃內部的行進角度作為折射角 $r$。</p>
                        </div>
                    </div>

                    <p class="font-bold text-gray-800 text-lg border-b border-gray-200 pb-1 mb-2 mt-6">4. 折射率的物理意義</p>
                    <p>折射率 $n$ 不僅決定光線偏折的程度，還代表光在真空中的速度 $c$ 與在該介質中的速度 $v$ 的比值：</p>
                    <div class="text-center my-2">
                        $$n = \\frac{c}{v}$$
                    </div>
                    <p class="text-sm text-gray-600">由於光在介質中速度總是小於真空光速 ($v < c$)，所以折射率 $n$ 總是大多於 1。</p>
                `,
                btnClose: "明白"
            },
            en: {
                title: "Snell's Law Virtual Lab",
                subtitle: "Refractive Index Experiment",
                lblI: "Incident Angle ($i$)",
                lblR: "Refracted Angle ($r$)",
                hint: "Click or drag canvas to change angle",
                ctrlTitle: "Controls",
                ctrlAngle: "Incident Angle ($i$)",
                ctrlN: "Refractive Index ($n$)",
                txtNormal: "0° (Normal)",
                txtAir: "1.0 (Air)",
                txtGlass: "1.5 (Glass)",
                txtDiamond: "2.4 (Diamond)",
                btnRecord: "Record Data",
                btnReset: "Reset",
                graphTitle: "Graph of $\\sin(i)$ vs $\\sin(r)$",
                slope: "Best Fit Slope",
                calcN: "Calculated Index ($n$)",
                theory: `<p class="mb-1 font-semibold">Theory:</p><p>$$n_1 \\sin(i) = n_2 \\sin(r)$$</p><p>Let $n_1=1$ (Air), then $\\sin(i) = n \\sin(r)$。</p><p class="mt-1">$$m = \\frac{\\Delta \\sin(i)}{\\Delta \\sin(r)} \\approx n$$</p>`,
                tableTitle: "Data Table",
                btnClear: "Clear Data",
                emptyTable: "No data recorded. Adjust angle and click 'Record Data'.",
                footer: "&copy; 2023 Physics Lab Tools",
                
                // Modal
                btnTheory: "Theory",
                modalTitle: "Principle Explanation",
                modalContent: `
                    <p class="font-bold text-gray-800 text-lg border-b border-gray-200 pb-1 mb-2">1. Snell's Law</p>
                    <p>The relationship between the angle of incidence $\\theta_1$ and the angle of refraction $\\theta_2$ when light passes from medium 1 to medium 2 is given by:</p>
                    <div class="bg-indigo-50 p-3 rounded text-center my-3 border border-indigo-100">
                        $$n_1 \\sin(\\theta_1) = n_2 \\sin(\\theta_2)$$
                    </div>
                    <ul class="list-disc pl-5 space-y-1 text-sm bg-gray-50 p-3 rounded mb-4">
                        <li>$n_1$: Refractive index of medium 1 (Air), approx 1.00.</li>
                        <li>$n_2$: Refractive index of medium 2 (Block).</li>
                        <li>$\\theta_1$: Angle of incidence $i$ (relative to normal).</li>
                        <li>$\\theta_2$: Angle of refraction $r$ (relative to normal).</li>
                    </ul>

                    <p class="font-bold text-gray-800 text-lg border-b border-gray-200 pb-1 mb-2 mt-6">2. Experiment Goal & Graph Analysis</p>
                    <p>Rewriting the formula for air ($n_1 \\approx 1$) to medium:</p>
                    <p class="text-center my-1">$$1 \\cdot \\sin(i) = n \\cdot \\sin(r) \\implies \\sin(i) = n \\cdot \\sin(r)$$</p>
                    <p class="mt-2">This matches the linear equation form <span class="font-mono text-indigo-600 font-bold">y = m ⋅ x</span>:</p>
                    <ul class="list-disc pl-5 space-y-1 text-sm mt-2">
                        <li>Y-axis ($y$): $\\sin(i)$</li>
                        <li>X-axis ($x$): $\\sin(r)$</li>
                        <li>Slope ($m$): Refractive Index $n$</li>
                    </ul>
                    <p class="mt-2">By measuring multiple pairs of $i$ and $r$, plotting the graph, and finding the slope of the best-fit line, we can determine $n$.</p>
                    
                    <p class="font-bold text-gray-800 text-lg border-b border-gray-200 pb-1 mb-2 mt-6">3. Why use a Semicircular Block?</p>
                    <div class="flex gap-4 items-start">
                        <div class="flex-1">
                            <p>Refraction occurs when light enters the flat top surface. However, when light exits through the <strong>curved bottom surface</strong>, it travels along the radius. This means the light hits the boundary <strong>perpendicularly</strong> (angle of incidence is 0°).</p>
                            <p class="mt-2 text-sm text-gray-600 bg-yellow-50 p-2 rounded border border-yellow-100"><i class="fa-solid fa-lightbulb text-yellow-500 mr-1"></i> Key Point: <strong>No refraction</strong> occurs at the curved exit. This allows us to measure the angle inside the glass directly.</p>
                        </div>
                    </div>

                    <p class="font-bold text-gray-800 text-lg border-b border-gray-200 pb-1 mb-2 mt-6">4. Physical Meaning of Refractive Index</p>
                    <p>The refractive index $n$ is defined as the ratio of the speed of light in a vacuum $c$ to the speed of light in the medium $v$:</p>
                    <div class="text-center my-2">
                        $$n = \\frac{c}{v}$$
                    </div>
                    <p class="text-sm text-gray-600">Since light travels slower in a medium than in a vacuum ($v < c$), $n$ is always greater than 1.</p>
                `,
                btnClose: "Close"
            }
        };

        // DOM Elements
        const simCanvas = document.getElementById('simCanvas');
        const simCtx = simCanvas.getContext('2d');
        const graphCanvas = document.getElementById('graphCanvas');
        const graphCtx = graphCanvas.getContext('2d');
        
        const angleSlider = document.getElementById('angleSlider');
        const nSlider = document.getElementById('nSlider');
        const displayAngle = document.getElementById('display-angle');
        const displayRI = document.getElementById('display-ri');
        const valI = document.getElementById('val-i');
        const valR = document.getElementById('val-r');
        const slopeValue = document.getElementById('slopeValue');
        const calcNElement = document.getElementById('calcN'); // Renamed to avoid ID conflict in updating text
        const dataTableBody = document.getElementById('dataTableBody');
        const langDisplay = document.getElementById('lang-display');
        
        // Modal Elements
        const theoryModal = document.getElementById('theoryModal');
        const theoryModalContent = document.getElementById('theoryModalContent');

        // Init
        function init() {
            resizeCanvases();
            window.addEventListener('resize', resizeCanvases);
            
            angleSlider.addEventListener('input', (e) => {
                state.angleIncident = parseFloat(e.target.value);
                updateSimulation();
            });

            nSlider.addEventListener('input', (e) => {
                state.refractiveIndex = parseFloat(e.target.value);
                updateSimulation();
            });

            // Interactive Canvas
            simCanvas.addEventListener('mousedown', startDrag);
            simCanvas.addEventListener('touchstart', startDrag, {passive: false});
            
            window.addEventListener('mousemove', doDrag);
            window.addEventListener('touchmove', doDrag, {passive: false});
            
            window.addEventListener('mouseup', endDrag);
            window.addEventListener('touchend', endDrag);

            updateTable(); // Initialize empty row
            updateSimulation();
            updateGraph();
        }

        // Modal Logic
        function openTheoryModal() {
            theoryModal.classList.remove('hidden');
            theoryModal.classList.add('flex');
            // Small timeout to allow display:flex to apply before opacity transition
            setTimeout(() => {
                theoryModal.classList.add('modal-active');
                theoryModalContent.classList.add('modal-content-active');
            }, 10);
        }

        function closeTheoryModal() {
            theoryModal.classList.remove('modal-active');
            theoryModalContent.classList.remove('modal-content-active');
            
            // Wait for transition to finish before hiding
            setTimeout(() => {
                theoryModal.classList.remove('flex');
                theoryModal.classList.add('hidden');
            }, 300);
        }

        // Language Logic
        function toggleLanguage() {
            currentLang = currentLang === 'zh' ? 'en' : 'zh';
            // langDisplay.textContent = currentLang === 'zh' ? 'EN' : '中'; // Removed dynamic text update
            applyLanguage();
        }

        function applyLanguage() {
            const t = i18n[currentLang];
            
            // Text Content
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                if (t[key]) el.textContent = t[key];
            });

            // HTML Content (For Theory & Modal)
            document.querySelectorAll('[data-i18n-html]').forEach(el => {
                const key = el.getAttribute('data-i18n-html');
                if (t[key]) el.innerHTML = t[key];
            });

            // Refresh Table Empty Message
            if (state.dataPoints.length === 0) {
                updateTable();
            }

            // Re-render LaTeX
            if (window.MathJax) {
                MathJax.typesetPromise();
            }

            // Redraw Canvases (if they used lang-specific text, though mostly symbols here)
            updateSimulation();
            updateGraph();
        }

        function resizeCanvases() {
            // Make canvas crisp on high DPI screens
            const dpr = window.devicePixelRatio || 1;
            
            // Sim Canvas
            const simRect = simCanvas.parentElement.getBoundingClientRect();
            simCanvas.width = simRect.width * dpr;
            simCanvas.height = 400 * dpr;
            simCtx.scale(dpr, dpr);
            simCanvas.style.width = `${simRect.width}px`;
            simCanvas.style.height = `400px`;

            // Graph Canvas
            const graphRect = graphCanvas.parentElement.getBoundingClientRect();
            graphCanvas.width = graphRect.width * dpr;
            graphCanvas.height = 256 * dpr; // h-64
            graphCtx.scale(dpr, dpr);
            graphCanvas.style.width = `${graphRect.width}px`;
            graphCanvas.style.height = `256px`;

            updateSimulation();
            updateGraph();
        }

        // Simulation Logic
        function updateSimulation() {
            const width = simCanvas.width / (window.devicePixelRatio || 1);
            const height = simCanvas.height / (window.devicePixelRatio || 1);
            const centerX = width / 2;
            const centerY = height / 2 + 50;
            const radius = 140;

            // Clear
            simCtx.clearRect(0, 0, width, height);

            // Physics Calc
            const n1 = 1.0;
            const n2 = state.refractiveIndex;
            const thetaI = degToRad(state.angleIncident);
            const sinR = (n1 / n2) * Math.sin(thetaI);
            const thetaR = Math.asin(sinR);
            const angleR_deg = radToDeg(thetaR);

            // Update UI Text
            displayAngle.textContent = state.angleIncident.toFixed(1) + "°";
            displayRI.textContent = state.refractiveIndex.toFixed(2);
            valI.textContent = state.angleIncident.toFixed(1);
            valR.textContent = angleR_deg.toFixed(1);

            // Draw Semi-Circle Block
            simCtx.beginPath();
            simCtx.arc(centerX, centerY, radius, 0, Math.PI); 
            simCtx.closePath(); 
            simCtx.fillStyle = 'rgba(199, 210, 254, 0.5)'; 
            simCtx.fill();
            simCtx.strokeStyle = '#4F46E5';
            simCtx.lineWidth = 2;
            simCtx.stroke();

            // Draw Normal Line (Dashed)
            simCtx.beginPath();
            simCtx.setLineDash([5, 5]);
            simCtx.moveTo(centerX, centerY - radius - 20);
            simCtx.lineTo(centerX, centerY + radius + 20);
            simCtx.strokeStyle = '#6B7280';
            simCtx.lineWidth = 1;
            simCtx.stroke();
            simCtx.setLineDash([]);

            // --- Draw Angle Arcs ---
            const arcRadius = 50;

            // Incident Angle Arc (i) - Red
            if (state.angleIncident > 1) { 
                simCtx.beginPath();
                simCtx.arc(centerX, centerY, arcRadius, 1.5 * Math.PI - thetaI, 1.5 * Math.PI);
                simCtx.strokeStyle = '#EF4444'; 
                simCtx.lineWidth = 2;
                simCtx.stroke();
                simCtx.fillStyle = 'rgba(239, 68, 68, 0.15)';
                simCtx.lineTo(centerX, centerY);
                simCtx.fill();
            }

            // Refracted Angle Arc (r) - Blue
            if (angleR_deg > 1) {
                simCtx.beginPath();
                simCtx.arc(centerX, centerY, arcRadius, 0.5 * Math.PI - thetaR, 0.5 * Math.PI);
                simCtx.strokeStyle = '#2563EB'; 
                simCtx.lineWidth = 2;
                simCtx.stroke();
                simCtx.fillStyle = 'rgba(37, 99, 235, 0.15)';
                simCtx.lineTo(centerX, centerY);
                simCtx.fill();
            }

            // Draw Incident Ray (Air)
            const rayLength = radius + 40;
            const incX = centerX - rayLength * Math.sin(thetaI);
            const incY = centerY - rayLength * Math.cos(thetaI);

            simCtx.beginPath();
            simCtx.moveTo(incX, incY);
            simCtx.lineTo(centerX, centerY);
            simCtx.strokeStyle = '#EF4444'; // Red
            simCtx.lineWidth = 3;
            simCtx.stroke();

            // Arrow on Incident
            drawArrow(simCtx, incX, incY, centerX, centerY, '#EF4444');

            // Draw Refracted Ray (Block)
            const refX = centerX + radius * Math.sin(thetaR);
            const refY = centerY + radius * Math.cos(thetaR); 

            simCtx.beginPath();
            simCtx.moveTo(centerX, centerY);
            simCtx.lineTo(refX, refY);
            simCtx.strokeStyle = '#2563EB'; // Blue
            simCtx.lineWidth = 3;
            simCtx.stroke();

            // Arrow on Refracted
            drawArrow(simCtx, centerX, centerY, refX, refY, '#2563EB');

            // Draw Labels
            simCtx.font = "bold 16px sans-serif";
            simCtx.textAlign = "center";
            simCtx.textBaseline = "middle";
            
            // Label i
            const labelDist = 75;
            const angleIPos = 1.5 * Math.PI - thetaI / 2;
            simCtx.fillStyle = "#EF4444";
            simCtx.fillText("i", centerX + labelDist * Math.cos(angleIPos), centerY + labelDist * Math.sin(angleIPos));
            
            // Label r
            const angleRPos = 0.5 * Math.PI - thetaR / 2;
            simCtx.fillStyle = "#2563EB";
            simCtx.fillText("r", centerX + labelDist * Math.cos(angleRPos), centerY + labelDist * Math.sin(angleRPos));

            simCtx.textAlign = "left";
            simCtx.textBaseline = "alphabetic";

            simCtx.fillStyle = "#374151";
            simCtx.fillText(`n = ${state.refractiveIndex.toFixed(2)}`, centerX + radius - 70, centerY + 30);
        }

        function drawArrow(ctx, fromX, fromY, toX, toY, color) {
            const headlen = 10;
            const dx = toX - fromX;
            const dy = toY - fromY;
            const angle = Math.atan2(dy, dx);
            const midX = (fromX + toX) / 2;
            const midY = (fromY + toY) / 2;

            ctx.beginPath();
            ctx.moveTo(midX, midY);
            ctx.lineTo(midX - headlen * Math.cos(angle - Math.PI / 6), midY - headlen * Math.sin(angle - Math.PI / 6));
            ctx.moveTo(midX, midY);
            ctx.lineTo(midX - headlen * Math.cos(angle + Math.PI / 6), midY - headlen * Math.sin(angle + Math.PI / 6));
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.stroke();
        }

        // Interaction
        function startDrag(e) {
            const rect = simCanvas.getBoundingClientRect();
            const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
            const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
            
            if (y < 400/2 + 50) {
                isDragging = true;
                updateAngleFromMouse(x, y);
            }
        }

        function doDrag(e) {
            if (!isDragging) return;
            e.preventDefault(); 
            const rect = simCanvas.getBoundingClientRect();
            const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
            const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
            updateAngleFromMouse(x, y);
        }

        function endDrag() {
            isDragging = false;
        }

        function updateAngleFromMouse(x, y) {
            const width = simCanvas.getBoundingClientRect().width;
            const height = 400;
            const centerX = width / 2;
            const centerY = height / 2 + 50;

            let dx = centerX - x; 
            let dy = centerY - y; 

            if (dy < 0) return; 

            let angleRad = Math.atan2(dx, dy);
            let angleDeg = radToDeg(angleRad);

            if (angleDeg < 0) angleDeg = 0;
            if (angleDeg > 85) angleDeg = 85;

            state.angleIncident = angleDeg;
            angleSlider.value = angleDeg;
            updateSimulation();
        }

        // Data Logic
        function recordData() {
            const i = state.angleIncident;
            const r_rad = Math.asin((1 / state.refractiveIndex) * Math.sin(degToRad(i)));
            const r = radToDeg(r_rad);

            const sinI = Math.sin(degToRad(i));
            const sinR = Math.sin(r_rad);

            const newData = {
                id: Date.now(),
                i: i,
                r: r,
                sinI: sinI,
                sinR: sinR
            };

            state.dataPoints.push(newData);
            state.dataPoints.sort((a, b) => a.i - b.i);

            updateTable();
            updateGraph();
        }

        function clearData() {
            state.dataPoints = [];
            updateTable();
            updateGraph();
            slopeValue.textContent = "--";
            calcNElement.textContent = "--";
        }

        function updateTable() {
            dataTableBody.innerHTML = "";
            if (state.dataPoints.length === 0) {
                const emptyMsg = i18n[currentLang].emptyTable;
                dataTableBody.innerHTML = `
                    <tr class="border-b hover:bg-gray-50">
                        <td colspan="5" class="px-4 py-4 text-center text-gray-400 italic">
                            ${emptyMsg}
                        </td>
                    </tr>`;
                return;
            }

            state.dataPoints.forEach((pt, index) => {
                const row = document.createElement('tr');
                row.className = "border-b hover:bg-gray-50 transition";
                row.innerHTML = `
                    <td class="px-4 py-3 font-medium text-gray-900">${index + 1}</td>
                    <td class="px-4 py-3">${pt.i.toFixed(1)}°</td>
                    <td class="px-4 py-3">${pt.r.toFixed(1)}°</td>
                    <td class="px-4 py-3 bg-blue-50 text-blue-700 font-mono">${pt.sinI.toFixed(3)}</td>
                    <td class="px-4 py-3 bg-green-50 text-green-700 font-mono">${pt.sinR.toFixed(3)}</td>
                `;
                dataTableBody.appendChild(row);
            });
            
            if(window.MathJax) {
                MathJax.typesetPromise([dataTableBody]);
            }
        }

        function resetExperiment() {
            clearData();
            state.angleIncident = 30;
            state.refractiveIndex = 1.5;
            angleSlider.value = 30;
            nSlider.value = 1.5;
            updateSimulation();
        }

        // Graphing & Regression
        function updateGraph() {
            const width = graphCanvas.width / (window.devicePixelRatio || 1);
            const height = graphCanvas.height / (window.devicePixelRatio || 1);
            graphCtx.clearRect(0, 0, width, height);

            const padLeft = 50;
            const padBottom = 40;
            const padRight = 50; 
            const padTop = 35;
            const gW = width - padLeft - padRight;
            const gH = height - padTop - padBottom;

            // Draw Axes Lines
            graphCtx.beginPath();
            graphCtx.strokeStyle = '#9CA3AF';
            graphCtx.lineWidth = 2;
            
            graphCtx.moveTo(padLeft, height - padBottom);
            graphCtx.lineTo(padLeft, padTop);
            
            graphCtx.moveTo(padLeft, height - padBottom);
            graphCtx.lineTo(width - padRight, height - padBottom);
            graphCtx.stroke();

            // Draw Arrow Heads
            graphCtx.beginPath();
            const headLen = 8;
            
            graphCtx.moveTo(padLeft, padTop);
            graphCtx.lineTo(padLeft - 5, padTop + headLen);
            graphCtx.moveTo(padLeft, padTop);
            graphCtx.lineTo(padLeft + 5, padTop + headLen);

            const xEnd = width - padRight;
            const yEnd = height - padBottom;
            graphCtx.moveTo(xEnd, yEnd);
            graphCtx.lineTo(xEnd - headLen, yEnd - 5);
            graphCtx.moveTo(xEnd, yEnd);
            graphCtx.lineTo(xEnd - headLen, yEnd + 5);
            graphCtx.stroke();

            // Labels
            graphCtx.fillStyle = '#374151';
            graphCtx.font = "bold 14px sans-serif";
            
            graphCtx.textAlign = "left";
            graphCtx.fillText("sin(r)", xEnd + 8, yEnd + 4);
            
            graphCtx.textAlign = "center";
            graphCtx.fillText("sin(i)", padLeft, padTop - 10);

            // Updated Scales: Max 1.0 for both
            const maxX = 1.0;
            const maxY = 1.0;

            const d2pX = (val) => padLeft + (val / maxX) * gW;
            const d2pY = (val) => height - padBottom - (val / maxY) * gH;

            // Grid Lines & Numeric Labels (Step 0.1)
            graphCtx.strokeStyle = '#E5E7EB';
            graphCtx.lineWidth = 1;
            graphCtx.fillStyle = '#6B7280'; // Gray for numbers
            graphCtx.font = "10px sans-serif";
            
            // Draw Grid Lines first
            graphCtx.beginPath();
            for(let i=0.1; i<=1.05; i+=0.1) {
                let val = Math.round(i * 10) / 10;
                if(val > 1.0) break;

                // Horizontal Line
                let y = d2pY(val);
                graphCtx.moveTo(padLeft, y);
                graphCtx.lineTo(width - padRight, y);

                // Vertical Line
                let x = d2pX(val);
                graphCtx.moveTo(x, height - padBottom);
                graphCtx.lineTo(x, padTop);
            }
            graphCtx.stroke();

            // Draw Numeric Labels
            for(let i=0.0; i<=1.05; i+=0.1) {
                let val = Math.round(i * 10) / 10;
                if(val > 1.0) break;

                // Y Axis Labels (skip 0 to avoid clutter)
                if (val > 0) {
                    graphCtx.textAlign = "right";
                    graphCtx.textBaseline = "middle";
                    graphCtx.fillText(val.toFixed(1), padLeft - 8, d2pY(val));
                } else {
                    graphCtx.textAlign = "right";
                    graphCtx.textBaseline = "middle";
                    graphCtx.fillText("0", padLeft - 8, d2pY(val));
                }

                // X Axis Labels
                graphCtx.textAlign = "center";
                graphCtx.textBaseline = "top";
                graphCtx.fillText(val.toFixed(1), d2pX(val), height - padBottom + 8);
            }

            // Draw Points
            if (state.dataPoints.length > 0) {
                state.dataPoints.forEach(pt => {
                    const px = d2pX(pt.sinR);
                    const py = d2pY(pt.sinI);

                    graphCtx.beginPath();
                    graphCtx.arc(px, py, 4, 0, Math.PI * 2);
                    graphCtx.fillStyle = '#DC2626'; // Red dots
                    graphCtx.fill();
                });

                // Regression
                let sumXY = 0;
                let sumXX = 0;
                state.dataPoints.forEach(pt => {
                    sumXY += pt.sinR * pt.sinI;
                    sumXX += pt.sinR * pt.sinR;
                });

                if (sumXX > 0) {
                    const slope = sumXY / sumXX;
                    
                    graphCtx.beginPath();
                    graphCtx.moveTo(d2pX(0), d2pY(0));
                    let endX = maxX;
                    let endY = slope * endX;
                    if (endY > maxY) {
                        endY = maxY;
                        endX = endY / slope;
                    }
                    
                    graphCtx.lineTo(d2pX(endX), d2pY(endY));
                    graphCtx.strokeStyle = '#10B981'; // Green line
                    graphCtx.lineWidth = 2;
                    graphCtx.stroke();

                    slopeValue.textContent = slope.toFixed(3);
                    calcNElement.textContent = slope.toFixed(3);
                }
            }
        }

        // Start
        init();

    </script>
</body>
</html>