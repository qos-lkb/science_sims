<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>物理光學模擬：透鏡成像</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <style>
        body {
            font-family: 'Noto Sans TC', sans-serif;
            height: 100dvh; 
            touch-action: none;
            overscroll-behavior: none;
        }
        canvas {
            cursor: grab;
            touch-action: none;
        }
        canvas:active {
            cursor: grabbing;
        }
        .custom-scrollbar::-webkit-scrollbar { width: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #f1f1f1; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        
        /* Modal Animation */
        .modal-enter { opacity: 0; transform: scale(0.95); }
        .modal-enter-active { opacity: 1; transform: scale(1); transition: opacity 300ms, transform 300ms; }
        .modal-exit { opacity: 1; transform: scale(1); }
        .modal-exit-active { opacity: 0; transform: scale(0.95); transition: opacity 200ms, transform 200ms; }
        
        /* Table Styles */
        .case-table th, .case-table td {
            padding: 8px;
            border-bottom: 1px solid #e2e8f0;
            text-align: left;
        }
        .case-table th {
            background-color: #f8fafc;
            font-weight: 600;
            color: #475569;
        }
        .case-table tr:last-child td {
            border-bottom: none;
        }
    </style>
</head>
<body class="bg-slate-100 flex flex-col overflow-hidden text-slate-800">

    <!-- Header -->
    <header class="bg-blue-600 text-white p-3 shadow-md z-30 flex justify-between items-center shrink-0">
        <div class="flex items-center gap-2 overflow-hidden">
            <h1 class="text-lg md:text-xl font-bold truncate whitespace-nowrap" data-i18n="appTitle">
                物理光學模擬
            </h1>
        </div>
        
        <div class="flex items-center gap-2">
            <button onclick="toggleTheory()" class="bg-blue-500 hover:bg-blue-400 text-white text-xs md:text-sm px-3 py-1.5 rounded-lg border border-blue-400 transition-colors flex items-center gap-1">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12.01" y2="8"/></svg>
                <span data-i18n="btnTheory">原理</span>
            </button>
            
            <!-- Cases Button (New) -->
            <button onclick="toggleCases()" class="bg-blue-500 hover:bg-blue-400 text-white text-xs md:text-sm px-3 py-1.5 rounded-lg border border-blue-400 transition-colors flex items-center gap-1">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>
                <span data-i18n="btnCases">成像列表</span>
            </button>

            <button onclick="toggleLanguage()" class="bg-blue-700 hover:bg-blue-800 text-white text-xs md:text-sm px-3 py-1.5 rounded-lg border border-blue-600 transition-colors font-medium w-auto min-w-[5rem] text-center">
                <span id="lang-display">中 / Eng</span>
            </button>
        </div>
    </header>

    <!-- Main Content -->
    <div class="flex-1 relative flex flex-col lg:flex-row overflow-hidden">
        
        <!-- Canvas -->
        <div class="flex-1 relative bg-white overflow-hidden touch-none" id="canvas-container">
            <canvas id="opticsCanvas" class="block w-full h-full"></canvas>
            
            <div class="absolute top-3 right-3 bg-white/95 p-2.5 rounded-lg shadow-lg text-xs md:text-sm border border-gray-200 pointer-events-none select-none z-10">
                <div class="font-bold mb-1.5 border-b pb-1 text-gray-700" data-i18n="imgNature">成像性質</div>
                <div id="image-nature" class="space-y-1">
                    <p class="flex items-center"><span class="inline-block w-2.5 h-2.5 bg-orange-500 rounded-full mr-2"></span><span id="status-type">實像</span></p>
                    <p class="flex items-center"><span class="inline-block w-2.5 h-2.5 bg-gray-500 rounded-full mr-2"></span><span id="status-orientation">倒立</span></p>
                    <p class="flex items-center"><span class="inline-block w-2.5 h-2.5 bg-blue-500 rounded-full mr-2"></span><span id="status-size">縮小</span></p>
                </div>
            </div>
        </div>

        <!-- Controls -->
        <div class="w-full lg:w-96 h-[45%] lg:h-auto bg-white border-t lg:border-t-0 lg:border-l border-gray-200 flex flex-col shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.1)] z-20 shrink-0">
            <div class="w-full flex justify-center py-2 lg:hidden shrink-0">
                <div class="w-12 h-1.5 bg-gray-300 rounded-full"></div>
            </div>

            <div class="flex-1 overflow-y-auto custom-scrollbar p-4 pt-0 lg:pt-4 space-y-5">
                
                <!-- Removed AI Tutor Section -->

                <div class="space-y-4 pb-8 pt-4">
                    <h2 class="font-bold text-gray-800 flex items-center gap-2 text-xs uppercase tracking-wide text-gray-500" data-i18n="paramsTitle">
                        參數設定
                    </h2>

                    <!-- Lens Selector -->
                    <div class="bg-gray-50 p-2 rounded-lg border border-gray-200">
                        <label class="block text-xs md:text-sm font-medium text-gray-700 mb-2" data-i18n="labelLensType">透鏡種類</label>
                        <div class="flex gap-2">
                            <label class="flex-1 cursor-pointer group">
                                <input type="radio" name="lensType" value="convex" class="peer sr-only" checked onchange="setLensType('convex')">
                                <div class="text-center py-1.5 px-2 rounded-md border border-gray-300 bg-white text-gray-600 text-xs md:text-sm peer-checked:bg-blue-600 peer-checked:text-white peer-checked:border-blue-600 transition-all shadow-sm flex items-center justify-center gap-2">
                                    <span class="font-bold text-lg leading-none">()</span> <span data-i18n="convexLens">凸透鏡</span>
                                </div>
                            </label>
                            <label class="flex-1 cursor-pointer group">
                                <input type="radio" name="lensType" value="concave" class="peer sr-only" onchange="setLensType('concave')">
                                <div class="text-center py-1.5 px-2 rounded-md border border-gray-300 bg-white text-gray-600 text-xs md:text-sm peer-checked:bg-blue-600 peer-checked:text-white peer-checked:border-blue-600 transition-all shadow-sm flex items-center justify-center gap-2">
                                    <span class="font-bold text-lg leading-none">)(</span> <span data-i18n="concaveLens">凹透鏡</span>
                                </div>
                            </label>
                        </div>
                    </div>

                    <div class="space-y-3">
                        <div>
                            <div class="flex justify-between mb-1">
                                <label class="text-xs md:text-sm font-medium text-gray-700" data-i18n="labelF">焦距 ($f$)</label>
                                <span class="text-xs md:text-sm text-blue-600 font-mono" id="val-f">100 mm</span>
                            </div>
                            <input type="range" id="slider-f" min="50" max="300" value="150" class="w-full h-6 bg-transparent cursor-pointer accent-blue-600 touch-none">
                        </div>
                        <div>
                            <div class="flex justify-between mb-1">
                                <label class="text-xs md:text-sm font-medium text-gray-700" data-i18n="labelU">物距 ($u$)</label>
                                <span class="text-xs md:text-sm text-blue-600 font-mono" id="val-u">300 mm</span>
                            </div>
                            <input type="range" id="slider-u" min="10" max="600" value="300" class="w-full h-6 bg-transparent cursor-pointer accent-blue-600 touch-none">
                        </div>
                        <div>
                            <div class="flex justify-between mb-1">
                                <label class="text-xs md:text-sm font-medium text-gray-700" data-i18n="labelH">物體高度 ($h_o$)</label>
                                <span class="text-xs md:text-sm text-blue-600 font-mono" id="val-h">80 mm</span>
                            </div>
                            <input type="range" id="slider-h" min="10" max="150" value="80" class="w-full h-6 bg-transparent cursor-pointer accent-blue-600 touch-none">
                        </div>
                    </div>

                    <hr class="border-gray-200">

                    <div class="space-y-2">
                        <h2 class="font-bold text-gray-800 flex items-center gap-2 text-xs uppercase tracking-wide text-gray-500" data-i18n="resultsTitle">
                            計算結果
                        </h2>
                        <div class="grid grid-cols-2 gap-2 text-xs md:text-sm">
                            <div class="bg-gray-50 p-2 rounded border border-gray-100">
                                <div class="text-gray-500 text-[10px]" data-i18n="resV">像距 ($v$)</div>
                                <div class="font-mono font-bold text-gray-800" id="res-v">--</div>
                            </div>
                            <div class="bg-gray-50 p-2 rounded border border-gray-100">
                                <div class="text-gray-500 text-[10px]" data-i18n="resM">放大率 ($m$)</div>
                                <div class="font-mono font-bold text-gray-800" id="res-m">--</div>
                            </div>
                            <div class="bg-gray-50 p-2 rounded border border-gray-100 col-span-2">
                                <div class="text-gray-500 text-[10px]" data-i18n="resFormula">透鏡公式</div>
                                <div class="text-center text-blue-600 mt-1">$$ \frac{1}{f} = \frac{1}{u} + \frac{1}{v} $$</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Theory Modal -->
    <div id="theory-modal" class="fixed inset-0 bg-black/50 z-50 hidden flex justify-center items-center p-4 backdrop-blur-sm transition-opacity duration-300 opacity-0" onclick="if(event.target === this) toggleTheory()">
        <div class="bg-white rounded-xl shadow-2xl w-full max-w-lg max-h-[85vh] overflow-y-auto custom-scrollbar transform transition-transform duration-300 scale-95">
            <div class="sticky top-0 bg-white p-4 border-b flex justify-between items-center z-10">
                <h2 class="text-lg font-bold text-gray-800" data-i18n="theoryTitle">物理原理</h2>
                <button onclick="toggleTheory()" class="text-gray-500 hover:text-gray-700 bg-gray-100 p-1.5 rounded-full">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                </button>
            </div>
            <div class="p-5 space-y-6">
                <div>
                    <h3 class="font-bold text-blue-600 mb-2 flex items-center gap-2">
                        <span class="w-6 h-6 rounded-full bg-blue-100 text-blue-600 flex items-center justify-center text-xs">1</span>
                        <span data-i18n="theoryRaysTitle">三條特殊光線 (以凸透鏡為例)</span>
                    </h3>
                    <ul class="space-y-3 text-sm text-gray-700">
                        <li class="flex gap-3">
                            <span class="w-1 h-full bg-yellow-400 shrink-0 rounded-full"></span>
                            <div><strong data-i18n="ray1Name">平行光：</strong> <span data-i18n="ray1Desc">平行於主軸，折射後通過焦點。</span></div>
                        </li>
                        <li class="flex gap-3">
                            <span class="w-1 h-full bg-yellow-400 shrink-0 rounded-full"></span>
                            <div><strong data-i18n="ray2Name">光心光：</strong> <span data-i18n="ray2Desc">通過光心，方向不變。</span></div>
                        </li>
                        <li class="flex gap-3">
                            <span class="w-1 h-full bg-yellow-400 shrink-0 rounded-full"></span>
                            <div><strong data-i18n="ray3Name">焦點光：</strong> <span data-i18n="ray3Desc">通過焦點，折射後平行於主軸。</span></div>
                        </li>
                    </ul>
                </div>
                <div>
                    <h3 class="font-bold text-blue-600 mb-2 flex items-center gap-2">
                        <span class="w-6 h-6 rounded-full bg-blue-100 text-blue-600 flex items-center justify-center text-xs">2</span>
                        <span data-i18n="theoryMathTitle">數學公式</span>
                    </h3>
                    <div class="bg-gray-50 p-3 rounded-lg border border-gray-100">
                        <div class="text-center mb-4">
                            <div class="text-lg font-mono font-bold text-gray-800">$$ \frac{1}{f} = \frac{1}{u} + \frac{1}{v} $$</div>
                        </div>
                        <div class="text-center">
                            <div class="text-lg font-mono font-bold text-gray-800">$$ m = -\frac{v}{u} = \frac{h_i}{h_o} $$</div>
                        </div>
                    </div>
                    <div class="mt-3 text-xs text-gray-500 space-y-1">
                        <p>• $f$: <span data-i18n="legendF">焦距 (凸透鏡為正，凹透鏡為負)</span></p>
                        <p>• $u$: <span data-i18n="legendU">物距 (實物為正)</span></p>
                        <p>• $v$: <span data-i18n="legendV">像距 (實像為正，虛像為負)</span></p>
                        <p>• $m$: <span data-i18n="legendM">放大率 (負值代表倒立)</span></p>
                    </div>
                </div>
            </div>
            <div class="p-4 bg-gray-50 border-t text-center">
                 <button onclick="toggleTheory()" class="bg-blue-600 text-white px-6 py-2 rounded-lg text-sm font-medium hover:bg-blue-700 transition-colors" data-i18n="btnClose">關閉</button>
            </div>
        </div>
    </div>

    <!-- Cases Modal (New) -->
    <div id="cases-modal" class="fixed inset-0 bg-black/50 z-50 hidden flex justify-center items-center p-4 backdrop-blur-sm transition-opacity duration-300 opacity-0" onclick="if(event.target === this) toggleCases()">
        <div class="bg-white rounded-xl shadow-2xl w-full max-w-2xl max-h-[85vh] overflow-y-auto custom-scrollbar transform transition-transform duration-300 scale-95">
            <div class="sticky top-0 bg-white p-4 border-b flex justify-between items-center z-10">
                <h2 class="text-lg font-bold text-gray-800" data-i18n="casesTitle">透鏡成像列表</h2>
                <button onclick="toggleCases()" class="text-gray-500 hover:text-gray-700 bg-gray-100 p-1.5 rounded-full">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                </button>
            </div>
            <div class="p-5 space-y-6">
                <!-- Convex Cases -->
                <div>
                    <h3 class="font-bold text-blue-600 mb-3 text-sm md:text-base border-b pb-2" data-i18n="convexCasesTitle">凸透鏡 (Convex Lens) 成像</h3>
                    <div class="overflow-x-auto">
                        <table class="w-full text-xs md:text-sm text-left border-collapse case-table">
                            <thead>
                                <tr>
                                    <th data-i18n="thObjPos">物距 (u)</th>
                                    <th data-i18n="thImgNature">成像性質</th>
                                    <th data-i18n="thApp">應用例子</th>
                                </tr>
                            </thead>
                            <tbody class="text-gray-700">
                                <tr>
                                    <td>u = ∞</td>
                                    <td data-i18n="case1Nature">點狀實像 (於焦點)</td>
                                    <td data-i18n="case1App">聚光取火</td>
                                </tr>
                                <tr>
                                    <td>u > 2f</td>
                                    <td data-i18n="case2Nature">縮小、倒立、實像</td>
                                    <td data-i18n="case2App">相機、眼睛</td>
                                </tr>
                                <tr>
                                    <td>u = 2f</td>
                                    <td data-i18n="case3Nature">等大、倒立、實像</td>
                                    <td data-i18n="case3App">影印機 (1:1)</td>
                                </tr>
                                <tr>
                                    <td>2f > u > f</td>
                                    <td data-i18n="case4Nature">放大、倒立、實像</td>
                                    <td data-i18n="case4App">投影機、顯微鏡</td>
                                </tr>
                                <tr>
                                    <td>u = f</td>
                                    <td data-i18n="case5Nature">不成像 (光線平行)</td>
                                    <td data-i18n="case5App">探照燈</td>
                                </tr>
                                <tr>
                                    <td>u < f</td>
                                    <td data-i18n="case6Nature">放大、正立、虛像</td>
                                    <td data-i18n="case6App">放大鏡</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Concave Cases -->
                <div>
                    <h3 class="font-bold text-blue-600 mb-3 text-sm md:text-base border-b pb-2" data-i18n="concaveCasesTitle">凹透鏡 (Concave Lens) 成像</h3>
                    <div class="bg-gray-50 p-3 rounded-lg border border-gray-100 text-xs md:text-sm text-gray-700">
                        <p data-i18n="concaveDesc">無論物體在任何位置，凹透鏡總是形成：<br><strong class="text-blue-700">縮小、正立、虛像</strong>。</p>
                        <p class="mt-2 text-gray-500" data-i18n="concaveApp">應用：近視眼鏡、防盜眼</p>
                    </div>
                </div>
            </div>
            <div class="p-4 bg-gray-50 border-t text-center">
                 <button onclick="toggleCases()" class="bg-blue-600 text-white px-6 py-2 rounded-lg text-sm font-medium hover:bg-blue-700 transition-colors" data-i18n="btnClose">關閉</button>
            </div>
        </div>
    </div>

    <script>
        const i18n = {
            zh: {
                appTitle: "物理光學模擬",
                btnTheory: "原理解說",
                btnCases: "成像列表",
                imgNature: "成像性質",
                paramsTitle: "參數設定",
                labelLensType: "透鏡種類",
                convexLens: "凸透鏡",
                concaveLens: "凹透鏡",
                labelF: "焦距 ($f$)",
                labelU: "物距 ($u$)",
                labelH: "物體高度 ($h_o$)",
                resultsTitle: "計算結果",
                resV: "像距 ($v$)",
                resM: "放大率 ($m$)",
                resFormula: "透鏡公式",
                theoryTitle: "物理原理",
                theoryRaysTitle: "三條特殊光線 (以凸透鏡為例)",
                ray1Name: "平行光：",
                ray1Desc: "平行於主軸的光線，折射後通過焦點 (F)。",
                ray2Name: "光心光：",
                ray2Desc: "通過透鏡中心 (O) 的光線，方向不變。",
                ray3Name: "焦點光：",
                ray3Desc: "通過焦點 (F') 的光線，折射後平行於主軸。",
                theoryMathTitle: "數學公式",
                legendF: "焦距 (凸透鏡為正，凹透鏡為負)",
                legendU: "物距 (實物為正)",
                legendV: "像距 (實像為正，虛像為負)",
                legendM: "放大率 (負值代表倒立)",
                btnClose: "關閉",
                casesTitle: "透鏡成像列表",
                convexCasesTitle: "凸透鏡 (Convex Lens) 成像",
                concaveCasesTitle: "凹透鏡 (Concave Lens) 成像",
                thObjPos: "物距 (u)",
                thImgNature: "成像性質",
                thApp: "應用例子",
                case1Nature: "點狀實像 (於焦點)",
                case1App: "聚光取火",
                case2Nature: "縮小、倒立、實像",
                case2App: "相機、眼睛",
                case3Nature: "等大、倒立、實像",
                case3App: "影印機 (1:1)",
                case4Nature: "放大、倒立、實像",
                case4App: "投影機、顯微鏡",
                case5Nature: "不成像 (光線平行)",
                case5App: "探照燈",
                case6Nature: "放大、正立、虛像",
                case6App: "放大鏡",
                concaveDesc: "無論物體在任何位置，凹透鏡總是形成：<br><strong class=\"text-blue-700\">縮小、正立、虛像</strong>。",
                concaveApp: "應用：近視眼鏡、防盜眼",
                real: "實像",
                virtual: "虛像",
                inverted: "倒立",
                upright: "正立",
                magnified: "放大",
                diminished: "縮小",
                sameSize: "等大",
                noImage: "不成像",
                infinity: "無窮遠",
                objLabel: "物體",
                imgLabelReal: "實像",
                imgLabelVirtual: "虛像",
            },
            en: {
                appTitle: "Optics Simulator",
                btnTheory: "Theory",
                btnCases: "Cases",
                imgNature: "Image Nature",
                paramsTitle: "Parameters",
                labelLensType: "Lens Type",
                convexLens: "Convex",
                concaveLens: "Concave",
                labelF: "Focal Length ($f$)",
                labelU: "Object Dist. ($u$)",
                labelH: "Object Height ($h_o$)",
                resultsTitle: "Results",
                resV: "Image Dist. ($v$)",
                resM: "Magnification ($m$)",
                resFormula: "Lens Formula",
                theoryTitle: "Physics Principles",
                theoryRaysTitle: "Three Special Rays (Convex Example)",
                ray1Name: "Parallel Ray:",
                ray1Desc: "Parallel to principal axis, refracts through focus (F).",
                ray2Name: "Center Ray:",
                ray2Desc: "Passes through optical center (O), does not deviate.",
                ray3Name: "Focal Ray:",
                ray3Desc: "Passes through focus (F'), refracts parallel to axis.",
                theoryMathTitle: "Formulas",
                legendF: "Focal Length (+ Convex, - Concave)",
                legendU: "Object Distance (+ for real)",
                legendV: "Image Distance (+ real, - virtual)",
                legendM: "Magnification (- means inverted)",
                btnClose: "Close",
                casesTitle: "Imaging Cases List",
                convexCasesTitle: "Convex Lens Imaging",
                concaveCasesTitle: "Concave Lens Imaging",
                thObjPos: "Obj Dist (u)",
                thImgNature: "Image Nature",
                thApp: "Application",
                case1Nature: "Point image (at Focus)",
                case1App: "Burning glass",
                case2Nature: "Diminished, Inverted, Real",
                case2App: "Camera, Eye",
                case3Nature: "Same size, Inverted, Real",
                case3App: "Photocopier (1:1)",
                case4Nature: "Magnified, Inverted, Real",
                case4App: "Projector, Microscope",
                case5Nature: "No Image (Parallel rays)",
                case5App: "Spotlight",
                case6Nature: "Magnified, Upright, Virtual",
                case6App: "Magnifying Glass",
                concaveDesc: "Regardless of object position, Concave Lens always forms:<br><strong class=\"text-blue-700\">Diminished, Upright, Virtual Image</strong>.",
                concaveApp: "App: Myopia glasses, Peephole",
                real: "Real",
                virtual: "Virtual",
                inverted: "Inverted",
                upright: "Upright",
                magnified: "Magnified",
                diminished: "Diminished",
                sameSize: "Same Size",
                noImage: "No Image",
                infinity: "Infinity",
                objLabel: "Object",
                imgLabelReal: "Real Img",
                imgLabelVirtual: "Virt Img",
            }
        };

        const state = {
            lang: 'zh',
            lensType: 'convex', 
            f: 150,
            u: 300,
            h: 80,
            isDragging: false,
            dragTarget: null,
            calculatedV: 0,
            calculatedM: 0,
            nature: "實像",
            theoryOpen: false,
            casesOpen: false
        };

        const canvas = document.getElementById('opticsCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvas-container');

        const ui = {
            sliders: {
                f: document.getElementById('slider-f'),
                u: document.getElementById('slider-u'),
                h: document.getElementById('slider-h'),
            },
            displays: {
                f: document.getElementById('val-f'),
                u: document.getElementById('val-u'),
                h: document.getElementById('val-h'),
                v: document.getElementById('res-v'),
                m: document.getElementById('res-m'),
            },
            status: {
                type: document.getElementById('status-type'),
                orientation: document.getElementById('status-orientation'),
                size: document.getElementById('status-size'),
            },
            modal: document.getElementById('theory-modal'),
            casesModal: document.getElementById('cases-modal')
        };

        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            window.addEventListener('orientationchange', () => setTimeout(resizeCanvas, 100));
            
            ui.sliders.f.addEventListener('input', (e) => { state.f = Number(e.target.value); update(); });
            ui.sliders.u.addEventListener('input', (e) => { state.u = Number(e.target.value); update(); });
            ui.sliders.h.addEventListener('input', (e) => { state.h = Number(e.target.value); update(); });

            canvas.addEventListener('mousedown', handleInputStart);
            canvas.addEventListener('mousemove', handleInputMove);
            window.addEventListener('mouseup', handleInputEnd);
            canvas.addEventListener('touchstart', handleInputStart, {passive: false});
            canvas.addEventListener('touchmove', handleInputMove, {passive: false});
            window.addEventListener('touchend', handleInputEnd);

            applyLanguage();
            update();
        }

        function setLensType(type) {
            state.lensType = type;
            update();
        }

        function toggleLanguage() {
            state.lang = state.lang === 'zh' ? 'en' : 'zh';
            applyLanguage();
            update();
        }

        function applyLanguage() {
            const texts = i18n[state.lang];
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                if (texts[key]) el.innerHTML = texts[key]; // Changed to innerHTML to support <br>
            });
            if (window.MathJax && window.MathJax.typesetPromise) window.MathJax.typesetPromise();
        }

        function toggleTheory() {
            state.theoryOpen = !state.theoryOpen;
            // Close other modal if open
            if(state.casesOpen) toggleCases();

            const modal = ui.modal;
            if (state.theoryOpen) {
                modal.classList.remove('hidden');
                setTimeout(() => { modal.classList.remove('opacity-0'); modal.querySelector('div').classList.remove('scale-95'); }, 10);
            } else {
                modal.classList.add('opacity-0'); modal.querySelector('div').classList.add('scale-95');
                setTimeout(() => modal.classList.add('hidden'), 300);
            }
        }

        function toggleCases() {
            state.casesOpen = !state.casesOpen;
            // Close other modal if open
            if(state.theoryOpen) toggleTheory();

            const modal = ui.casesModal;
            if (state.casesOpen) {
                modal.classList.remove('hidden');
                setTimeout(() => { modal.classList.remove('opacity-0'); modal.querySelector('div').classList.remove('scale-95'); }, 10);
            } else {
                modal.classList.add('opacity-0'); modal.querySelector('div').classList.add('scale-95');
                setTimeout(() => modal.classList.add('hidden'), 300);
            }
        }

        function resizeCanvas() {
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            update();
        }

        function handleInputStart(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const x = clientX - rect.left;
            const y = clientY - rect.top;
            
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const objTipX = cx - state.u;
            const objTipY = cy - state.h;

            if (Math.abs(x - objTipX) < 40 && Math.abs(y - objTipY) < 40) {
                state.isDragging = true; state.dragTarget = 'object-tip';
            } else if (Math.abs(x - objTipX) < 40 && Math.abs(y - cy) < 80) {
                state.isDragging = true; state.dragTarget = 'object-base';
            }
        }

        function handleInputMove(e) {
            if (!state.isDragging) return;
            if (e.cancelable) e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const x = clientX - rect.left;
            const y = clientY - rect.top;
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;

            if (state.dragTarget === 'object-tip') {
                let newU = cx - x;
                let newH = cy - y;
                if (newU < 10) newU = 10;
                if (newU > cx - 10) newU = cx - 10;
                if (newH < 10) newH = 10;
                if (newH > cy - 10) newH = cy - 10;
                state.u = newU; state.h = newH;
            } else if (state.dragTarget === 'object-base') {
                let newU = cx - x;
                if (newU < 10) newU = 10;
                if (newU > cx - 10) newU = cx - 10;
                state.u = newU;
            }
            ui.sliders.u.value = Math.round(state.u);
            ui.sliders.h.value = Math.round(state.h);
            update();
        }

        function handleInputEnd() { state.isDragging = false; state.dragTarget = null; }

        function calculateImage() {
            const u = state.u;
            const f = state.lensType === 'convex' ? state.f : -state.f;
            let v = 0, m = 0;
            
            if (state.lensType === 'convex' && u === state.f) {
                v = Infinity; m = Infinity;
            } else {
                v = (f * u) / (u - f);
                m = -v / u; 
            }
            state.calculatedV = v; state.calculatedM = m;
            return { v, m };
        }

        function update() {
            ui.displays.f.innerText = `${Math.round(state.f)} mm`;
            ui.displays.u.innerText = `${Math.round(state.u)} mm`;
            ui.displays.h.innerText = `${Math.round(state.h)} mm`;

            const { v, m } = calculateImage();
            const texts = i18n[state.lang];
            
            if (v === Infinity) {
                ui.displays.v.innerText = texts.infinity;
                ui.displays.m.innerText = "∞";
                ui.status.type.innerText = texts.noImage;
                ui.status.orientation.innerText = "--";
                ui.status.size.innerText = "--";
                state.nature = texts.noImage;
            } else {
                ui.displays.v.innerText = `${Math.round(Math.abs(v))} mm`;
                ui.displays.m.innerText = `${Math.abs(m).toFixed(2)}x`;
                
                let typeText = v > 0 ? texts.real : texts.virtual;
                let orientText = m < 0 ? texts.inverted : texts.upright;
                let sizeText = Math.abs(m) > 1.01 ? texts.magnified : (Math.abs(m) < 0.99 ? texts.diminished : texts.sameSize);
                
                ui.status.type.innerText = typeText;
                ui.status.orientation.innerText = orientText;
                ui.status.size.innerText = sizeText;
                state.nature = `${sizeText} ${orientText} ${typeText}`;
            }
            drawScene(v, m);
        }

        // --- Drawing Logic ---

        function drawScene(v, m) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const texts = i18n[state.lang];

            // Grid
            ctx.strokeStyle = "#e2e8f0"; ctx.lineWidth = 1;
            for(let x = cx % 50; x < canvas.width; x += 50) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke(); }
            for(let y = cy % 50; y < canvas.height; y += 50) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke(); }

            // Axis
            ctx.strokeStyle = "#334155"; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(0, cy); ctx.lineTo(canvas.width, cy); ctx.stroke();

            drawLensShape(cx, cy);
            drawFocusPoints(cx, cy);

            const objX = cx - state.u;
            drawArrow(objX, cy, state.h, "#dc2626", texts.objLabel, false);

            if (v !== Infinity) {
                const imgX = cx + v;
                const imgH = state.h * m; 
                const isVirtual = v < 0;
                const color = isVirtual ? "#9333ea" : "#ea580c";
                const label = isVirtual ? texts.imgLabelVirtual : texts.imgLabelReal;
                drawArrow(imgX, cy, imgH, color, label, isVirtual);
            }

            if (state.lensType === 'convex') {
                drawConvexRays(cx, cy, objX, cy - state.h, v, m);
            } else {
                drawConcaveRays(cx, cy, objX, cy - state.h, v, m);
            }
        }

        function drawLensShape(cx, cy) {
            ctx.fillStyle = "rgba(147, 197, 253, 0.3)";
            ctx.strokeStyle = "#2563eb";
            ctx.lineWidth = 2;
            const h = 120; // Half height
            const w = 15;  // Half width
            
            ctx.beginPath();
            if (state.lensType === 'convex') {
                ctx.moveTo(cx, cy - h);
                ctx.quadraticCurveTo(cx + w, cy, cx, cy + h);
                ctx.quadraticCurveTo(cx - w, cy, cx, cy - h);
            } else {
                // Concave shape
                ctx.moveTo(cx - w, cy - h);
                ctx.lineTo(cx + w, cy - h);
                ctx.quadraticCurveTo(cx + 5, cy, cx + w, cy + h);
                ctx.lineTo(cx - w, cy + h);
                ctx.quadraticCurveTo(cx - 5, cy, cx - w, cy - h);
            }
            ctx.fill();
            ctx.stroke();
            
            ctx.fillStyle = "#1e40af";
            ctx.beginPath(); ctx.arc(cx, cy, 3, 0, Math.PI*2); ctx.fill();
            ctx.font = "14px sans-serif"; ctx.fillText("O", cx + 5, cy + 15);
        }

        function drawFocusPoints(cx, cy) {
            ctx.fillStyle = "#000";
            const f = state.f;
            const f2 = f * 2; // 2F distance
            
            // Draw Focus Points (F, F')
            ctx.beginPath(); ctx.arc(cx - f, cy, 3, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(cx + f, cy, 3, 0, Math.PI*2); ctx.fill();
            
            // Draw 2F Points
            ctx.beginPath(); ctx.arc(cx - f2, cy, 3, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(cx + f2, cy, 3, 0, Math.PI*2); ctx.fill();

            ctx.font = "12px sans-serif"; ctx.fillStyle = "#475569";
            
            if (state.lensType === 'convex') {
                ctx.fillText("F'", cx - f - 5, cy + 20); 
                ctx.fillText("F", cx + f - 5, cy + 20); 
                
                // 2F' (Object side) and 2F (Image side)
                ctx.fillText("2F'", cx - f2 - 8, cy + 20);
                ctx.fillText("2F", cx + f2 - 8, cy + 20);
            } else {
                ctx.fillText("F", cx - f - 5, cy + 20); 
                ctx.fillText("F'", cx + f - 5, cy + 20); 
                
                // 2F (Virtual side) and 2F' (Real side) for symmetry naming
                ctx.fillText("2F", cx - f2 - 8, cy + 20);
                ctx.fillText("2F'", cx + f2 - 8, cy + 20);
            }
        }

        function drawArrow(x, originY, height, color, label, isDashed) {
            ctx.strokeStyle = color; ctx.fillStyle = color; ctx.lineWidth = 3;
            ctx.setLineDash(isDashed ? [5, 5] : []);
            const tipY = originY - height;
            ctx.beginPath(); ctx.moveTo(x, originY); ctx.lineTo(x, tipY); ctx.stroke();
            
            const dirY = height > 0 ? -1 : 1;
            ctx.beginPath(); ctx.moveTo(x, tipY); 
            ctx.lineTo(x - 6, tipY - 6*dirY); ctx.lineTo(x + 6, tipY - 6*dirY);
            ctx.closePath(); ctx.fill();
            
            ctx.setLineDash([]); ctx.font = "bold 14px Noto Sans TC"; ctx.textAlign = "center";
            ctx.fillText(label, x, originY + (height > 0 ? 40 : -40));
        }

        // --- Improved Line Drawing with Clipping ---
        function drawLineWithArrow(x1, y1, x2, y2, color, isDashed = false) {
            if (!isFinite(x1) || !isFinite(y1) || !isFinite(x2) || !isFinite(y2)) return;

            // Calculate visible segment for arrow placement
            let clip = clipLine(x1, y1, x2, y2);
            
            ctx.beginPath(); 
            ctx.moveTo(x1, y1); 
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = color; 
            ctx.lineWidth = 1.5;
            ctx.setLineDash(isDashed ? [5, 5] : []);
            ctx.stroke(); 
            ctx.setLineDash([]);

            // Draw arrow at the midpoint of the VISIBLE segment
            if (!isDashed && clip) { 
                const midX = (clip.x1 + clip.x2) / 2;
                const midY = (clip.y1 + clip.y2) / 2;
                const angle = Math.atan2(y2 - y1, x2 - x1);
                drawArrowHead(midX, midY, angle, color);
            }
        }

        function clipLine(x1, y1, x2, y2) {
            // Liang-Barsky algorithm
            const xmin = 0, ymin = 0, xmax = canvas.width, ymax = canvas.height;
            let p = [-(x2 - x1), (x2 - x1), -(y2 - y1), (y2 - y1)];
            let q = [x1 - xmin, xmax - x1, y1 - ymin, ymax - y1];
            let u1 = 0, u2 = 1;

            for (let i = 0; i < 4; i++) {
                if (p[i] === 0) {
                    if (q[i] < 0) return null;
                } else {
                    let t = q[i] / p[i];
                    if (p[i] < 0 && t > u1) u1 = t;
                    else if (p[i] > 0 && t < u2) u2 = t;
                }
            }

            if (u1 > u2) return null;

            return {
                x1: x1 + u1 * (x2 - x1),
                y1: y1 + u1 * (y2 - y1),
                x2: x1 + u2 * (x2 - x1),
                y2: y1 + u2 * (y2 - y1)
            };
        }

        function drawArrowHead(x, y, angle, color) {
            const size = 10;
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-size, -size/2.5);
            ctx.lineTo(-size + 2, 0);
            ctx.lineTo(-size, size/2.5);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        function drawConvexRays(cx, cy, objX, objY, imgV, m) {
            const imgX = imgV === Infinity ? cx + 1000 : cx + imgV;
            const imgY = imgV === Infinity ? NaN : cy - (state.h * m);
            const rayColor = "#eab308";
            const virtualColor = "#fbbf24";

            // Ray 1: Parallel -> Focus
            drawLineWithArrow(objX, objY, cx, objY, rayColor); 
            // Determine intersection point on right side or far away
            const slope1 = (cy - objY) / state.f;
            const endX1 = cx + canvas.width * 2; // Ensure it goes off screen
            const endY1 = objY + slope1 * canvas.width * 2;
            drawLineWithArrow(cx, objY, endX1, endY1, rayColor);
            
            if (imgV < 0) {
                 drawLineWithArrow(cx, objY, imgX, imgY, virtualColor, true);
            }

            // Ray 2: Center (Straight)
            const slope2 = (cy - objY) / (cx - objX);
            const endX2 = cx + canvas.width * 2;
            const endY2 = cy + slope2 * canvas.width * 2;
            drawLineWithArrow(objX, objY, endX2, endY2, rayColor);
             if (imgV < 0) {
                drawLineWithArrow(cx, cy, imgX, imgY, virtualColor, true);
            }

            // Ray 3: Through Focus -> Parallel
            if (Math.abs(state.u - state.f) > 1) {
                // Determine height at lens
                const slope3 = (cy - objY) / (cx - state.f - objX); // Slope from tip to F'
                // y = objY + slope * (x - objX)
                // at x = cx:
                const hitY = objY + slope3 * (cx - objX);
                
                drawLineWithArrow(objX, objY, cx, hitY, rayColor);
                drawLineWithArrow(cx, hitY, cx + canvas.width * 2, hitY, rayColor); // Out parallel
                
                if (imgV < 0) {
                     drawLineWithArrow(cx, hitY, imgX, hitY, virtualColor, true);
                }
            }
        }

        function drawConcaveRays(cx, cy, objX, objY, imgV, m) {
            const imgX = cx + imgV;
            const imgY = cy - (state.h * m);
            const rayColor = "#eab308";
            const virtualColor = "#fbbf24";
            
            // Concave Ray 1: Parallel -> Diverges from Focus (Left F)
            drawLineWithArrow(objX, objY, cx, objY, rayColor); 
            const slope1 = (objY - cy) / state.f; 
            const endX1 = cx + canvas.width * 2;
            const endY1 = objY + slope1 * canvas.width * 2; 
            drawLineWithArrow(cx, objY, endX1, endY1, rayColor);
            drawLineWithArrow(cx, objY, cx - state.f, cy, virtualColor, true);

            // Concave Ray 2: Center (Straight)
            const slope2 = (cy - objY) / (cx - objX);
            const endX2 = cx + canvas.width * 2;
            const endY2 = cy + slope2 * canvas.width * 2;
            drawLineWithArrow(objX, objY, endX2, endY2, rayColor);

            // Concave Ray 3: Towards Focus (Right F) -> Parallel
            const slope3 = (cy - objY) / (cx + state.f - objX);
            const hitY = objY + slope3 * (cx - objX);
            
            drawLineWithArrow(objX, objY, cx, hitY, rayColor);
            drawLineWithArrow(cx, hitY, cx + state.f, cy, "#d1d5db", true); // Guide to F'
            
            drawLineWithArrow(cx, hitY, cx + canvas.width * 2, hitY, rayColor);
            drawLineWithArrow(cx, hitY, imgX, hitY, virtualColor, true);
        }

        init();
    </script>
</body>
</html>