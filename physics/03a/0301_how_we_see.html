<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å…‰ç·šé€²å…¥çœ¼ç›æ¨¡æ“¬å™¨</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* è‡ªå®šç¾© Canvas æ¨£å¼ä»¥ç¢ºä¿æ¸…æ™°åº¦ */
        canvas {
            border: 1px solid #e5e7eb;
            background-color: #111827; /* æ·±è‰²èƒŒæ™¯æ¨¡æ“¬æš—å®¤ */
            border-radius: 0.5rem;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
        }
        .slider-thumb::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #3b82f6;
            cursor: pointer;
            border-radius: 50%;
        }
        /* Modal Canvas ç‰¹æ®Šæ¨£å¼ï¼šç™½è‰²èƒŒæ™¯ */
        #eyeModalCanvas {
            background-color: #ffffff;
            border: none;
            box-shadow: none;
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800 font-sans min-h-screen flex flex-col">

    <!-- Header -->
    <header class="bg-blue-600 text-white p-4 shadow-lg">
        <div class="max-w-5xl mx-auto flex items-center justify-between">
            <h1 class="text-2xl font-bold flex items-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                </svg>
                ç‰©ç†æ•™å®¤ï¼šå…‰ç·šèˆ‡è¦–è¦º
            </h1>
            <span class="text-sm bg-blue-700 px-3 py-1 rounded-full">äº’å‹•æ¨¡æ“¬å¯¦é©—</span>
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-grow p-4 md:p-8 max-w-6xl mx-auto w-full grid grid-cols-1 lg:grid-cols-3 gap-6">
        
        <!-- Controls Panel -->
        <div class="bg-white p-6 rounded-xl shadow-md space-y-6 h-fit border border-gray-200 lg:col-span-1">
            <h2 class="text-xl font-semibold border-b pb-2 text-gray-700">å¯¦é©—åƒæ•¸è¨­å®š</h2>

            <!-- Control 1: Object Type -->
            <div class="space-y-2">
                <label class="block text-sm font-medium text-gray-700">1. ç‰©é«”æ€§è³ª</label>
                <div class="flex gap-2">
                    <button id="btn-luminous" onclick="setObjectType('luminous')" class="flex-1 py-2 px-3 rounded-lg border-2 border-yellow-500 bg-yellow-50 text-yellow-700 font-medium hover:bg-yellow-100 transition focus:outline-none focus:ring-2 focus:ring-yellow-500">
                        ğŸ•¯ï¸ ç™¼å…‰é«”
                    </button>
                    <button id="btn-nonluminous" onclick="setObjectType('non-luminous')" class="flex-1 py-2 px-3 rounded-lg border-2 border-gray-300 bg-gray-50 text-gray-600 font-medium hover:bg-gray-100 transition focus:outline-none focus:ring-2 focus:ring-gray-400">
                        ğŸ éç™¼å…‰é«”
                    </button>
                </div>
                <p id="type-desc" class="text-xs text-gray-500 mt-1">
                    ç™¼å…‰é«”æœƒè‡ªè¡Œç™¼å‡ºå…‰ç·šï¼ˆä¾‹å¦‚ï¼šè Ÿç‡­ã€å¤ªé™½ï¼‰ã€‚
                </p>
            </div>

            <!-- Control 2: Distance -->
            <div class="space-y-3">
                <div class="flex justify-between items-center">
                    <label class="block text-sm font-medium text-gray-700">2. ç‰©é«”è·é›¢</label>
                    <div class="flex items-center gap-2">
                        <input type="checkbox" id="infinite-toggle" onchange="toggleInfinite()" class="w-4 h-4 text-blue-600 rounded focus:ring-blue-500">
                        <label for="infinite-toggle" class="text-sm text-blue-600 font-semibold cursor-pointer select-none">è¨­ç‚ºç„¡é™é </label>
                    </div>
                </div>
                <input type="range" id="distance-slider" min="50" max="600" value="300" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer slider-thumb" oninput="updateSimulation()">
                <div class="flex justify-between text-xs text-gray-500">
                    <span>è¿‘</span>
                    <span id="distance-value">300cm</span>
                    <span>é </span>
                </div>
            </div>

            <!-- Control 3: Pupil Size -->
            <div class="space-y-3">
                <label class="block text-sm font-medium text-gray-700">3. çœ¼ç›ç›´å¾‘ (ç³å­”å¤§å°)</label>
                <input type="range" id="pupil-slider" min="10" max="80" value="30" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer slider-thumb" oninput="updateSimulation()">
                <div class="flex justify-between text-xs text-gray-500">
                    <span>å°å…‰éŒ</span>
                    <span id="pupil-value">30mm</span>
                    <span>å¤§å…‰éŒ</span>
                </div>
                <div class="bg-blue-50 p-3 rounded text-sm text-blue-800 border border-blue-100">
                    <strong class="block mb-1">ğŸ’¡ ç‰©ç†æ¦‚å¿µï¼šå…‰éŒ</strong>
                    <span id="concept-text">ç‰©é«”ç™¼å‡ºçš„å…‰æ˜¯å‘å››é¢å…«æ–¹æ“´æ•£çš„ï¼Œä½†åªæœ‰å°„å…¥ç³å­”ç¯„åœå…§çš„å…‰ç·šï¼ˆé»ƒè‰²å€åŸŸï¼‰æ‰èƒ½è¢«æˆ‘å€‘çœ‹è¦‹ã€‚</span>
                </div>
            </div>

            <!-- New: Explanation Button -->
            <button onclick="toggleModal(true)" class="w-full py-3 bg-indigo-600 text-white rounded-lg font-semibold hover:bg-indigo-700 transition shadow-sm flex items-center justify-center gap-2">
                <span>ğŸ“–</span> å¯¦é©—è§£èªªï¼šç‰©è·èˆ‡å…‰éŒ
            </button>
        </div>

        <!-- Simulation Canvas -->
        <div class="lg:col-span-2 flex flex-col gap-4">
            <div class="relative w-full aspect-[16/9] bg-gray-900 rounded-xl overflow-hidden shadow-inner border border-gray-700">
                <canvas id="simCanvas" class="absolute top-0 left-0 w-full h-full"></canvas>
                
                <!-- Overlay Labels (Optional for better accessibility) -->
                <div class="absolute bottom-4 right-4 text-white/50 text-sm pointer-events-none select-none">
                    æ¨¡æ“¬ç•«é¢
                </div>
            </div>
            
            <!-- Observation Panel -->
            <div class="bg-white p-4 rounded-xl shadow-sm border border-gray-200">
                <h3 class="font-bold text-gray-800 mb-2">è§€å¯Ÿé‡é»ï¼š</h3>
                <ul class="list-disc list-inside text-sm text-gray-600 space-y-1">
                    <li id="obs-1">å…‰ç·šä»¥ç›´ç·šå‚³æ’­é€²å…¥çœ¼ç›ã€‚</li>
                    <li id="obs-2">ç‰©é«”è·é›¢è¶Šé ï¼Œé€²å…¥çœ¼ç›çš„å…‰ç·šå¤¾è§’è¶Šå°ã€‚</li>
                    <li id="obs-3">ç³å­”è¶Šå¤§ï¼Œæ”¶é›†åˆ°çš„å…‰ç·šè¶Šå¤šï¼ˆå…‰éŒè¶Šå¯¬ï¼‰ã€‚</li>
                </ul>
            </div>
        </div>
    </main>

    <!-- Modal Overlay -->
    <div id="info-modal" class="fixed inset-0 bg-black/60 z-50 hidden flex items-center justify-center backdrop-blur-sm transition-opacity opacity-0">
        <div class="bg-white rounded-2xl shadow-2xl max-w-lg w-full mx-4 overflow-hidden transform transition-all scale-95 flex flex-col max-h-[90vh]">
            <!-- Modal Header -->
            <div class="bg-indigo-600 p-4 flex justify-between items-center text-white flex-shrink-0">
                <h3 class="text-xl font-bold flex items-center gap-2">
                    <span>ğŸ“</span> ç‰©è·èˆ‡å…‰éŒç™¼æ•£
                </h3>
                <button onclick="toggleModal(false)" class="hover:bg-indigo-700 p-1 rounded-full transition">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>
            
            <!-- Modal Body -->
            <div class="p-6 space-y-4 text-gray-700 overflow-y-auto">
                <div class="bg-indigo-50 p-4 rounded-lg border border-indigo-100">
                    <h4 class="font-bold text-indigo-900 mb-2">ç‚ºä»€éº¼è·é›¢æœƒå½±éŸ¿å…‰éŒå½¢ç‹€ï¼Ÿ</h4>
                    <p class="text-sm leading-relaxed">
                        ç•¶ç‰©é«”è·é›¢çœ¼ç›ä¸åŒæ™‚ï¼Œèƒ½å¤ é€²å…¥ç³å­”çš„å…‰ç·šè§’åº¦ï¼ˆç™¼æ•£è§’ï¼‰æœƒç™¼ç”Ÿè®ŠåŒ–ã€‚<strong>è·é›¢æ„ˆé ï¼Œé€²å…¥çœ¼ç›çš„å…‰ç·šç™¼æ•£è§’åº¦æ„ˆå°ã€‚</strong>
                    </p>
                </div>

                <!-- NEW: Frontal Eye Diagram -->
                <div class="border border-gray-200 rounded-lg p-4 bg-gray-50 flex flex-col items-center shadow-sm">
                    <h5 class="text-sm font-bold text-gray-700 mb-2 self-start w-full border-b pb-1">ğŸ‘ï¸ çœ¼ç›æ§‹é€ æ­£é¢åœ– (ç¤ºæ„)</h5>
                    <canvas id="eyeModalCanvas" width="300" height="150" class="w-full max-w-[300px]"></canvas>
                    <p class="text-xs text-gray-500 mt-2 text-center">
                        <span class="inline-block w-3 h-3 bg-gray-800 rounded-full align-middle mr-1"></span><strong>ç³å­” (Pupil)</strong>ï¼šä½æ–¼ä¸­å¤®çš„é»‘è‰²åœ“å½¢é–‹å­”ï¼Œå…‰ç·šç”±æ­¤é€²å…¥ã€‚<br>
                        <span class="inline-block w-3 h-3 bg-blue-400 rounded-full align-middle mr-1"></span><strong>è™¹è†œ (Iris)</strong>ï¼šæœ‰é¡è‰²çš„è‚Œè‚‰çµ„ç¹”ï¼Œæ§åˆ¶ç³å­”å¤§å°ã€‚
                    </p>
                </div>

                <div class="space-y-4">
                    <div class="flex gap-4 items-start">
                        <div class="w-12 h-12 flex-shrink-0 bg-yellow-100 rounded-full flex items-center justify-center text-xl shadow-sm">ğŸ”¦</div>
                        <div>
                            <strong class="block text-gray-900">è¿‘è™•ç‰©é«” (Short Distance)</strong>
                            <p class="text-sm text-gray-600 mt-1">
                                è·é›¢è¼ƒè¿‘æ™‚ï¼Œå…‰ç·šé€²å…¥çœ¼ç›çš„<strong>ç™¼æ•£è§’åº¦è¼ƒå¤§</strong>ã€‚å…‰ç·šéœ€è¦ä»¥è¼ƒå¤§çš„å¼µè§’æ‰èƒ½å‰›å¥½é€²å…¥ç³å­”ï¼Œå…‰éŒçœ‹èµ·ä¾†è¼ƒã€Œèƒ–ã€ã€‚
                            </p>
                        </div>
                    </div>

                    <div class="flex gap-4 items-start">
                        <div class="w-12 h-12 flex-shrink-0 bg-blue-100 rounded-full flex items-center justify-center text-xl shadow-sm">ğŸ”­</div>
                        <div>
                            <strong class="block text-gray-900">é è™•ç‰©é«” (Long Distance)</strong>
                            <p class="text-sm text-gray-600 mt-1">
                                è·é›¢æ„ˆé ï¼Œå…‰ç·šé€²å…¥çœ¼ç›çš„<strong>ç™¼æ•£è§’åº¦æ„ˆå°</strong>ã€‚å…‰ç·šçœ‹èµ·ä¾†è¶Šä¾†è¶Šã€Œç›´ã€ï¼Œå½¼æ­¤ä¹‹é–“çš„å¤¾è§’é¡¯è‘—è®Šå°ã€‚
                            </p>
                        </div>
                    </div>

                    <div class="flex gap-4 items-start">
                        <div class="w-12 h-12 flex-shrink-0 bg-gray-100 rounded-full flex items-center justify-center text-xl shadow-sm">â™¾ï¸</div>
                        <div>
                            <strong class="block text-gray-900">ç„¡é™é  (Infinite)</strong>
                            <p class="text-sm text-gray-600 mt-1">
                                ç•¶ç‰©é«”ä½æ–¼ç„¡é™é æ™‚ï¼Œç™¼æ•£è§’åº¦è¶¨è¿‘æ–¼<strong>é›¶</strong>ï¼Œé€²å…¥çœ¼ç›çš„å…‰ç·šè¦–ç‚º<strong>å¹³è¡Œå…‰</strong>ã€‚
                            </p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Modal Footer -->
            <div class="bg-gray-50 p-4 flex justify-end flex-shrink-0">
                <button onclick="toggleModal(false)" class="px-5 py-2 bg-gray-200 hover:bg-gray-300 text-gray-800 rounded-lg font-medium transition">
                    æ˜ç™½äº†
                </button>
            </div>
        </div>
    </div>

    <script>
        // State
        const state = {
            objectType: 'luminous', // 'luminous' or 'non-luminous'
            distance: 300,
            isInfinite: false,
            pupilSize: 30,
            canvasWidth: 800,
            canvasHeight: 450,
            isDragging: false // æ–°å¢ï¼šæ‹–æ›³ç‹€æ…‹
        };

        // DOM Elements
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        const distanceSlider = document.getElementById('distance-slider');
        const distanceValue = document.getElementById('distance-value');
        const pupilSlider = document.getElementById('pupil-slider');
        const pupilValue = document.getElementById('pupil-value');
        const infiniteToggle = document.getElementById('infinite-toggle');
        const btnLuminous = document.getElementById('btn-luminous');
        const btnNonLuminous = document.getElementById('btn-nonluminous');
        const typeDesc = document.getElementById('type-desc');
        const conceptText = document.getElementById('concept-text');
        
        // Modal Logic
        const modal = document.getElementById('info-modal');
        const modalContent = modal.querySelector('div');

        function toggleModal(show) {
            if (show) {
                modal.classList.remove('hidden');
                // Simple animation delay
                setTimeout(() => {
                    modal.classList.remove('opacity-0');
                    modalContent.classList.remove('scale-95');
                    modalContent.classList.add('scale-100');
                }, 10);
                
                // ç¢ºä¿åœ¨ Modal é¡¯ç¤ºå¾Œç¹ªè£½æ­£é¢åœ–
                requestAnimationFrame(drawEyeFront);
            } else {
                modal.classList.add('opacity-0');
                modalContent.classList.remove('scale-100');
                modalContent.classList.add('scale-95');
                setTimeout(() => {
                    modal.classList.add('hidden');
                }, 300);
            }
        }

        function drawEyeFront() {
            const c = document.getElementById('eyeModalCanvas');
            if(!c) return;
            const context = c.getContext('2d');
            const w = c.width;
            const h = c.height;
            const cx = w / 2;
            const cy = h / 2;

            context.clearRect(0, 0, w, h);

            // 1. çœ¼ç™½ (Sclera) - æ©¢åœ“
            context.beginPath();
            context.ellipse(cx, cy, 70, 45, 0, 0, Math.PI * 2);
            context.fillStyle = "#F3F4F6"; // soft white
            context.fill();
            context.lineWidth = 1;
            context.strokeStyle = "#D1D5DB";
            context.stroke();

            // 2. è™¹è†œ (Iris) - åœ“å½¢
            context.beginPath();
            context.arc(cx, cy, 32, 0, Math.PI * 2);
            context.fillStyle = "#60A5FA"; // blue
            context.fill();
            // è™¹è†œç´‹ç† (ç°¡å–®ç¤ºæ„)
            context.strokeStyle = "rgba(255,255,255,0.3)";
            context.lineWidth = 1;
            for(let i=0; i<12; i++) {
                context.beginPath();
                context.moveTo(cx, cy);
                context.lineTo(cx + Math.cos(i*Math.PI/6)*32, cy + Math.sin(i*Math.PI/6)*32);
                context.stroke();
            }

            // 3. ç³å­” (Pupil) - åœ“å½¢ï¼Œä¸”ç‚ºé»‘è‰²
            // ç‚ºäº†ç¤ºæ„ï¼Œä½¿ç”¨ä¸€å€‹å›ºå®šå¤§å°ï¼Œæˆ–ç¨å¾®å‘¼æ‡‰ç•¶å‰è¨­å®š
            const demoPupilSize = 15; // ç¤ºæ„åœ–å›ºå®šå¤§å°ï¼Œç¢ºä¿æ¸…æ™°
            context.beginPath();
            context.arc(cx, cy, demoPupilSize, 0, Math.PI * 2);
            context.fillStyle = "#1F2937"; // dark gray/black
            context.fill();

            // 4. åå…‰ (Highlight) - å¢åŠ ç«‹é«”æ„Ÿ
            context.beginPath();
            context.arc(cx + 8, cy - 8, 4, 0, Math.PI * 2);
            context.fillStyle = "rgba(255,255,255,0.6)";
            context.fill();

            // 5. æ¨™è¨»ç·š
            context.strokeStyle = "#4B5563";
            context.lineWidth = 1.5;
            context.font = "12px Arial";
            context.fillStyle = "#374151";

            // æ¨™ç¤ºç³å­”
            context.beginPath();
            context.moveTo(cx, cy);
            context.lineTo(cx + 60, cy - 30);
            context.lineTo(cx + 90, cy - 30);
            context.stroke();
            context.fillText("ç³å­” (åœ“å½¢)", cx + 95, cy - 26);
        }

        // Close modal when clicking outside
        modal.addEventListener('click', (e) => {
            if (e.target === modal) toggleModal(false);
        });

        // Initialization
        function init() {
            // Set canvas internal resolution
            canvas.width = state.canvasWidth;
            canvas.height = state.canvasHeight;
            
            // Add Drag Event Listeners
            canvas.addEventListener('mousedown', handleStart);
            canvas.addEventListener('mousemove', handleMove);
            window.addEventListener('mouseup', handleEnd);
            
            // Touch support
            canvas.addEventListener('touchstart', handleStart, {passive: false});
            canvas.addEventListener('touchmove', handleMove, {passive: false});
            window.addEventListener('touchend', handleEnd);

            updateSimulation();
        }

        // Interaction Handlers (Drag & Drop)
        function getMousePos(evt) {
            const rect = canvas.getBoundingClientRect();
            const clientX = evt.clientX || (evt.touches && evt.touches[0].clientX);
            const clientY = evt.clientY || (evt.touches && evt.touches[0].clientY);
            
            if (clientX === undefined) return { x: 0, y: 0 };

            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        function isMouseOverObject(pos) {
            if (state.isInfinite) return false;
            
            const eyeX = canvas.width - 100;
            const objectX = eyeX - state.distance;
            const objectY = canvas.height / 2;
            
            // Hit box area (approx 50px radius)
            const dx = pos.x - objectX;
            const dy = pos.y - objectY;
            return (dx * dx + dy * dy) < 3600; // 60px radius for easier grabbing
        }

        function handleStart(e) {
            const pos = getMousePos(e);
            if (isMouseOverObject(pos)) {
                state.isDragging = true;
                if (e.type === 'touchstart') e.preventDefault(); // Prevent scrolling on mobile
                canvas.style.cursor = 'grabbing';
            }
        }

        function handleMove(e) {
            const pos = getMousePos(e);
            
            // Hover effect
            if (!state.isDragging) {
                if (isMouseOverObject(pos)) {
                    canvas.style.cursor = 'grab';
                } else {
                    canvas.style.cursor = 'default';
                }
                return;
            }

            // Dragging logic
            if (state.isDragging) {
                if (e.type === 'touchmove') e.preventDefault();
                
                const eyeX = canvas.width - 100;
                let newDist = eyeX - pos.x;
                
                // Clamp distance to slider limits
                const min = parseInt(distanceSlider.min);
                const max = parseInt(distanceSlider.max);
                
                if (newDist < min) newDist = min;
                if (newDist > max) newDist = max;
                
                // Update Slider (Sync)
                distanceSlider.value = Math.round(newDist);
                
                // Trigger global update
                updateSimulation();
            }
        }

        function handleEnd(e) {
            if (state.isDragging) {
                state.isDragging = false;
                canvas.style.cursor = 'grab';
            }
        }

        // Action Handlers
        function setObjectType(type) {
            state.objectType = type;
            
            // UI Updates
            if (type === 'luminous') {
                btnLuminous.classList.remove('border-gray-300', 'bg-gray-50', 'text-gray-600');
                btnLuminous.classList.add('border-yellow-500', 'bg-yellow-50', 'text-yellow-700');
                
                btnNonLuminous.classList.remove('border-red-500', 'bg-red-50', 'text-red-700');
                btnNonLuminous.classList.add('border-gray-300', 'bg-gray-50', 'text-gray-600');
                
                typeDesc.textContent = "ç™¼å…‰é«”æœƒè‡ªè¡Œç™¼å‡ºå…‰ç·šï¼ˆä¾‹å¦‚ï¼šè Ÿç‡­ã€å¤ªé™½ï¼‰ã€‚å…‰ç·šå¾ç‰©é«”ç›´æ¥å°„å‘çœ¼ç›ã€‚";
            } else {
                btnNonLuminous.classList.remove('border-gray-300', 'bg-gray-50', 'text-gray-600');
                btnNonLuminous.classList.add('border-red-500', 'bg-red-50', 'text-red-700');
                
                btnLuminous.classList.remove('border-yellow-500', 'bg-yellow-50', 'text-yellow-700');
                btnLuminous.classList.add('border-gray-300', 'bg-gray-50', 'text-gray-600');
                
                typeDesc.textContent = "éç™¼å…‰é«”æœ¬èº«ä¸ç™¼å…‰ï¼ˆä¾‹å¦‚ï¼šè˜‹æœï¼‰ã€‚éœ€è¦å¤–éƒ¨å…‰æºç…§å°„ï¼Œåå°„çš„å…‰ç·šé€²å…¥çœ¼ç›æ‰èƒ½è¢«çœ‹è¦‹ã€‚";
            }
            updateSimulation();
        }

        function toggleInfinite() {
            state.isInfinite = infiniteToggle.checked;
            distanceSlider.disabled = state.isInfinite;
            distanceSlider.parentElement.style.opacity = state.isInfinite ? '0.5' : '1';
            
            if (state.isInfinite) {
                conceptText.textContent = "ç•¶ç‰©é«”ä½æ–¼ç„¡é™é æ™‚ï¼Œåˆ°é”çœ¼ç›çš„å…‰ç·šå¹¾ä¹æ˜¯å¹³è¡Œçš„ã€‚";
            } else {
                conceptText.textContent = "ç‰©é«”ç™¼å‡ºçš„å…‰æ˜¯å‘å››é¢å…«æ–¹æ“´æ•£çš„ï¼Œä½†åªæœ‰å°„å…¥ç³å­”ç¯„åœå…§çš„å…‰ç·šï¼ˆé»ƒè‰²å€åŸŸï¼‰æ‰èƒ½è¢«æˆ‘å€‘çœ‹è¦‹ã€‚";
            }
            
            updateSimulation();
        }

        function updateSimulation() {
            // Update State from DOM
            if (!state.isInfinite) {
                state.distance = parseInt(distanceSlider.value);
                distanceValue.textContent = state.distance + "cm";
            } else {
                distanceValue.textContent = "ç„¡é™é ";
            }
            
            state.pupilSize = parseInt(pupilSlider.value);
            pupilValue.textContent = state.pupilSize + "mm";

            // Redraw
            draw();
        }

        // Drawing Logic
        function draw() {
            // Clear Canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const eyeX = canvas.width - 100;
            const eyeY = canvas.height / 2;
            const objectX = eyeX - state.distance;
            const objectY = eyeY; // Align on axis for simplicity

            // 1. Draw Environment (Light Source for Non-Luminous)
            if (state.objectType === 'non-luminous' && !state.isInfinite) {
                drawLamp(100, 50);
                // Draw ray from lamp to object
                ctx.beginPath();
                ctx.moveTo(100, 50);
                ctx.lineTo(objectX, objectY);
                ctx.strokeStyle = "rgba(255, 255, 200, 0.6)"; // ç¨å¾®èª¿äº®ä¸€é»
                ctx.lineWidth = 2;
                ctx.setLineDash([]); // ç¢ºä¿æ˜¯å¯¦ç·š
                ctx.stroke();
                
                // åœ¨ç·šæ®µä¸­é–“ç•«ç®­é ­
                const midX = (100 + objectX) / 2;
                const midY = (50 + objectY) / 2;
                const angle = Math.atan2(objectY - 50, objectX - 100);

                ctx.save();
                ctx.translate(midX, midY);
                ctx.rotate(angle);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-10, -5);
                ctx.lineTo(-10, 5);
                ctx.closePath();
                ctx.fillStyle = "rgba(255, 255, 200, 1)";
                ctx.fill();
                ctx.restore();
                
                // Label
                ctx.fillStyle = "#FFF";
                ctx.font = "14px Arial";
                ctx.fillText("å…‰æº", 80, 40);
            }

            // 2. Draw Rays (The Light Cone)
            ctx.globalCompositeOperation = 'screen'; // Make overlapping light brighter

            const pupilTopY = eyeY - (state.pupilSize / 2);
            const pupilBottomY = eyeY + (state.pupilSize / 2);

            if (state.isInfinite) {
                // Infinite: Parallel rays
                ctx.fillStyle = "rgba(255, 255, 0, 0.15)";
                ctx.fillRect(0, pupilTopY, eyeX, state.pupilSize);
                
                // Draw border lines for clarity
                ctx.strokeStyle = "rgba(255, 255, 0, 0.6)";
                ctx.lineWidth = 2;
                ctx.beginPath();
                // Ray 1
                ctx.moveTo(0, pupilTopY);
                ctx.lineTo(eyeX, pupilTopY);
                // Ray 2
                ctx.moveTo(0, pupilBottomY);
                ctx.lineTo(eyeX, pupilBottomY);
                // Ray 3 (Center)
                ctx.moveTo(0, eyeY);
                ctx.lineTo(eyeX, eyeY);
                ctx.stroke();
                
                // Draw arrows
                drawArrow(ctx, 300, pupilTopY, 20);
                drawArrow(ctx, 300, pupilBottomY, 20);

            } else {
                // Finite Distance: Cone
                
                // Fill the cone
                ctx.beginPath();
                ctx.moveTo(objectX, objectY);
                ctx.lineTo(eyeX, pupilTopY);
                ctx.lineTo(eyeX, pupilBottomY);
                ctx.closePath();
                ctx.fillStyle = "rgba(255, 255, 0, 0.2)";
                ctx.fill();

                // Draw the boundary rays (Only rays entering the eye)
                ctx.beginPath();
                ctx.moveTo(objectX, objectY);
                ctx.lineTo(eyeX, pupilTopY);
                ctx.moveTo(objectX, objectY);
                ctx.lineTo(eyeX, pupilBottomY);
                
                // Removed extra rays per request
                
                ctx.strokeStyle = "rgba(255, 255, 0, 0.8)";
                ctx.lineWidth = 2;
                ctx.stroke();

                // Removed dotted lines for missing rays

                // Arrows on rays
                const midX = (objectX + eyeX) / 2;
                const midTopY = (objectY + pupilTopY) / 2;
                const midBotY = (objectY + pupilBottomY) / 2;
                drawArrow(ctx, midX, midTopY, 0); // Rotation handled loosely
                drawArrow(ctx, midX, midBotY, 0);
            }

            ctx.globalCompositeOperation = 'source-over';

            // 3. Draw Object
            if (!state.isInfinite) {
                if (state.objectType === 'luminous') {
                    drawCandle(objectX, objectY);
                } else {
                    drawApple(objectX, objectY);
                }
            } else {
                // Hint for infinite
                ctx.fillStyle = "#FFF";
                ctx.font = "20px Arial";
                ctx.textAlign = "left";
                ctx.fillText("ä¾†è‡ªç„¡é™é çš„å…‰æº (å¦‚: æ˜Ÿæ˜Ÿ)", 20, eyeY - 50);
            }

            // 4. Draw Eye
            drawEye(eyeX, eyeY, state.pupilSize);
        }

        // Graphic Helpers
        function drawEye(x, y, aperture) {
            ctx.save();
            
            // Eyeball (White part)
            ctx.beginPath();
            ctx.arc(x + 40, y, 70, 0, Math.PI * 2);
            ctx.fillStyle = "#E5E7EB";
            ctx.fill();

            // Cornea/Front of eye curve
            ctx.beginPath();
            ctx.moveTo(x, y - 80);
            ctx.quadraticCurveTo(x - 20, y, x, y + 80);
            ctx.strokeStyle = "#9CA3AF";
            ctx.lineWidth = 2;
            ctx.stroke();

            // Iris/Blockers (The parts blocking light)
            ctx.fillStyle = "#60A5FA"; // Blue eye
            
            // Top Iris
            ctx.beginPath();
            ctx.moveTo(x, y - 80);
            ctx.quadraticCurveTo(x - 15, y - 40, x, y - (aperture/2)); // Inner edge based on aperture
            ctx.lineTo(x + 10, y - (aperture/2));
            ctx.lineTo(x + 10, y - 80);
            ctx.fill();

            // Bottom Iris
            ctx.beginPath();
            ctx.moveTo(x, y + 80);
            ctx.quadraticCurveTo(x - 15, y + 40, x, y + (aperture/2));
            ctx.lineTo(x + 10, y + (aperture/2));
            ctx.lineTo(x + 10, y + 80);
            ctx.fill();

            // Retina (Back of eye)
            ctx.beginPath();
            ctx.arc(x + 40, y, 65, -Math.PI/2, Math.PI/2, false);
            ctx.strokeStyle = "#F87171";
            ctx.lineWidth = 4;
            ctx.stroke();
            
            // Label
            ctx.fillStyle = "#FFFFFF"; // æ”¹ç‚ºç™½è‰²
            ctx.font = "14px Arial";
            
            // è¦–ç¶²è†œï¼šæ”¾åœ¨çœ¼çƒå³å´å¤–
            ctx.textAlign = "left";
            ctx.fillText("è¦–ç¶²è†œ", x + 120, y + 5);
            
            // ç³å­”ï¼šæ”¾åœ¨çœ¼ç›çµæ§‹ä¸‹æ–¹ï¼Œé¿å…é®æ“‹
            ctx.textAlign = "center";
            ctx.fillText("ç³å­”", x, y + 105);

            ctx.restore();
        }

        function drawCandle(x, y) {
            ctx.save();
            ctx.translate(x, y);
            
            // Candle body
            ctx.fillStyle = "#DDDDDD";
            ctx.fillRect(-10, 10, 20, 50);
            
            // Wick
            ctx.fillStyle = "#333";
            ctx.fillRect(-1, 0, 2, 10);

            // Flame
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.quadraticCurveTo(-10, -15, 0, -30);
            ctx.quadraticCurveTo(10, -15, 0, 0);
            ctx.fillStyle = "#F59E0B";
            ctx.fill();
            
            // Glow
            ctx.beginPath();
            ctx.arc(0, -15, 20, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(255, 200, 0, 0.3)";
            ctx.fill();

            ctx.fillStyle = "#FFF";
            ctx.font = "14px Arial";
            ctx.textAlign = "center";
            ctx.fillText("ç™¼å…‰é«”", 0, 80);

            ctx.restore();
        }

        function drawApple(x, y) {
            ctx.save();
            ctx.translate(x, y);

            // Apple body
            ctx.beginPath();
            ctx.arc(0, 10, 20, 0, Math.PI*2);
            ctx.fillStyle = "#EF4444";
            ctx.fill();
            
            // Leaf
            ctx.beginPath();
            ctx.ellipse(5, -10, 8, 4, Math.PI/4, 0, Math.PI*2);
            ctx.fillStyle = "#10B981";
            ctx.fill();

            ctx.fillStyle = "#FFF";
            ctx.font = "14px Arial";
            ctx.textAlign = "center";
            ctx.fillText("éç™¼å…‰é«”", 0, 50);

            ctx.restore();
        }

        function drawLamp(x, y) {
            ctx.save();
            ctx.translate(x, y);
            
            // Bulb
            ctx.beginPath();
            ctx.arc(0, 0, 15, 0, Math.PI*2);
            ctx.fillStyle = "#FEF3C7";
            ctx.fill();
            ctx.strokeStyle = "#F59E0B";
            ctx.lineWidth = 2;
            ctx.stroke();

            // Rays from lamp
            for(let i=0; i<8; i++) {
                ctx.rotate(Math.PI/4);
                ctx.beginPath();
                ctx.moveTo(20, 0);
                ctx.lineTo(30, 0);
                ctx.stroke();
            }

            ctx.restore();
        }

        function drawArrow(context, x, y, size) {
            // Simple arrow head on the line
            context.beginPath();
            context.moveTo(x, y);
            context.lineTo(x - 10, y - 5);
            context.moveTo(x, y);
            context.lineTo(x - 10, y + 5);
            context.strokeStyle = "rgba(255,255,0,1)";
            context.lineWidth = 2;
            context.stroke();
        }

        // Init
        window.addEventListener('load', init);

    </script>
</body>
</html>